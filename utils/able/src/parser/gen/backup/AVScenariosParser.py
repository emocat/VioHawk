# Generated from AVScenarios.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3m")
        buf.write("\u05e0\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084")
        buf.write("\t\u0084\4\u0085\t\u0085\4\u0086\t\u0086\4\u0087\t\u0087")
        buf.write("\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a\4\u008b")
        buf.write("\t\u008b\4\u008c\t\u008c\3\2\3\2\5\2\u011b\n\2\3\3\3\3")
        buf.write("\3\3\5\3\u0120\n\3\3\3\3\3\3\3\7\3\u0125\n\3\f\3\16\3")
        buf.write("\u0128\13\3\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4\u0131\n\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\3\4\7\4\u013c\n\4\f\4")
        buf.write("\16\4\u013f\13\4\3\5\3\5\3\5\3\5\3\5\3\5\3\5\5\5\u0148")
        buf.write("\n\5\3\5\3\5\3\5\3\5\3\5\3\5\7\5\u0150\n\5\f\5\16\5\u0153")
        buf.write("\13\5\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6")
        buf.write("\3\6\3\6\3\6\3\6\3\7\3\7\3\7\3\7\5\7\u0169\n\7\3\b\3\b")
        buf.write("\3\b\3\b\5\b\u016f\n\b\3\t\3\t\3\t\3\t\5\t\u0175\n\t\3")
        buf.write("\n\3\n\3\n\3\n\3\n\3\13\3\13\3\f\3\f\5\f\u0180\n\f\3\r")
        buf.write("\3\r\3\r\3\r\3\r\3\16\3\16\3\16\3\16\3\16\5\16\u018c\n")
        buf.write("\16\3\17\3\17\5\17\u0190\n\17\3\20\3\20\3\20\3\20\3\20")
        buf.write("\3\20\3\20\3\20\5\20\u019a\n\20\3\20\3\20\5\20\u019e\n")
        buf.write("\20\3\20\3\20\5\20\u01a2\n\20\3\21\5\21\u01a5\n\21\3\21")
        buf.write("\3\21\3\21\3\21\3\21\5\21\u01ac\n\21\3\21\3\21\3\21\3")
        buf.write("\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21")
        buf.write("\5\21\u01bc\n\21\3\22\3\22\3\22\5\22\u01c1\n\22\3\23\3")
        buf.write("\23\5\23\u01c5\n\23\3\24\3\24\5\24\u01c9\n\24\3\25\3\25")
        buf.write("\3\25\3\25\3\25\3\25\3\25\3\25\5\25\u01d3\n\25\3\26\5")
        buf.write("\26\u01d6\n\26\3\26\3\26\3\27\3\27\5\27\u01dc\n\27\3\30")
        buf.write("\3\30\3\31\3\31\3\31\5\31\u01e3\n\31\3\32\3\32\3\32\3")
        buf.write("\32\3\32\3\32\3\32\5\32\u01ec\n\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\5\32\u01fd\n\32\3\33\3\33\5\33\u0201\n\33\3\34\3\34\3")
        buf.write("\35\3\35\5\35\u0207\n\35\3\36\3\36\3\36\3\36\5\36\u020d")
        buf.write("\n\36\3\36\3\36\3\36\3\36\3\36\5\36\u0214\n\36\3\36\3")
        buf.write("\36\3\36\3\36\5\36\u021a\n\36\3\36\3\36\3\36\3\36\3\36")
        buf.write("\3\36\3\36\3\36\3\36\5\36\u0225\n\36\3\36\3\36\3\36\3")
        buf.write("\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\5\36\u0232\n\36")
        buf.write("\5\36\u0234\n\36\3\37\3\37\5\37\u0238\n\37\3 \3 \3!\3")
        buf.write("!\3!\3!\3!\3!\5!\u0242\n!\3\"\3\"\5\"\u0246\n\"\3#\3#")
        buf.write("\3#\3#\3#\3#\3#\3#\5#\u0250\n#\3#\3#\5#\u0254\n#\3$\3")
        buf.write("$\5$\u0258\n$\3%\3%\5%\u025c\n%\3&\3&\3\'\3\'\3\'\3\'")
        buf.write("\3\'\3\'\3\'\5\'\u0267\n\'\3(\3(\5(\u026b\n(\3)\3)\5)")
        buf.write("\u026f\n)\3*\3*\3*\3*\3*\5*\u0276\n*\3+\3+\3,\3,\3,\3")
        buf.write(",\3-\3-\3-\3-\3-\3-\7-\u0284\n-\f-\16-\u0287\13-\3.\3")
        buf.write(".\3.\3.\3.\3/\3/\5/\u0290\n/\3\60\3\60\3\60\3\60\3\60")
        buf.write("\3\60\3\60\3\60\5\60\u029a\n\60\3\60\3\60\5\60\u029e\n")
        buf.write("\60\3\60\3\60\5\60\u02a2\n\60\5\60\u02a4\n\60\3\61\3\61")
        buf.write("\5\61\u02a8\n\61\3\62\3\62\5\62\u02ac\n\62\3\63\3\63\3")
        buf.write("\63\3\63\3\63\3\64\3\64\5\64\u02b5\n\64\3\65\3\65\3\65")
        buf.write("\3\65\3\65\3\66\3\66\5\66\u02be\n\66\3\67\3\67\3\67\3")
        buf.write("\67\38\38\38\38\38\38\78\u02ca\n8\f8\168\u02cd\138\39")
        buf.write("\39\39\39\39\39\59\u02d5\n9\3:\3:\3:\3:\3;\3;\3;\3;\3")
        buf.write(";\3;\7;\u02e1\n;\f;\16;\u02e4\13;\3<\3<\5<\u02e8\n<\3")
        buf.write("=\3=\3=\3=\3=\3>\3>\3>\3>\3>\3>\3>\3>\5>\u02f7\n>\3>\3")
        buf.write(">\5>\u02fb\n>\3>\3>\5>\u02ff\n>\5>\u0301\n>\3?\3?\5?\u0305")
        buf.write("\n?\3@\3@\5@\u0309\n@\3A\3A\3A\5A\u030e\nA\3B\3B\3B\3")
        buf.write("B\3B\3B\3C\3C\5C\u0318\nC\3D\3D\3E\3E\3E\3E\3F\3F\3F\3")
        buf.write("F\3F\3F\7F\u0326\nF\fF\16F\u0329\13F\3G\3G\5G\u032d\n")
        buf.write("G\3H\3H\3H\3H\3H\3I\3I\3I\5I\u0337\nI\3J\3J\5J\u033b\n")
        buf.write("J\3K\3K\3K\3K\5K\u0341\nK\3L\3L\3L\3L\3L\3L\3M\3M\3M\3")
        buf.write("M\3M\3M\3M\3M\3M\3M\3N\3N\3N\3N\3N\3N\3N\3N\3N\3N\3O\3")
        buf.write("O\3O\3O\3O\3O\3O\3O\3O\3O\3P\3P\3P\3P\5P\u036b\nP\3Q\3")
        buf.write("Q\3Q\3Q\3Q\3R\3R\3R\3R\3S\3S\5S\u0378\nS\3T\3T\5T\u037c")
        buf.write("\nT\3U\3U\3V\3V\3V\3V\3W\3W\3W\3W\3W\3W\7W\u038a\nW\f")
        buf.write("W\16W\u038d\13W\3X\3X\5X\u0391\nX\3Y\3Y\3Y\3Y\3Y\3Y\3")
        buf.write("Y\3Y\5Y\u039b\nY\3Z\3Z\3Z\3Z\3Z\5Z\u03a2\nZ\3[\3[\5[\u03a6")
        buf.write("\n[\3\\\3\\\5\\\u03aa\n\\\3]\3]\3]\5]\u03af\n]\3^\3^\3")
        buf.write("^\3^\3_\3_\3_\3_\3`\3`\3`\7`\u03bc\n`\f`\16`\u03bf\13")
        buf.write("`\3a\3a\5a\u03c3\na\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3b\3")
        buf.write("c\3c\5c\u03d2\nc\3d\5d\u03d5\nd\3d\3d\3e\3e\3e\3e\3e\3")
        buf.write("e\7e\u03df\ne\fe\16e\u03e2\13e\3f\3f\5f\u03e6\nf\3g\3")
        buf.write("g\3g\3g\3g\3g\3g\3h\3h\5h\u03f1\nh\3i\3i\3i\3i\3i\3i\3")
        buf.write("j\3j\3j\3j\3j\3j\3j\3j\3k\3k\3l\3l\3m\3m\3m\3m\3m\3m\3")
        buf.write("m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\5")
        buf.write("m\u041d\nm\3n\3n\3n\3n\3n\3n\3n\3n\5n\u0427\nn\3o\3o\3")
        buf.write("p\3p\3q\3q\3q\3q\3q\3q\3q\5q\u0434\nq\3q\3q\3q\3q\7q\u043a")
        buf.write("\nq\fq\16q\u043d\13q\3r\3r\3r\3r\3r\3r\5r\u0445\nr\3s")
        buf.write("\3s\3s\3s\3s\3s\3s\3t\3t\3t\3t\3t\5t\u0453\nt\3u\3u\5")
        buf.write("u\u0457\nu\3v\3v\3v\3v\3v\3w\3w\5w\u0460\nw\3x\3x\3x\3")
        buf.write("x\3x\3x\3x\3x\3y\3y\5y\u046c\ny\3z\3z\3z\3z\3z\3z\3z\3")
        buf.write("z\3{\3{\3{\3{\3{\3{\3{\3|\3|\3|\3|\3|\3|\3|\3}\3}\3}\3")
        buf.write("}\3}\5}\u0489\n}\3~\3~\5~\u048d\n~\3\177\3\177\3\u0080")
        buf.write("\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0080\3\u0081")
        buf.write("\3\u0081\3\u0081\3\u0081\3\u0081\5\u0081\u049d\n\u0081")
        buf.write("\3\u0082\3\u0082\3\u0082\3\u0082\3\u0082\3\u0082\3\u0082")
        buf.write("\3\u0083\3\u0083\3\u0083\3\u0083\3\u0083\5\u0083\u04ab")
        buf.write("\n\u0083\3\u0084\3\u0084\3\u0085\3\u0085\3\u0086\3\u0086")
        buf.write("\3\u0086\3\u0086\3\u0087\3\u0087\3\u0087\3\u0087\3\u0087")
        buf.write("\3\u0087\3\u0087\3\u0087\3\u0087\3\u0087\3\u0087\3\u0087")
        buf.write("\5\u0087\u04c1\n\u0087\3\u0087\3\u0087\3\u0087\3\u0087")
        buf.write("\3\u0087\3\u0087\3\u0087\3\u0087\3\u0087\3\u0087\3\u0087")
        buf.write("\3\u0087\3\u0087\7\u0087\u04d0\n\u0087\f\u0087\16\u0087")
        buf.write("\u04d3\13\u0087\3\u0088\3\u0088\3\u0088\3\u0088\5\u0088")
        buf.write("\u04d9\n\u0088\3\u0089\3\u0089\3\u0089\7\u0089\u04de\n")
        buf.write("\u0089\f\u0089\16\u0089\u04e1\13\u0089\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\5\u008a\u051b")
        buf.write("\n\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\5\u008a\u0524\n\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\5\u008a\u052b\n\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\5\u008a\u0534")
        buf.write("\n\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\7\u008a\u0566\n\u008a\f\u008a\16\u008a\u0569\13\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\5\u008a")
        buf.write("\u05da\n\u008a\3\u008b\3\u008b\3\u008c\3\u008c\3\u008c")
        buf.write("\2\r\4\6\bXnt\u008a\u00ac\u00c8\u00e0\u010c\u008d\2\4")
        buf.write("\6\b\n\f\16\20\22\24\26\30\32\34\36 \"$&(*,.\60\62\64")
        buf.write("\668:<>@BDFHJLNPRTVXZ\\^`bdfhjlnprtvxz|~\u0080\u0082\u0084")
        buf.write("\u0086\u0088\u008a\u008c\u008e\u0090\u0092\u0094\u0096")
        buf.write("\u0098\u009a\u009c\u009e\u00a0\u00a2\u00a4\u00a6\u00a8")
        buf.write("\u00aa\u00ac\u00ae\u00b0\u00b2\u00b4\u00b6\u00b8\u00ba")
        buf.write("\u00bc\u00be\u00c0\u00c2\u00c4\u00c6\u00c8\u00ca\u00cc")
        buf.write("\u00ce\u00d0\u00d2\u00d4\u00d6\u00d8\u00da\u00dc\u00de")
        buf.write("\u00e0\u00e2\u00e4\u00e6\u00e8\u00ea\u00ec\u00ee\u00f0")
        buf.write("\u00f2\u00f4\u00f6\u00f8\u00fa\u00fc\u00fe\u0100\u0102")
        buf.write("\u0104\u0106\u0108\u010a\u010c\u010e\u0110\u0112\u0114")
        buf.write("\u0116\2\b\3\2\7\b\4\2\3\3\t\t\3\2\26\27\3\2HM\16\2\n")
        buf.write("\n\16\17\23\25\32$*\6499CDGGTTVX_`ff\3\2ad\2\u0639\2\u0118")
        buf.write("\3\2\2\2\4\u011f\3\2\2\2\6\u0130\3\2\2\2\b\u0147\3\2\2")
        buf.write("\2\n\u0154\3\2\2\2\f\u0168\3\2\2\2\16\u016e\3\2\2\2\20")
        buf.write("\u0174\3\2\2\2\22\u0176\3\2\2\2\24\u017b\3\2\2\2\26\u017f")
        buf.write("\3\2\2\2\30\u0181\3\2\2\2\32\u0186\3\2\2\2\34\u018f\3")
        buf.write("\2\2\2\36\u01a1\3\2\2\2 \u01bb\3\2\2\2\"\u01c0\3\2\2\2")
        buf.write("$\u01c4\3\2\2\2&\u01c8\3\2\2\2(\u01d2\3\2\2\2*\u01d5\3")
        buf.write("\2\2\2,\u01db\3\2\2\2.\u01dd\3\2\2\2\60\u01e2\3\2\2\2")
        buf.write("\62\u01fc\3\2\2\2\64\u0200\3\2\2\2\66\u0202\3\2\2\28\u0206")
        buf.write("\3\2\2\2:\u0233\3\2\2\2<\u0237\3\2\2\2>\u0239\3\2\2\2")
        buf.write("@\u0241\3\2\2\2B\u0245\3\2\2\2D\u0253\3\2\2\2F\u0257\3")
        buf.write("\2\2\2H\u025b\3\2\2\2J\u025d\3\2\2\2L\u0266\3\2\2\2N\u026a")
        buf.write("\3\2\2\2P\u026e\3\2\2\2R\u0275\3\2\2\2T\u0277\3\2\2\2")
        buf.write("V\u0279\3\2\2\2X\u027d\3\2\2\2Z\u0288\3\2\2\2\\\u028f")
        buf.write("\3\2\2\2^\u02a3\3\2\2\2`\u02a7\3\2\2\2b\u02ab\3\2\2\2")
        buf.write("d\u02ad\3\2\2\2f\u02b4\3\2\2\2h\u02b6\3\2\2\2j\u02bd\3")
        buf.write("\2\2\2l\u02bf\3\2\2\2n\u02c3\3\2\2\2p\u02d4\3\2\2\2r\u02d6")
        buf.write("\3\2\2\2t\u02da\3\2\2\2v\u02e7\3\2\2\2x\u02e9\3\2\2\2")
        buf.write("z\u0300\3\2\2\2|\u0304\3\2\2\2~\u0308\3\2\2\2\u0080\u030d")
        buf.write("\3\2\2\2\u0082\u030f\3\2\2\2\u0084\u0317\3\2\2\2\u0086")
        buf.write("\u0319\3\2\2\2\u0088\u031b\3\2\2\2\u008a\u031f\3\2\2\2")
        buf.write("\u008c\u032c\3\2\2\2\u008e\u032e\3\2\2\2\u0090\u0333\3")
        buf.write("\2\2\2\u0092\u033a\3\2\2\2\u0094\u0340\3\2\2\2\u0096\u0342")
        buf.write("\3\2\2\2\u0098\u0348\3\2\2\2\u009a\u0352\3\2\2\2\u009c")
        buf.write("\u035c\3\2\2\2\u009e\u036a\3\2\2\2\u00a0\u036c\3\2\2\2")
        buf.write("\u00a2\u0371\3\2\2\2\u00a4\u0377\3\2\2\2\u00a6\u037b\3")
        buf.write("\2\2\2\u00a8\u037d\3\2\2\2\u00aa\u037f\3\2\2\2\u00ac\u0383")
        buf.write("\3\2\2\2\u00ae\u0390\3\2\2\2\u00b0\u039a\3\2\2\2\u00b2")
        buf.write("\u03a1\3\2\2\2\u00b4\u03a5\3\2\2\2\u00b6\u03a9\3\2\2\2")
        buf.write("\u00b8\u03ae\3\2\2\2\u00ba\u03b0\3\2\2\2\u00bc\u03b4\3")
        buf.write("\2\2\2\u00be\u03b8\3\2\2\2\u00c0\u03c2\3\2\2\2\u00c2\u03c4")
        buf.write("\3\2\2\2\u00c4\u03d1\3\2\2\2\u00c6\u03d4\3\2\2\2\u00c8")
        buf.write("\u03d8\3\2\2\2\u00ca\u03e5\3\2\2\2\u00cc\u03e7\3\2\2\2")
        buf.write("\u00ce\u03f0\3\2\2\2\u00d0\u03f2\3\2\2\2\u00d2\u03f8\3")
        buf.write("\2\2\2\u00d4\u0400\3\2\2\2\u00d6\u0402\3\2\2\2\u00d8\u041c")
        buf.write("\3\2\2\2\u00da\u0426\3\2\2\2\u00dc\u0428\3\2\2\2\u00de")
        buf.write("\u042a\3\2\2\2\u00e0\u0433\3\2\2\2\u00e2\u0444\3\2\2\2")
        buf.write("\u00e4\u0446\3\2\2\2\u00e6\u0452\3\2\2\2\u00e8\u0456\3")
        buf.write("\2\2\2\u00ea\u0458\3\2\2\2\u00ec\u045f\3\2\2\2\u00ee\u0461")
        buf.write("\3\2\2\2\u00f0\u046b\3\2\2\2\u00f2\u046d\3\2\2\2\u00f4")
        buf.write("\u0475\3\2\2\2\u00f6\u047c\3\2\2\2\u00f8\u0488\3\2\2\2")
        buf.write("\u00fa\u048c\3\2\2\2\u00fc\u048e\3\2\2\2\u00fe\u0490\3")
        buf.write("\2\2\2\u0100\u049c\3\2\2\2\u0102\u049e\3\2\2\2\u0104\u04aa")
        buf.write("\3\2\2\2\u0106\u04ac\3\2\2\2\u0108\u04ae\3\2\2\2\u010a")
        buf.write("\u04b0\3\2\2\2\u010c\u04c0\3\2\2\2\u010e\u04d8\3\2\2\2")
        buf.write("\u0110\u04df\3\2\2\2\u0112\u05d9\3\2\2\2\u0114\u05db\3")
        buf.write("\2\2\2\u0116\u05dd\3\2\2\2\u0118\u011a\5\u0110\u0089\2")
        buf.write("\u0119\u011b\7\2\2\3\u011a\u0119\3\2\2\2\u011a\u011b\3")
        buf.write("\2\2\2\u011b\3\3\2\2\2\u011c\u011d\b\3\1\2\u011d\u0120")
        buf.write("\7e\2\2\u011e\u0120\5\u0114\u008b\2\u011f\u011c\3\2\2")
        buf.write("\2\u011f\u011e\3\2\2\2\u0120\u0126\3\2\2\2\u0121\u0122")
        buf.write("\f\4\2\2\u0122\u0123\7\3\2\2\u0123\u0125\5\4\3\5\u0124")
        buf.write("\u0121\3\2\2\2\u0125\u0128\3\2\2\2\u0126\u0124\3\2\2\2")
        buf.write("\u0126\u0127\3\2\2\2\u0127\5\3\2\2\2\u0128\u0126\3\2\2")
        buf.write("\2\u0129\u012a\b\4\1\2\u012a\u0131\5*\26\2\u012b\u012c")
        buf.write("\7\4\2\2\u012c\u012d\5\6\4\2\u012d\u012e\7\5\2\2\u012e")
        buf.write("\u0131\3\2\2\2\u012f\u0131\5\u0114\u008b\2\u0130\u0129")
        buf.write("\3\2\2\2\u0130\u012b\3\2\2\2\u0130\u012f\3\2\2\2\u0131")
        buf.write("\u013d\3\2\2\2\u0132\u0133\f\6\2\2\u0133\u0134\7\6\2\2")
        buf.write("\u0134\u013c\5\6\4\7\u0135\u0136\f\5\2\2\u0136\u0137\t")
        buf.write("\2\2\2\u0137\u013c\5\6\4\6\u0138\u0139\f\4\2\2\u0139\u013a")
        buf.write("\t\3\2\2\u013a\u013c\5\6\4\5\u013b\u0132\3\2\2\2\u013b")
        buf.write("\u0135\3\2\2\2\u013b\u0138\3\2\2\2\u013c\u013f\3\2\2\2")
        buf.write("\u013d\u013b\3\2\2\2\u013d\u013e\3\2\2\2\u013e\7\3\2\2")
        buf.write("\2\u013f\u013d\3\2\2\2\u0140\u0141\b\5\1\2\u0141\u0148")
        buf.write("\5\62\32\2\u0142\u0143\7\4\2\2\u0143\u0144\5\b\5\2\u0144")
        buf.write("\u0145\7\5\2\2\u0145\u0148\3\2\2\2\u0146\u0148\5\u0114")
        buf.write("\u008b\2\u0147\u0140\3\2\2\2\u0147\u0142\3\2\2\2\u0147")
        buf.write("\u0146\3\2\2\2\u0148\u0151\3\2\2\2\u0149\u014a\f\5\2\2")
        buf.write("\u014a\u014b\t\2\2\2\u014b\u0150\5\b\5\6\u014c\u014d\f")
        buf.write("\4\2\2\u014d\u014e\t\3\2\2\u014e\u0150\5\b\5\5\u014f\u0149")
        buf.write("\3\2\2\2\u014f\u014c\3\2\2\2\u0150\u0153\3\2\2\2\u0151")
        buf.write("\u014f\3\2\2\2\u0151\u0152\3\2\2\2\u0152\t\3\2\2\2\u0153")
        buf.write("\u0151\3\2\2\2\u0154\u0155\7\n\2\2\u0155\u0156\7\13\2")
        buf.write("\2\u0156\u0157\5\22\n\2\u0157\u0158\7\f\2\2\u0158\u0159")
        buf.write("\5\26\f\2\u0159\u015a\7\f\2\2\u015a\u015b\5\f\7\2\u015b")
        buf.write("\u015c\7\f\2\2\u015c\u015d\5\16\b\2\u015d\u015e\7\f\2")
        buf.write("\2\u015e\u015f\5\20\t\2\u015f\u0160\7\f\2\2\u0160\u0161")
        buf.write("\5\u009eP\2\u0161\u0162\7\f\2\2\u0162\u0163\7\r\2\2\u0163")
        buf.write("\13\3\2\2\2\u0164\u0169\5\u0114\u008b\2\u0165\u0169\5")
        buf.write("V,\2\u0166\u0167\7\13\2\2\u0167\u0169\7\r\2\2\u0168\u0164")
        buf.write("\3\2\2\2\u0168\u0165\3\2\2\2\u0168\u0166\3\2\2\2\u0169")
        buf.write("\r\3\2\2\2\u016a\u016f\5\u0114\u008b\2\u016b\u016f\5r")
        buf.write(":\2\u016c\u016d\7\13\2\2\u016d\u016f\7\r\2\2\u016e\u016a")
        buf.write("\3\2\2\2\u016e\u016b\3\2\2\2\u016e\u016c\3\2\2\2\u016f")
        buf.write("\17\3\2\2\2\u0170\u0175\5\u0114\u008b\2\u0171\u0175\5")
        buf.write("\u0088E\2\u0172\u0173\7\13\2\2\u0173\u0175\7\r\2\2\u0174")
        buf.write("\u0170\3\2\2\2\u0174\u0171\3\2\2\2\u0174\u0172\3\2\2\2")
        buf.write("\u0175\21\3\2\2\2\u0176\u0177\7\16\2\2\u0177\u0178\7\4")
        buf.write("\2\2\u0178\u0179\5\24\13\2\u0179\u017a\7\5\2\2\u017a\23")
        buf.write("\3\2\2\2\u017b\u017c\5\4\3\2\u017c\25\3\2\2\2\u017d\u0180")
        buf.write("\5\30\r\2\u017e\u0180\5\u0114\u008b\2\u017f\u017d\3\2")
        buf.write("\2\2\u017f\u017e\3\2\2\2\u0180\27\3\2\2\2\u0181\u0182")
        buf.write("\7\17\2\2\u0182\u0183\7\4\2\2\u0183\u0184\5\32\16\2\u0184")
        buf.write("\u0185\7\5\2\2\u0185\31\3\2\2\2\u0186\u0187\5\34\17\2")
        buf.write("\u0187\u0188\7\20\2\2\u0188\u018b\5\34\17\2\u0189\u018a")
        buf.write("\7\20\2\2\u018a\u018c\5B\"\2\u018b\u0189\3\2\2\2\u018b")
        buf.write("\u018c\3\2\2\2\u018c\33\3\2\2\2\u018d\u0190\5\36\20\2")
        buf.write("\u018e\u0190\5\u0114\u008b\2\u018f\u018d\3\2\2\2\u018f")
        buf.write("\u018e\3\2\2\2\u0190\35\3\2\2\2\u0191\u0192\7\4\2\2\u0192")
        buf.write("\u0193\5$\23\2\u0193\u0194\7\5\2\2\u0194\u01a2\3\2\2\2")
        buf.write("\u0195\u0196\7\4\2\2\u0196\u0197\5$\23\2\u0197\u0199\7")
        buf.write("\20\2\2\u0198\u019a\58\35\2\u0199\u0198\3\2\2\2\u0199")
        buf.write("\u019a\3\2\2\2\u019a\u019d\3\2\2\2\u019b\u019c\7\20\2")
        buf.write("\2\u019c\u019e\5&\24\2\u019d\u019b\3\2\2\2\u019d\u019e")
        buf.write("\3\2\2\2\u019e\u019f\3\2\2\2\u019f\u01a0\7\5\2\2\u01a0")
        buf.write("\u01a2\3\2\2\2\u01a1\u0191\3\2\2\2\u01a1\u0195\3\2\2\2")
        buf.write("\u01a2\37\3\2\2\2\u01a3\u01a5\5\"\22\2\u01a4\u01a3\3\2")
        buf.write("\2\2\u01a4\u01a5\3\2\2\2\u01a5\u01a6\3\2\2\2\u01a6\u01bc")
        buf.write("\5\62\32\2\u01a7\u01a8\5\"\22\2\u01a8\u01a9\5\b\5\2\u01a9")
        buf.write("\u01bc\3\2\2\2\u01aa\u01ac\5\"\22\2\u01ab\u01aa\3\2\2")
        buf.write("\2\u01ab\u01ac\3\2\2\2\u01ac\u01ad\3\2\2\2\u01ad\u01ae")
        buf.write("\5\b\5\2\u01ae\u01af\7\21\2\2\u01af\u01b0\7\4\2\2\u01b0")
        buf.write("\u01b1\5\6\4\2\u01b1\u01b2\7\20\2\2\u01b2\u01b3\5\6\4")
        buf.write("\2\u01b3\u01b4\7\5\2\2\u01b4\u01b5\7\22\2\2\u01b5\u01b6")
        buf.write("\7\4\2\2\u01b6\u01b7\5\6\4\2\u01b7\u01b8\7\20\2\2\u01b8")
        buf.write("\u01b9\5\6\4\2\u01b9\u01ba\7\5\2\2\u01ba\u01bc\3\2\2\2")
        buf.write("\u01bb\u01a4\3\2\2\2\u01bb\u01a7\3\2\2\2\u01bb\u01ab\3")
        buf.write("\2\2\2\u01bc!\3\2\2\2\u01bd\u01c1\7\23\2\2\u01be\u01c1")
        buf.write("\7\24\2\2\u01bf\u01c1\7\25\2\2\u01c0\u01bd\3\2\2\2\u01c0")
        buf.write("\u01be\3\2\2\2\u01c0\u01bf\3\2\2\2\u01c1#\3\2\2\2\u01c2")
        buf.write("\u01c5\5 \21\2\u01c3\u01c5\5\u0114\u008b\2\u01c4\u01c2")
        buf.write("\3\2\2\2\u01c4\u01c3\3\2\2\2\u01c5%\3\2\2\2\u01c6\u01c9")
        buf.write("\5(\25\2\u01c7\u01c9\5\u0114\u008b\2\u01c8\u01c6\3\2\2")
        buf.write("\2\u01c8\u01c7\3\2\2\2\u01c9\'\3\2\2\2\u01ca\u01d3\5\6")
        buf.write("\4\2\u01cb\u01cc\7\21\2\2\u01cc\u01cd\7\4\2\2\u01cd\u01ce")
        buf.write("\5\6\4\2\u01ce\u01cf\7\20\2\2\u01cf\u01d0\5\6\4\2\u01d0")
        buf.write("\u01d1\7\5\2\2\u01d1\u01d3\3\2\2\2\u01d2\u01ca\3\2\2\2")
        buf.write("\u01d2\u01cb\3\2\2\2\u01d3)\3\2\2\2\u01d4\u01d6\t\3\2")
        buf.write("\2\u01d5\u01d4\3\2\2\2\u01d5\u01d6\3\2\2\2\u01d6\u01d7")
        buf.write("\3\2\2\2\u01d7\u01d8\5,\27\2\u01d8+\3\2\2\2\u01d9\u01dc")
        buf.write("\5.\30\2\u01da\u01dc\5\60\31\2\u01db\u01d9\3\2\2\2\u01db")
        buf.write("\u01da\3\2\2\2\u01dc-\3\2\2\2\u01dd\u01de\7i\2\2\u01de")
        buf.write("/\3\2\2\2\u01df\u01e3\7j\2\2\u01e0\u01e3\7\26\2\2\u01e1")
        buf.write("\u01e3\7\27\2\2\u01e2\u01df\3\2\2\2\u01e2\u01e0\3\2\2")
        buf.write("\2\u01e2\u01e1\3\2\2\2\u01e3\61\3\2\2\2\u01e4\u01e5\7")
        buf.write("\4\2\2\u01e5\u01e6\5\6\4\2\u01e6\u01e7\7\20\2\2\u01e7")
        buf.write("\u01eb\5\6\4\2\u01e8\u01e9\7\20\2\2\u01e9\u01ea\t\3\2")
        buf.write("\2\u01ea\u01ec\5\6\4\2\u01eb\u01e8\3\2\2\2\u01eb\u01ec")
        buf.write("\3\2\2\2\u01ec\u01ed\3\2\2\2\u01ed\u01ee\7\5\2\2\u01ee")
        buf.write("\u01fd\3\2\2\2\u01ef\u01f0\5\64\33\2\u01f0\u01f1\7\30")
        buf.write("\2\2\u01f1\u01f2\5\6\4\2\u01f2\u01fd\3\2\2\2\u01f3\u01f4")
        buf.write("\5\64\33\2\u01f4\u01f5\7\30\2\2\u01f5\u01f6\7\21\2\2\u01f6")
        buf.write("\u01f7\7\4\2\2\u01f7\u01f8\5\6\4\2\u01f8\u01f9\7\20\2")
        buf.write("\2\u01f9\u01fa\5\6\4\2\u01fa\u01fb\7\5\2\2\u01fb\u01fd")
        buf.write("\3\2\2\2\u01fc\u01e4\3\2\2\2\u01fc\u01ef\3\2\2\2\u01fc")
        buf.write("\u01f3\3\2\2\2\u01fd\63\3\2\2\2\u01fe\u0201\5\u0114\u008b")
        buf.write("\2\u01ff\u0201\5\66\34\2\u0200\u01fe\3\2\2\2\u0200\u01ff")
        buf.write("\3\2\2\2\u0201\65\3\2\2\2\u0202\u0203\5\4\3\2\u0203\67")
        buf.write("\3\2\2\2\u0204\u0207\5\u0114\u008b\2\u0205\u0207\5:\36")
        buf.write("\2\u0206\u0204\3\2\2\2\u0206\u0205\3\2\2\2\u02079\3\2")
        buf.write("\2\2\u0208\u0209\5\6\4\2\u0209\u020c\5<\37\2\u020a\u020b")
        buf.write("\7\31\2\2\u020b\u020d\5> \2\u020c\u020a\3\2\2\2\u020c")
        buf.write("\u020d\3\2\2\2\u020d\u0234\3\2\2\2\u020e\u020f\5\6\4\2")
        buf.write("\u020f\u0210\7\32\2\2\u0210\u0213\5<\37\2\u0211\u0212")
        buf.write("\7\31\2\2\u0212\u0214\5> \2\u0213\u0211\3\2\2\2\u0213")
        buf.write("\u0214\3\2\2\2\u0214\u0234\3\2\2\2\u0215\u0216\7\32\2")
        buf.write("\2\u0216\u0219\5<\37\2\u0217\u0218\7\31\2\2\u0218\u021a")
        buf.write("\5> \2\u0219\u0217\3\2\2\2\u0219\u021a\3\2\2\2\u021a\u0234")
        buf.write("\3\2\2\2\u021b\u021c\7\21\2\2\u021c\u021d\7\4\2\2\u021d")
        buf.write("\u021e\5\6\4\2\u021e\u021f\7\20\2\2\u021f\u0220\5\6\4")
        buf.write("\2\u0220\u0221\7\5\2\2\u0221\u0224\5<\37\2\u0222\u0223")
        buf.write("\7\31\2\2\u0223\u0225\5> \2\u0224\u0222\3\2\2\2\u0224")
        buf.write("\u0225\3\2\2\2\u0225\u0234\3\2\2\2\u0226\u0227\7\21\2")
        buf.write("\2\u0227\u0228\7\4\2\2\u0228\u0229\5\6\4\2\u0229\u022a")
        buf.write("\7\32\2\2\u022a\u022b\7\20\2\2\u022b\u022c\5\6\4\2\u022c")
        buf.write("\u022d\7\32\2\2\u022d\u022e\7\5\2\2\u022e\u0231\5<\37")
        buf.write("\2\u022f\u0230\7\31\2\2\u0230\u0232\5> \2\u0231\u022f")
        buf.write("\3\2\2\2\u0231\u0232\3\2\2\2\u0232\u0234\3\2\2\2\u0233")
        buf.write("\u0208\3\2\2\2\u0233\u020e\3\2\2\2\u0233\u0215\3\2\2\2")
        buf.write("\u0233\u021b\3\2\2\2\u0233\u0226\3\2\2\2\u0234;\3\2\2")
        buf.write("\2\u0235\u0238\7\33\2\2\u0236\u0238\7\34\2\2\u0237\u0235")
        buf.write("\3\2\2\2\u0237\u0236\3\2\2\2\u0238=\3\2\2\2\u0239\u023a")
        buf.write("\5@!\2\u023a?\3\2\2\2\u023b\u023c\5\64\33\2\u023c\u023d")
        buf.write("\7\30\2\2\u023d\u023e\5\6\4\2\u023e\u0242\3\2\2\2\u023f")
        buf.write("\u0242\7\35\2\2\u0240\u0242\5\u0114\u008b\2\u0241\u023b")
        buf.write("\3\2\2\2\u0241\u023f\3\2\2\2\u0241\u0240\3\2\2\2\u0242")
        buf.write("A\3\2\2\2\u0243\u0246\5\u0114\u008b\2\u0244\u0246\5D#")
        buf.write("\2\u0245\u0243\3\2\2\2\u0245\u0244\3\2\2\2\u0246C\3\2")
        buf.write("\2\2\u0247\u0248\7\4\2\2\u0248\u0249\5F$\2\u0249\u024a")
        buf.write("\7\5\2\2\u024a\u0254\3\2\2\2\u024b\u024c\7\4\2\2\u024c")
        buf.write("\u024d\5F$\2\u024d\u024f\7\20\2\2\u024e\u0250\5N(\2\u024f")
        buf.write("\u024e\3\2\2\2\u024f\u0250\3\2\2\2\u0250\u0251\3\2\2\2")
        buf.write("\u0251\u0252\7\5\2\2\u0252\u0254\3\2\2\2\u0253\u0247\3")
        buf.write("\2\2\2\u0253\u024b\3\2\2\2\u0254E\3\2\2\2\u0255\u0258")
        buf.write("\5\u0114\u008b\2\u0256\u0258\5H%\2\u0257\u0255\3\2\2\2")
        buf.write("\u0257\u0256\3\2\2\2\u0258G\3\2\2\2\u0259\u025c\5J&\2")
        buf.write("\u025a\u025c\5L\'\2\u025b\u0259\3\2\2\2\u025b\u025a\3")
        buf.write("\2\2\2\u025cI\3\2\2\2\u025d\u025e\5\4\3\2\u025eK\3\2\2")
        buf.write("\2\u025f\u0267\7\36\2\2\u0260\u0267\7\37\2\2\u0261\u0267")
        buf.write("\7 \2\2\u0262\u0267\7!\2\2\u0263\u0267\7\"\2\2\u0264\u0267")
        buf.write("\7#\2\2\u0265\u0267\7$\2\2\u0266\u025f\3\2\2\2\u0266\u0260")
        buf.write("\3\2\2\2\u0266\u0261\3\2\2\2\u0266\u0262\3\2\2\2\u0266")
        buf.write("\u0263\3\2\2\2\u0266\u0264\3\2\2\2\u0266\u0265\3\2\2\2")
        buf.write("\u0267M\3\2\2\2\u0268\u026b\5\u0114\u008b\2\u0269\u026b")
        buf.write("\5P)\2\u026a\u0268\3\2\2\2\u026a\u0269\3\2\2\2\u026bO")
        buf.write("\3\2\2\2\u026c\u026f\5R*\2\u026d\u026f\5T+\2\u026e\u026c")
        buf.write("\3\2\2\2\u026e\u026d\3\2\2\2\u026fQ\3\2\2\2\u0270\u0276")
        buf.write("\7%\2\2\u0271\u0276\7&\2\2\u0272\u0276\7\'\2\2\u0273\u0276")
        buf.write("\7(\2\2\u0274\u0276\7)\2\2\u0275\u0270\3\2\2\2\u0275\u0271")
        buf.write("\3\2\2\2\u0275\u0272\3\2\2\2\u0275\u0273\3\2\2\2\u0275")
        buf.write("\u0274\3\2\2\2\u0276S\3\2\2\2\u0277\u0278\7h\2\2\u0278")
        buf.write("U\3\2\2\2\u0279\u027a\7\13\2\2\u027a\u027b\5X-\2\u027b")
        buf.write("\u027c\7\r\2\2\u027cW\3\2\2\2\u027d\u027e\b-\1\2\u027e")
        buf.write("\u027f\5\\/\2\u027f\u0285\3\2\2\2\u0280\u0281\f\3\2\2")
        buf.write("\u0281\u0282\7\20\2\2\u0282\u0284\5\\/\2\u0283\u0280\3")
        buf.write("\2\2\2\u0284\u0287\3\2\2\2\u0285\u0283\3\2\2\2\u0285\u0286")
        buf.write("\3\2\2\2\u0286Y\3\2\2\2\u0287\u0285\3\2\2\2\u0288\u0289")
        buf.write("\7*\2\2\u0289\u028a\7\4\2\2\u028a\u028b\5^\60\2\u028b")
        buf.write("\u028c\7\5\2\2\u028c[\3\2\2\2\u028d\u0290\5Z.\2\u028e")
        buf.write("\u0290\5\u0114\u008b\2\u028f\u028d\3\2\2\2\u028f\u028e")
        buf.write("\3\2\2\2\u0290]\3\2\2\2\u0291\u02a4\5\34\17\2\u0292\u0293")
        buf.write("\5\34\17\2\u0293\u0294\7\20\2\2\u0294\u0295\5`\61\2\u0295")
        buf.write("\u02a4\3\2\2\2\u0296\u0297\5\34\17\2\u0297\u0299\7\20")
        buf.write("\2\2\u0298\u029a\5`\61\2\u0299\u0298\3\2\2\2\u0299\u029a")
        buf.write("\3\2\2\2\u029a\u029b\3\2\2\2\u029b\u029d\7\20\2\2\u029c")
        buf.write("\u029e\5\34\17\2\u029d\u029c\3\2\2\2\u029d\u029e\3\2\2")
        buf.write("\2\u029e\u02a1\3\2\2\2\u029f\u02a0\7\20\2\2\u02a0\u02a2")
        buf.write("\5B\"\2\u02a1\u029f\3\2\2\2\u02a1\u02a2\3\2\2\2\u02a2")
        buf.write("\u02a4\3\2\2\2\u02a3\u0291\3\2\2\2\u02a3\u0292\3\2\2\2")
        buf.write("\u02a3\u0296\3\2\2\2\u02a4_\3\2\2\2\u02a5\u02a8\5b\62")
        buf.write("\2\u02a6\u02a8\5\u0114\u008b\2\u02a7\u02a5\3\2\2\2\u02a7")
        buf.write("\u02a6\3\2\2\2\u02a8a\3\2\2\2\u02a9\u02ac\5d\63\2\u02aa")
        buf.write("\u02ac\5h\65\2\u02ab\u02a9\3\2\2\2\u02ab\u02aa\3\2\2\2")
        buf.write("\u02acc\3\2\2\2\u02ad\u02ae\5f\64\2\u02ae\u02af\7\4\2")
        buf.write("\2\u02af\u02b0\5\34\17\2\u02b0\u02b1\7\5\2\2\u02b1e\3")
        buf.write("\2\2\2\u02b2\u02b5\7+\2\2\u02b3\u02b5\7,\2\2\u02b4\u02b2")
        buf.write("\3\2\2\2\u02b4\u02b3\3\2\2\2\u02b5g\3\2\2\2\u02b6\u02b7")
        buf.write("\5p9\2\u02b7\u02b8\7\4\2\2\u02b8\u02b9\5j\66\2\u02b9\u02ba")
        buf.write("\7\5\2\2\u02bai\3\2\2\2\u02bb\u02be\5\u0114\u008b\2\u02bc")
        buf.write("\u02be\5l\67\2\u02bd\u02bb\3\2\2\2\u02bd\u02bc\3\2\2\2")
        buf.write("\u02bek\3\2\2\2\u02bf\u02c0\7\4\2\2\u02c0\u02c1\5n8\2")
        buf.write("\u02c1\u02c2\7\5\2\2\u02c2m\3\2\2\2\u02c3\u02c4\b8\1\2")
        buf.write("\u02c4\u02c5\5\34\17\2\u02c5\u02cb\3\2\2\2\u02c6\u02c7")
        buf.write("\f\4\2\2\u02c7\u02c8\7\20\2\2\u02c8\u02ca\5\34\17\2\u02c9")
        buf.write("\u02c6\3\2\2\2\u02ca\u02cd\3\2\2\2\u02cb\u02c9\3\2\2\2")
        buf.write("\u02cb\u02cc\3\2\2\2\u02cco\3\2\2\2\u02cd\u02cb\3\2\2")
        buf.write("\2\u02ce\u02d5\7-\2\2\u02cf\u02d5\7.\2\2\u02d0\u02d5\7")
        buf.write("/\2\2\u02d1\u02d5\7\60\2\2\u02d2\u02d5\7\61\2\2\u02d3")
        buf.write("\u02d5\7\62\2\2\u02d4\u02ce\3\2\2\2\u02d4\u02cf\3\2\2")
        buf.write("\2\u02d4\u02d0\3\2\2\2\u02d4\u02d1\3\2\2\2\u02d4\u02d2")
        buf.write("\3\2\2\2\u02d4\u02d3\3\2\2\2\u02d5q\3\2\2\2\u02d6\u02d7")
        buf.write("\7\13\2\2\u02d7\u02d8\5t;\2\u02d8\u02d9\7\r\2\2\u02d9")
        buf.write("s\3\2\2\2\u02da\u02db\b;\1\2\u02db\u02dc\5v<\2\u02dc\u02e2")
        buf.write("\3\2\2\2\u02dd\u02de\f\3\2\2\u02de\u02df\7\20\2\2\u02df")
        buf.write("\u02e1\5v<\2\u02e0\u02dd\3\2\2\2\u02e1\u02e4\3\2\2\2\u02e2")
        buf.write("\u02e0\3\2\2\2\u02e2\u02e3\3\2\2\2\u02e3u\3\2\2\2\u02e4")
        buf.write("\u02e2\3\2\2\2\u02e5\u02e8\5x=\2\u02e6\u02e8\5\u0114\u008b")
        buf.write("\2\u02e7\u02e5\3\2\2\2\u02e7\u02e6\3\2\2\2\u02e8w\3\2")
        buf.write("\2\2\u02e9\u02ea\7\63\2\2\u02ea\u02eb\7\4\2\2\u02eb\u02ec")
        buf.write("\5z>\2\u02ec\u02ed\7\5\2\2\u02edy\3\2\2\2\u02ee\u0301")
        buf.write("\5\34\17\2\u02ef\u02f0\5\34\17\2\u02f0\u02f1\7\20\2\2")
        buf.write("\u02f1\u02f2\5|?\2\u02f2\u0301\3\2\2\2\u02f3\u02f4\5\34")
        buf.write("\17\2\u02f4\u02f6\7\20\2\2\u02f5\u02f7\5|?\2\u02f6\u02f5")
        buf.write("\3\2\2\2\u02f6\u02f7\3\2\2\2\u02f7\u02f8\3\2\2\2\u02f8")
        buf.write("\u02fa\7\20\2\2\u02f9\u02fb\5\34\17\2\u02fa\u02f9\3\2")
        buf.write("\2\2\u02fa\u02fb\3\2\2\2\u02fb\u02fe\3\2\2\2\u02fc\u02fd")
        buf.write("\7\20\2\2\u02fd\u02ff\5\u0080A\2\u02fe\u02fc\3\2\2\2\u02fe")
        buf.write("\u02ff\3\2\2\2\u02ff\u0301\3\2\2\2\u0300\u02ee\3\2\2\2")
        buf.write("\u0300\u02ef\3\2\2\2\u0300\u02f3\3\2\2\2\u0301{\3\2\2")
        buf.write("\2\u0302\u0305\5~@\2\u0303\u0305\5\u0114\u008b\2\u0304")
        buf.write("\u0302\3\2\2\2\u0304\u0303\3\2\2\2\u0305}\3\2\2\2\u0306")
        buf.write("\u0309\5d\63\2\u0307\u0309\5h\65\2\u0308\u0306\3\2\2\2")
        buf.write("\u0308\u0307\3\2\2\2\u0309\177\3\2\2\2\u030a\u030e\5\u0082")
        buf.write("B\2\u030b\u030e\5\u0114\u008b\2\u030c\u030e\7e\2\2\u030d")
        buf.write("\u030a\3\2\2\2\u030d\u030b\3\2\2\2\u030d\u030c\3\2\2\2")
        buf.write("\u030e\u0081\3\2\2\2\u030f\u0310\7\4\2\2\u0310\u0311\5")
        buf.write("\u0084C\2\u0311\u0312\7\20\2\2\u0312\u0313\5N(\2\u0313")
        buf.write("\u0314\7\5\2\2\u0314\u0083\3\2\2\2\u0315\u0318\5\u0114")
        buf.write("\u008b\2\u0316\u0318\5\u0086D\2\u0317\u0315\3\2\2\2\u0317")
        buf.write("\u0316\3\2\2\2\u0318\u0085\3\2\2\2\u0319\u031a\5\6\4\2")
        buf.write("\u031a\u0087\3\2\2\2\u031b\u031c\7\13\2\2\u031c\u031d")
        buf.write("\5\u008aF\2\u031d\u031e\7\r\2\2\u031e\u0089\3\2\2\2\u031f")
        buf.write("\u0320\bF\1\2\u0320\u0321\5\u008cG\2\u0321\u0327\3\2\2")
        buf.write("\2\u0322\u0323\f\3\2\2\u0323\u0324\7\20\2\2\u0324\u0326")
        buf.write("\5\u008cG\2\u0325\u0322\3\2\2\2\u0326\u0329\3\2\2\2\u0327")
        buf.write("\u0325\3\2\2\2\u0327\u0328\3\2\2\2\u0328\u008b\3\2\2\2")
        buf.write("\u0329\u0327\3\2\2\2\u032a\u032d\5\u008eH\2\u032b\u032d")
        buf.write("\5\u0114\u008b\2\u032c\u032a\3\2\2\2\u032c\u032b\3\2\2")
        buf.write("\2\u032d\u008d\3\2\2\2\u032e\u032f\7\64\2\2\u032f\u0330")
        buf.write("\7\4\2\2\u0330\u0331\5\u0090I\2\u0331\u0332\7\5\2\2\u0332")
        buf.write("\u008f\3\2\2\2\u0333\u0336\5$\23\2\u0334\u0335\7\20\2")
        buf.write("\2\u0335\u0337\5\u0092J\2\u0336\u0334\3\2\2\2\u0336\u0337")
        buf.write("\3\2\2\2\u0337\u0091\3\2\2\2\u0338\u033b\5\u0114\u008b")
        buf.write("\2\u0339\u033b\5\u0094K\2\u033a\u0338\3\2\2\2\u033a\u0339")
        buf.write("\3\2\2\2\u033b\u0093\3\2\2\2\u033c\u0341\5\u0096L\2\u033d")
        buf.write("\u0341\5\u0098M\2\u033e\u0341\5\u009aN\2\u033f\u0341\5")
        buf.write("\u009cO\2\u0340\u033c\3\2\2\2\u0340\u033d\3\2\2\2\u0340")
        buf.write("\u033e\3\2\2\2\u0340\u033f\3\2\2\2\u0341\u0095\3\2\2\2")
        buf.write("\u0342\u0343\7\4\2\2\u0343\u0344\7\65\2\2\u0344\u0345")
        buf.write("\7\20\2\2\u0345\u0346\5\6\4\2\u0346\u0347\7\5\2\2\u0347")
        buf.write("\u0097\3\2\2\2\u0348\u0349\7\4\2\2\u0349\u034a\7\66\2")
        buf.write("\2\u034a\u034b\7\20\2\2\u034b\u034c\5\6\4\2\u034c\u034d")
        buf.write("\7\20\2\2\u034d\u034e\5\6\4\2\u034e\u034f\7\20\2\2\u034f")
        buf.write("\u0350\5\6\4\2\u0350\u0351\7\5\2\2\u0351\u0099\3\2\2\2")
        buf.write("\u0352\u0353\7\4\2\2\u0353\u0354\7\67\2\2\u0354\u0355")
        buf.write("\7\20\2\2\u0355\u0356\5\6\4\2\u0356\u0357\7\20\2\2\u0357")
        buf.write("\u0358\5\6\4\2\u0358\u0359\7\20\2\2\u0359\u035a\5\6\4")
        buf.write("\2\u035a\u035b\7\5\2\2\u035b\u009b\3\2\2\2\u035c\u035d")
        buf.write("\7\4\2\2\u035d\u035e\78\2\2\u035e\u035f\7\20\2\2\u035f")
        buf.write("\u0360\5\6\4\2\u0360\u0361\7\20\2\2\u0361\u0362\5\6\4")
        buf.write("\2\u0362\u0363\7\20\2\2\u0363\u0364\5\6\4\2\u0364\u0365")
        buf.write("\7\5\2\2\u0365\u009d\3\2\2\2\u0366\u036b\5\u0114\u008b")
        buf.write("\2\u0367\u036b\5\u00a0Q\2\u0368\u0369\7\13\2\2\u0369\u036b")
        buf.write("\7\r\2\2\u036a\u0366\3\2\2\2\u036a\u0367\3\2\2\2\u036a")
        buf.write("\u0368\3\2\2\2\u036b\u009f\3\2\2\2\u036c\u036d\79\2\2")
        buf.write("\u036d\u036e\7\4\2\2\u036e\u036f\5\u00a2R\2\u036f\u0370")
        buf.write("\7\5\2\2\u0370\u00a1\3\2\2\2\u0371\u0372\5\u00a6T\2\u0372")
        buf.write("\u0373\7\20\2\2\u0373\u0374\5\u00a4S\2\u0374\u00a3\3\2")
        buf.write("\2\2\u0375\u0378\5\u0114\u008b\2\u0376\u0378\5\u00aaV")
        buf.write("\2\u0377\u0375\3\2\2\2\u0377\u0376\3\2\2\2\u0378\u00a5")
        buf.write("\3\2\2\2\u0379\u037c\5\u00a8U\2\u037a\u037c\5\u0114\u008b")
        buf.write("\2\u037b\u0379\3\2\2\2\u037b\u037a\3\2\2\2\u037c\u00a7")
        buf.write("\3\2\2\2\u037d\u037e\7g\2\2\u037e\u00a9\3\2\2\2\u037f")
        buf.write("\u0380\7\13\2\2\u0380\u0381\5\u00acW\2\u0381\u0382\7\r")
        buf.write("\2\2\u0382\u00ab\3\2\2\2\u0383\u0384\bW\1\2\u0384\u0385")
        buf.write("\5\u00aeX\2\u0385\u038b\3\2\2\2\u0386\u0387\f\3\2\2\u0387")
        buf.write("\u0388\7\20\2\2\u0388\u038a\5\u00aeX\2\u0389\u0386\3\2")
        buf.write("\2\2\u038a\u038d\3\2\2\2\u038b\u0389\3\2\2\2\u038b\u038c")
        buf.write("\3\2\2\2\u038c\u00ad\3\2\2\2\u038d\u038b\3\2\2\2\u038e")
        buf.write("\u0391\5\u0114\u008b\2\u038f\u0391\5\u00b0Y\2\u0390\u038e")
        buf.write("\3\2\2\2\u0390\u038f\3\2\2\2\u0391\u00af\3\2\2\2\u0392")
        buf.write("\u0393\5\u00b2Z\2\u0393\u0394\7:\2\2\u0394\u0395\5\u00b4")
        buf.write("[\2\u0395\u039b\3\2\2\2\u0396\u0397\5\u00b2Z\2\u0397\u0398")
        buf.write("\7:\2\2\u0398\u0399\5\u00b6\\\2\u0399\u039b\3\2\2\2\u039a")
        buf.write("\u0392\3\2\2\2\u039a\u0396\3\2\2\2\u039b\u00b1\3\2\2\2")
        buf.write("\u039c\u03a2\7;\2\2\u039d\u03a2\7<\2\2\u039e\u03a2\7=")
        buf.write("\2\2\u039f\u03a2\7>\2\2\u03a0\u03a2\7?\2\2\u03a1\u039c")
        buf.write("\3\2\2\2\u03a1\u039d\3\2\2\2\u03a1\u039e\3\2\2\2\u03a1")
        buf.write("\u039f\3\2\2\2\u03a1\u03a0\3\2\2\2\u03a2\u00b3\3\2\2\2")
        buf.write("\u03a3\u03a6\5.\30\2\u03a4\u03a6\5\u0114\u008b\2\u03a5")
        buf.write("\u03a3\3\2\2\2\u03a5\u03a4\3\2\2\2\u03a6\u00b5\3\2\2\2")
        buf.write("\u03a7\u03aa\5\u00b8]\2\u03a8\u03aa\5\u0114\u008b\2\u03a9")
        buf.write("\u03a7\3\2\2\2\u03a9\u03a8\3\2\2\2\u03aa\u00b7\3\2\2\2")
        buf.write("\u03ab\u03af\7@\2\2\u03ac\u03af\7A\2\2\u03ad\u03af\7B")
        buf.write("\2\2\u03ae\u03ab\3\2\2\2\u03ae\u03ac\3\2\2\2\u03ae\u03ad")
        buf.write("\3\2\2\2\u03af\u00b9\3\2\2\2\u03b0\u03b1\7\13\2\2\u03b1")
        buf.write("\u03b2\5\u00bc_\2\u03b2\u03b3\7\r\2\2\u03b3\u00bb\3\2")
        buf.write("\2\2\u03b4\u03b5\5\u00be`\2\u03b5\u03b6\7\20\2\2\u03b6")
        buf.write("\u03b7\5\u00c8e\2\u03b7\u00bd\3\2\2\2\u03b8\u03bd\5\u00c0")
        buf.write("a\2\u03b9\u03ba\7\20\2\2\u03ba\u03bc\5\u00c0a\2\u03bb")
        buf.write("\u03b9\3\2\2\2\u03bc\u03bf\3\2\2\2\u03bd\u03bb\3\2\2\2")
        buf.write("\u03bd\u03be\3\2\2\2\u03be\u00bf\3\2\2\2\u03bf\u03bd\3")
        buf.write("\2\2\2\u03c0\u03c3\5\u0114\u008b\2\u03c1\u03c3\5\u00c2")
        buf.write("b\2\u03c2\u03c0\3\2\2\2\u03c2\u03c1\3\2\2\2\u03c3\u00c1")
        buf.write("\3\2\2\2\u03c4\u03c5\7C\2\2\u03c5\u03c6\7\4\2\2\u03c6")
        buf.write("\u03c7\5\u00c4c\2\u03c7\u03c8\7\20\2\2\u03c8\u03c9\t\4")
        buf.write("\2\2\u03c9\u03ca\7\20\2\2\u03ca\u03cb\t\4\2\2\u03cb\u03cc")
        buf.write("\7\20\2\2\u03cc\u03cd\t\4\2\2\u03cd\u03ce\7\5\2\2\u03ce")
        buf.write("\u00c3\3\2\2\2\u03cf\u03d2\5\u00c6d\2\u03d0\u03d2\5\u0114")
        buf.write("\u008b\2\u03d1\u03cf\3\2\2\2\u03d1\u03d0\3\2\2\2\u03d2")
        buf.write("\u00c5\3\2\2\2\u03d3\u03d5\t\3\2\2\u03d4\u03d3\3\2\2\2")
        buf.write("\u03d4\u03d5\3\2\2\2\u03d5\u03d6\3\2\2\2\u03d6\u03d7\5")
        buf.write("\60\31\2\u03d7\u00c7\3\2\2\2\u03d8\u03d9\be\1\2\u03d9")
        buf.write("\u03da\5\u00caf\2\u03da\u03e0\3\2\2\2\u03db\u03dc\f\3")
        buf.write("\2\2\u03dc\u03dd\7\20\2\2\u03dd\u03df\5\u00caf\2\u03de")
        buf.write("\u03db\3\2\2\2\u03df\u03e2\3\2\2\2\u03e0\u03de\3\2\2\2")
        buf.write("\u03e0\u03e1\3\2\2\2\u03e1\u00c9\3\2\2\2\u03e2\u03e0\3")
        buf.write("\2\2\2\u03e3\u03e6\5\u00ccg\2\u03e4\u03e6\5\u0114\u008b")
        buf.write("\2\u03e5\u03e3\3\2\2\2\u03e5\u03e4\3\2\2\2\u03e6\u00cb")
        buf.write("\3\2\2\2\u03e7\u03e8\7D\2\2\u03e8\u03e9\7\4\2\2\u03e9")
        buf.write("\u03ea\5\64\33\2\u03ea\u03eb\7\20\2\2\u03eb\u03ec\5\u00ce")
        buf.write("h\2\u03ec\u03ed\7\5\2\2\u03ed\u00cd\3\2\2\2\u03ee\u03f1")
        buf.write("\5\u0114\u008b\2\u03ef\u03f1\5\u00d0i\2\u03f0\u03ee\3")
        buf.write("\2\2\2\u03f0\u03ef\3\2\2\2\u03f1\u00cf\3\2\2\2\u03f2\u03f3")
        buf.write("\7\4\2\2\u03f3\u03f4\5\6\4\2\u03f4\u03f5\7\20\2\2\u03f5")
        buf.write("\u03f6\5\6\4\2\u03f6\u03f7\7\5\2\2\u03f7\u00d1\3\2\2\2")
        buf.write("\u03f8\u03f9\7E\2\2\u03f9\u03fa\5\u0114\u008b\2\u03fa")
        buf.write("\u03fb\7F\2\2\u03fb\u03fc\7G\2\2\u03fc\u03fd\7\4\2\2\u03fd")
        buf.write("\u03fe\5\u0114\u008b\2\u03fe\u03ff\7\5\2\2\u03ff\u00d3")
        buf.write("\3\2\2\2\u0400\u0401\5\u0114\u008b\2\u0401\u00d5\3\2\2")
        buf.write("\2\u0402\u0403\t\5\2\2\u0403\u00d7\3\2\2\2\u0404\u041d")
        buf.write("\7N\2\2\u0405\u041d\7O\2\2\u0406\u041d\7P\2\2\u0407\u0408")
        buf.write("\7N\2\2\u0408\u0409\7Q\2\2\u0409\u040a\5\u00dco\2\u040a")
        buf.write("\u040b\7\20\2\2\u040b\u040c\5\u00dep\2\u040c\u040d\7R")
        buf.write("\2\2\u040d\u041d\3\2\2\2\u040e\u040f\7O\2\2\u040f\u0410")
        buf.write("\7Q\2\2\u0410\u0411\5\u00dco\2\u0411\u0412\7\20\2\2\u0412")
        buf.write("\u0413\5\u00dep\2\u0413\u0414\7R\2\2\u0414\u041d\3\2\2")
        buf.write("\2\u0415\u0416\7P\2\2\u0416\u0417\7Q\2\2\u0417\u0418\5")
        buf.write("\u00dco\2\u0418\u0419\7\20\2\2\u0419\u041a\5\u00dep\2")
        buf.write("\u041a\u041b\7R\2\2\u041b\u041d\3\2\2\2\u041c\u0404\3")
        buf.write("\2\2\2\u041c\u0405\3\2\2\2\u041c\u0406\3\2\2\2\u041c\u0407")
        buf.write("\3\2\2\2\u041c\u040e\3\2\2\2\u041c\u0415\3\2\2\2\u041d")
        buf.write("\u00d9\3\2\2\2\u041e\u0427\7S\2\2\u041f\u0420\7S\2\2\u0420")
        buf.write("\u0421\7Q\2\2\u0421\u0422\5\u00dco\2\u0422\u0423\7\20")
        buf.write("\2\2\u0423\u0424\5\u00dep\2\u0424\u0425\7R\2\2\u0425\u0427")
        buf.write("\3\2\2\2\u0426\u041e\3\2\2\2\u0426\u041f\3\2\2\2\u0427")
        buf.write("\u00db\3\2\2\2\u0428\u0429\5*\26\2\u0429\u00dd\3\2\2\2")
        buf.write("\u042a\u042b\5*\26\2\u042b\u00df\3\2\2\2\u042c\u042d\b")
        buf.write("q\1\2\u042d\u0434\5\u00e2r\2\u042e\u042f\7\4\2\2\u042f")
        buf.write("\u0430\5\u00e0q\2\u0430\u0431\7\5\2\2\u0431\u0434\3\2")
        buf.write("\2\2\u0432\u0434\5\u0114\u008b\2\u0433\u042c\3\2\2\2\u0433")
        buf.write("\u042e\3\2\2\2\u0433\u0432\3\2\2\2\u0434\u043b\3\2\2\2")
        buf.write("\u0435\u0436\f\4\2\2\u0436\u0437\5\u0116\u008c\2\u0437")
        buf.write("\u0438\5\u00e0q\5\u0438\u043a\3\2\2\2\u0439\u0435\3\2")
        buf.write("\2\2\u043a\u043d\3\2\2\2\u043b\u0439\3\2\2\2\u043b\u043c")
        buf.write("\3\2\2\2\u043c\u00e1\3\2\2\2\u043d\u043b\3\2\2\2\u043e")
        buf.write("\u0445\5\u00e4s\2\u043f\u0445\5\u00f4{\2\u0440\u0445\5")
        buf.write("\u00f6|\2\u0441\u0445\5\u00fe\u0080\2\u0442\u0445\5\u0102")
        buf.write("\u0082\2\u0443\u0445\5*\26\2\u0444\u043e\3\2\2\2\u0444")
        buf.write("\u043f\3\2\2\2\u0444\u0440\3\2\2\2\u0444\u0441\3\2\2\2")
        buf.write("\u0444\u0442\3\2\2\2\u0444\u0443\3\2\2\2\u0445\u00e3\3")
        buf.write("\2\2\2\u0446\u0447\7T\2\2\u0447\u0448\7\4\2\2\u0448\u0449")
        buf.write("\5\u00e6t\2\u0449\u044a\7\20\2\2\u044a\u044b\5\u00e6t")
        buf.write("\2\u044b\u044c\7\5\2\2\u044c\u00e5\3\2\2\2\u044d\u0453")
        buf.write("\5\u00eav\2\u044e\u0453\5\u00eex\2\u044f\u0453\5\u00f2")
        buf.write("z\2\u0450\u0453\5 \21\2\u0451\u0453\5\u0114\u008b\2\u0452")
        buf.write("\u044d\3\2\2\2\u0452\u044e\3\2\2\2\u0452\u044f\3\2\2\2")
        buf.write("\u0452\u0450\3\2\2\2\u0452\u0451\3\2\2\2\u0453\u00e7\3")
        buf.write("\2\2\2\u0454\u0457\5\u0114\u008b\2\u0455\u0457\5\u00ea")
        buf.write("v\2\u0456\u0454\3\2\2\2\u0456\u0455\3\2\2\2\u0457\u00e9")
        buf.write("\3\2\2\2\u0458\u0459\5\u00d4k\2\u0459\u045a\7Q\2\2\u045a")
        buf.write("\u045b\7U\2\2\u045b\u045c\7R\2\2\u045c\u00eb\3\2\2\2\u045d")
        buf.write("\u0460\5\u0114\u008b\2\u045e\u0460\5\u00eex\2\u045f\u045d")
        buf.write("\3\2\2\2\u045f\u045e\3\2\2\2\u0460\u00ed\3\2\2\2\u0461")
        buf.write("\u0462\5\u00d4k\2\u0462\u0463\7Q\2\2\u0463\u0464\7V\2")
        buf.write("\2\u0464\u0465\7R\2\2\u0465\u0466\7Q\2\2\u0466\u0467\5")
        buf.write("\u0114\u008b\2\u0467\u0468\7R\2\2\u0468\u00ef\3\2\2\2")
        buf.write("\u0469\u046c\5\u0114\u008b\2\u046a\u046c\5\u00f2z\2\u046b")
        buf.write("\u0469\3\2\2\2\u046b\u046a\3\2\2\2\u046c\u00f1\3\2\2\2")
        buf.write("\u046d\u046e\5\u00d4k\2\u046e\u046f\7Q\2\2\u046f\u0470")
        buf.write("\7W\2\2\u0470\u0471\7R\2\2\u0471\u0472\7Q\2\2\u0472\u0473")
        buf.write("\5\u0114\u008b\2\u0473\u0474\7R\2\2\u0474\u00f3\3\2\2")
        buf.write("\2\u0475\u0476\7X\2\2\u0476\u0477\7\4\2\2\u0477\u0478")
        buf.write("\5\u00ecw\2\u0478\u0479\7\20\2\2\u0479\u047a\5\u00f0y")
        buf.write("\2\u047a\u047b\7\5\2\2\u047b\u00f5\3\2\2\2\u047c\u047d")
        buf.write("\7Y\2\2\u047d\u047e\7\4\2\2\u047e\u047f\5\u00f8}\2\u047f")
        buf.write("\u0480\7\20\2\2\u0480\u0481\5\u00f8}\2\u0481\u0482\7\5")
        buf.write("\2\2\u0482\u00f7\3\2\2\2\u0483\u0489\5\u0114\u008b\2\u0484")
        buf.write("\u0489\5\u00eav\2\u0485\u0489\5\u00eex\2\u0486\u0489\5")
        buf.write("\u00f2z\2\u0487\u0489\5\u00fc\177\2\u0488\u0483\3\2\2")
        buf.write("\2\u0488\u0484\3\2\2\2\u0488\u0485\3\2\2\2\u0488\u0486")
        buf.write("\3\2\2\2\u0488\u0487\3\2\2\2\u0489\u00f9\3\2\2\2\u048a")
        buf.write("\u048d\5\u0114\u008b\2\u048b\u048d\5\u00fc\177\2\u048c")
        buf.write("\u048a\3\2\2\2\u048c\u048b\3\2\2\2\u048d\u00fb\3\2\2\2")
        buf.write("\u048e\u048f\5\b\5\2\u048f\u00fd\3\2\2\2\u0490\u0491\7")
        buf.write("Z\2\2\u0491\u0492\7\4\2\2\u0492\u0493\5\u0100\u0081\2")
        buf.write("\u0493\u0494\7\20\2\2\u0494\u0495\5\u0100\u0081\2\u0495")
        buf.write("\u0496\7\5\2\2\u0496\u00ff\3\2\2\2\u0497\u049d\5\u0114")
        buf.write("\u008b\2\u0498\u049d\5\u00eav\2\u0499\u049d\5\u00eex\2")
        buf.write("\u049a\u049d\5\u00f2z\2\u049b\u049d\5(\25\2\u049c\u0497")
        buf.write("\3\2\2\2\u049c\u0498\3\2\2\2\u049c\u0499\3\2\2\2\u049c")
        buf.write("\u049a\3\2\2\2\u049c\u049b\3\2\2\2\u049d\u0101\3\2\2\2")
        buf.write("\u049e\u049f\7[\2\2\u049f\u04a0\7\4\2\2\u04a0\u04a1\5")
        buf.write("\u0104\u0083\2\u04a1\u04a2\7\20\2\2\u04a2\u04a3\5\u0104")
        buf.write("\u0083\2\u04a3\u04a4\7\5\2\2\u04a4\u0103\3\2\2\2\u04a5")
        buf.write("\u04ab\5\u0114\u008b\2\u04a6\u04ab\5\u00eav\2\u04a7\u04ab")
        buf.write("\5\u00eex\2\u04a8\u04ab\5\u00f2z\2\u04a9\u04ab\5\u0106")
        buf.write("\u0084\2\u04aa\u04a5\3\2\2\2\u04aa\u04a6\3\2\2\2\u04aa")
        buf.write("\u04a7\3\2\2\2\u04aa\u04a8\3\2\2\2\u04aa\u04a9\3\2\2\2")
        buf.write("\u04ab\u0105\3\2\2\2\u04ac\u04ad\5\b\5\2\u04ad\u0107\3")
        buf.write("\2\2\2\u04ae\u04af\5\u00e0q\2\u04af\u0109\3\2\2\2\u04b0")
        buf.write("\u04b1\5\u0108\u0085\2\u04b1\u04b2\5\u00d6l\2\u04b2\u04b3")
        buf.write("\5\u0108\u0085\2\u04b3\u010b\3\2\2\2\u04b4\u04b5\b\u0087")
        buf.write("\1\2\u04b5\u04c1\5\u010a\u0086\2\u04b6\u04b7\7\4\2\2\u04b7")
        buf.write("\u04b8\5\u010c\u0087\2\u04b8\u04b9\7\5\2\2\u04b9\u04c1")
        buf.write("\3\2\2\2\u04ba\u04bb\7\\\2\2\u04bb\u04c1\5\u010c\u0087")
        buf.write("\t\u04bc\u04bd\5\u00d8m\2\u04bd\u04be\5\u010c\u0087\b")
        buf.write("\u04be\u04c1\3\2\2\2\u04bf\u04c1\5\u0114\u008b\2\u04c0")
        buf.write("\u04b4\3\2\2\2\u04c0\u04b6\3\2\2\2\u04c0\u04ba\3\2\2\2")
        buf.write("\u04c0\u04bc\3\2\2\2\u04c0\u04bf\3\2\2\2\u04c1\u04d1\3")
        buf.write("\2\2\2\u04c2\u04c3\f\7\2\2\u04c3\u04c4\5\u00dan\2\u04c4")
        buf.write("\u04c5\5\u010c\u0087\b\u04c5\u04d0\3\2\2\2\u04c6\u04c7")
        buf.write("\f\6\2\2\u04c7\u04c8\7\22\2\2\u04c8\u04d0\5\u010c\u0087")
        buf.write("\7\u04c9\u04ca\f\5\2\2\u04ca\u04cb\7]\2\2\u04cb\u04d0")
        buf.write("\5\u010c\u0087\6\u04cc\u04cd\f\4\2\2\u04cd\u04ce\7\30")
        buf.write("\2\2\u04ce\u04d0\5\u010c\u0087\5\u04cf\u04c2\3\2\2\2\u04cf")
        buf.write("\u04c6\3\2\2\2\u04cf\u04c9\3\2\2\2\u04cf\u04cc\3\2\2\2")
        buf.write("\u04d0\u04d3\3\2\2\2\u04d1\u04cf\3\2\2\2\u04d1\u04d2\3")
        buf.write("\2\2\2\u04d2\u010d\3\2\2\2\u04d3\u04d1\3\2\2\2\u04d4\u04d9")
        buf.write("\5\4\3\2\u04d5\u04d9\5\6\4\2\u04d6\u04d9\5\b\5\2\u04d7")
        buf.write("\u04d9\5\u00e0q\2\u04d8\u04d4\3\2\2\2\u04d8\u04d5\3\2")
        buf.write("\2\2\u04d8\u04d6\3\2\2\2\u04d8\u04d7\3\2\2\2\u04d9\u010f")
        buf.write("\3\2\2\2\u04da\u04db\5\u0112\u008a\2\u04db\u04dc\7\f\2")
        buf.write("\2\u04dc\u04de\3\2\2\2\u04dd\u04da\3\2\2\2\u04de\u04e1")
        buf.write("\3\2\2\2\u04df\u04dd\3\2\2\2\u04df\u04e0\3\2\2\2\u04e0")
        buf.write("\u0111\3\2\2\2\u04e1\u04df\3\2\2\2\u04e2\u04e3\5\u0114")
        buf.write("\u008b\2\u04e3\u04e4\7F\2\2\u04e4\u04e5\5\n\6\2\u04e5")
        buf.write("\u05da\3\2\2\2\u04e6\u04e7\5\u0114\u008b\2\u04e7\u04e8")
        buf.write("\7F\2\2\u04e8\u04e9\5\30\r\2\u04e9\u05da\3\2\2\2\u04ea")
        buf.write("\u04eb\5\u0114\u008b\2\u04eb\u04ec\7F\2\2\u04ec\u04ed")
        buf.write("\7\4\2\2\u04ed\u04ee\5\u0114\u008b\2\u04ee\u04ef\7\5\2")
        buf.write("\2\u04ef\u05da\3\2\2\2\u04f0\u04f1\5\u0114\u008b\2\u04f1")
        buf.write("\u04f2\7F\2\2\u04f2\u04f3\7\4\2\2\u04f3\u04f4\5\u0114")
        buf.write("\u008b\2\u04f4\u04f5\7\20\2\2\u04f5\u04f6\5\u0114\u008b")
        buf.write("\2\u04f6\u04f7\7\5\2\2\u04f7\u05da\3\2\2\2\u04f8\u04f9")
        buf.write("\5\u0114\u008b\2\u04f9\u04fa\7F\2\2\u04fa\u04fb\7\4\2")
        buf.write("\2\u04fb\u04fc\5\u0114\u008b\2\u04fc\u04fd\7\20\2\2\u04fd")
        buf.write("\u04fe\5\u0114\u008b\2\u04fe\u04ff\7\20\2\2\u04ff\u0500")
        buf.write("\5\u0114\u008b\2\u0500\u0501\7\5\2\2\u0501\u05da\3\2\2")
        buf.write("\2\u0502\u0503\5\u0114\u008b\2\u0503\u0504\7F\2\2\u0504")
        buf.write("\u0505\5\36\20\2\u0505\u05da\3\2\2\2\u0506\u0507\5\u0114")
        buf.write("\u008b\2\u0507\u0508\7F\2\2\u0508\u0509\5D#\2\u0509\u05da")
        buf.write("\3\2\2\2\u050a\u050b\5\u0114\u008b\2\u050b\u050c\7F\2")
        buf.write("\2\u050c\u050d\5l\67\2\u050d\u05da\3\2\2\2\u050e\u050f")
        buf.write("\5\u0114\u008b\2\u050f\u0510\7F\2\2\u0510\u0511\5\u0082")
        buf.write("B\2\u0511\u05da\3\2\2\2\u0512\u0513\5\u0114\u008b\2\u0513")
        buf.write("\u0514\7F\2\2\u0514\u0515\5\"\22\2\u0515\u0516\5\b\5\2")
        buf.write("\u0516\u05da\3\2\2\2\u0517\u0518\5\u0114\u008b\2\u0518")
        buf.write("\u051a\7F\2\2\u0519\u051b\5\"\22\2\u051a\u0519\3\2\2\2")
        buf.write("\u051a\u051b\3\2\2\2\u051b\u051c\3\2\2\2\u051c\u051d\7")
        buf.write("\4\2\2\u051d\u051e\5\6\4\2\u051e\u051f\7\20\2\2\u051f")
        buf.write("\u0523\5\6\4\2\u0520\u0521\7\20\2\2\u0521\u0522\t\3\2")
        buf.write("\2\u0522\u0524\5\6\4\2\u0523\u0520\3\2\2\2\u0523\u0524")
        buf.write("\3\2\2\2\u0524\u0525\3\2\2\2\u0525\u0526\7\5\2\2\u0526")
        buf.write("\u05da\3\2\2\2\u0527\u0528\5\u0114\u008b\2\u0528\u052a")
        buf.write("\7F\2\2\u0529\u052b\5\"\22\2\u052a\u0529\3\2\2\2\u052a")
        buf.write("\u052b\3\2\2\2\u052b\u052c\3\2\2\2\u052c\u052d\5\64\33")
        buf.write("\2\u052d\u052e\7\30\2\2\u052e\u052f\5\6\4\2\u052f\u05da")
        buf.write("\3\2\2\2\u0530\u0531\5\u0114\u008b\2\u0531\u0533\7F\2")
        buf.write("\2\u0532\u0534\5\"\22\2\u0533\u0532\3\2\2\2\u0533\u0534")
        buf.write("\3\2\2\2\u0534\u0535\3\2\2\2\u0535\u0536\5\64\33\2\u0536")
        buf.write("\u0537\7\30\2\2\u0537\u0538\7\21\2\2\u0538\u0539\7\4\2")
        buf.write("\2\u0539\u053a\5\6\4\2\u053a\u053b\7\20\2\2\u053b\u053c")
        buf.write("\5\6\4\2\u053c\u053d\7\5\2\2\u053d\u05da\3\2\2\2\u053e")
        buf.write("\u053f\5\u0114\u008b\2\u053f\u0540\7F\2\2\u0540\u0541")
        buf.write("\5\"\22\2\u0541\u0542\5\u0114\u008b\2\u0542\u05da\3\2")
        buf.write("\2\2\u0543\u0544\5\u0114\u008b\2\u0544\u0545\7F\2\2\u0545")
        buf.write("\u0546\5:\36\2\u0546\u05da\3\2\2\2\u0547\u0548\5\u0114")
        buf.write("\u008b\2\u0548\u0549\7F\2\2\u0549\u054a\5L\'\2\u054a\u05da")
        buf.write("\3\2\2\2\u054b\u054c\5\u0114\u008b\2\u054c\u054d\7F\2")
        buf.write("\2\u054d\u054e\5P)\2\u054e\u05da\3\2\2\2\u054f\u0550\5")
        buf.write("\u0114\u008b\2\u0550\u0551\7F\2\2\u0551\u0552\5Z.\2\u0552")
        buf.write("\u05da\3\2\2\2\u0553\u0554\5\u0114\u008b\2\u0554\u0555")
        buf.write("\7F\2\2\u0555\u0556\5d\63\2\u0556\u05da\3\2\2\2\u0557")
        buf.write("\u0558\5\u0114\u008b\2\u0558\u0559\7F\2\2\u0559\u055a")
        buf.write("\5h\65\2\u055a\u05da\3\2\2\2\u055b\u055c\5\u0114\u008b")
        buf.write("\2\u055c\u055d\7F\2\2\u055d\u055e\5l\67\2\u055e\u05da")
        buf.write("\3\2\2\2\u055f\u0560\5\u0114\u008b\2\u0560\u0561\7F\2")
        buf.write("\2\u0561\u0562\7\13\2\2\u0562\u0567\5\u0114\u008b\2\u0563")
        buf.write("\u0564\7\20\2\2\u0564\u0566\5\u0114\u008b\2\u0565\u0563")
        buf.write("\3\2\2\2\u0566\u0569\3\2\2\2\u0567\u0565\3\2\2\2\u0567")
        buf.write("\u0568\3\2\2\2\u0568\u056a\3\2\2\2\u0569\u0567\3\2\2\2")
        buf.write("\u056a\u056b\7\r\2\2\u056b\u05da\3\2\2\2\u056c\u056d\5")
        buf.write("\u0114\u008b\2\u056d\u056e\7F\2\2\u056e\u056f\5r:\2\u056f")
        buf.write("\u05da\3\2\2\2\u0570\u0571\5\u0114\u008b\2\u0571\u0572")
        buf.write("\7F\2\2\u0572\u0573\5V,\2\u0573\u05da\3\2\2\2\u0574\u0575")
        buf.write("\5\u0114\u008b\2\u0575\u0576\7F\2\2\u0576\u0577\5\u0088")
        buf.write("E\2\u0577\u05da\3\2\2\2\u0578\u0579\5\u0114\u008b\2\u0579")
        buf.write("\u057a\7F\2\2\u057a\u057b\5\u00aaV\2\u057b\u05da\3\2\2")
        buf.write("\2\u057c\u057d\5\u0114\u008b\2\u057d\u057e\7F\2\2\u057e")
        buf.write("\u057f\5\u00ba^\2\u057f\u05da\3\2\2\2\u0580\u0581\5\u0114")
        buf.write("\u008b\2\u0581\u0582\7F\2\2\u0582\u0583\5x=\2\u0583\u05da")
        buf.write("\3\2\2\2\u0584\u0585\5\u0114\u008b\2\u0585\u0586\7F\2")
        buf.write("\2\u0586\u0587\5\u008eH\2\u0587\u05da\3\2\2\2\u0588\u0589")
        buf.write("\5\u0114\u008b\2\u0589\u058a\7F\2\2\u058a\u058b\5\u0094")
        buf.write("K\2\u058b\u05da\3\2\2\2\u058c\u058d\5\u0114\u008b\2\u058d")
        buf.write("\u058e\7F\2\2\u058e\u058f\5\u00a0Q\2\u058f\u05da\3\2\2")
        buf.write("\2\u0590\u0591\5\u0114\u008b\2\u0591\u0592\7F\2\2\u0592")
        buf.write("\u0593\5\u00a8U\2\u0593\u05da\3\2\2\2\u0594\u0595\5\u0114")
        buf.write("\u008b\2\u0595\u0596\7F\2\2\u0596\u0597\5\u00b0Y\2\u0597")
        buf.write("\u05da\3\2\2\2\u0598\u0599\5\u0114\u008b\2\u0599\u059a")
        buf.write("\7F\2\2\u059a\u059b\5\u00b8]\2\u059b\u05da\3\2\2\2\u059c")
        buf.write("\u059d\5\u0114\u008b\2\u059d\u059e\7F\2\2\u059e\u059f")
        buf.write("\5\u00c2b\2\u059f\u05da\3\2\2\2\u05a0\u05a1\5\u0114\u008b")
        buf.write("\2\u05a1\u05a2\7F\2\2\u05a2\u05a3\5\u00ccg\2\u05a3\u05da")
        buf.write("\3\2\2\2\u05a4\u05da\5\u00d2j\2\u05a5\u05a6\5\u0114\u008b")
        buf.write("\2\u05a6\u05a7\7F\2\2\u05a7\u05a8\5\u00e4s\2\u05a8\u05da")
        buf.write("\3\2\2\2\u05a9\u05aa\5\u0114\u008b\2\u05aa\u05ab\7F\2")
        buf.write("\2\u05ab\u05ac\5\u00f4{\2\u05ac\u05da\3\2\2\2\u05ad\u05ae")
        buf.write("\5\u0114\u008b\2\u05ae\u05af\7F\2\2\u05af\u05b0\5\u00f6")
        buf.write("|\2\u05b0\u05da\3\2\2\2\u05b1\u05b2\5\u0114\u008b\2\u05b2")
        buf.write("\u05b3\7F\2\2\u05b3\u05b4\5\u00fe\u0080\2\u05b4\u05da")
        buf.write("\3\2\2\2\u05b5\u05b6\5\u0114\u008b\2\u05b6\u05b7\7F\2")
        buf.write("\2\u05b7\u05b8\5\u0102\u0082\2\u05b8\u05da\3\2\2\2\u05b9")
        buf.write("\u05ba\5\u0114\u008b\2\u05ba\u05bb\7F\2\2\u05bb\u05bc")
        buf.write("\5\u010e\u0088\2\u05bc\u05da\3\2\2\2\u05bd\u05be\5\u0114")
        buf.write("\u008b\2\u05be\u05bf\7F\2\2\u05bf\u05c0\5\u010c\u0087")
        buf.write("\2\u05c0\u05da\3\2\2\2\u05c1\u05c2\5\u00d4k\2\u05c2\u05c3")
        buf.write("\7^\2\2\u05c3\u05c4\5\u010c\u0087\2\u05c4\u05da\3\2\2")
        buf.write("\2\u05c5\u05c6\5\u0114\u008b\2\u05c6\u05c7\7F\2\2\u05c7")
        buf.write("\u05c8\5\u00f2z\2\u05c8\u05da\3\2\2\2\u05c9\u05ca\5\u0114")
        buf.write("\u008b\2\u05ca\u05cb\7F\2\2\u05cb\u05cc\5\u00eav\2\u05cc")
        buf.write("\u05da\3\2\2\2\u05cd\u05ce\5\u0114\u008b\2\u05ce\u05cf")
        buf.write("\7F\2\2\u05cf\u05d0\5\u00eex\2\u05d0\u05da\3\2\2\2\u05d1")
        buf.write("\u05d2\5\u0114\u008b\2\u05d2\u05d3\7F\2\2\u05d3\u05d4")
        buf.write("\5(\25\2\u05d4\u05da\3\2\2\2\u05d5\u05d6\5\u0114\u008b")
        buf.write("\2\u05d6\u05d7\7F\2\2\u05d7\u05d8\5 \21\2\u05d8\u05da")
        buf.write("\3\2\2\2\u05d9\u04e2\3\2\2\2\u05d9\u04e6\3\2\2\2\u05d9")
        buf.write("\u04ea\3\2\2\2\u05d9\u04f0\3\2\2\2\u05d9\u04f8\3\2\2\2")
        buf.write("\u05d9\u0502\3\2\2\2\u05d9\u0506\3\2\2\2\u05d9\u050a\3")
        buf.write("\2\2\2\u05d9\u050e\3\2\2\2\u05d9\u0512\3\2\2\2\u05d9\u0517")
        buf.write("\3\2\2\2\u05d9\u0527\3\2\2\2\u05d9\u0530\3\2\2\2\u05d9")
        buf.write("\u053e\3\2\2\2\u05d9\u0543\3\2\2\2\u05d9\u0547\3\2\2\2")
        buf.write("\u05d9\u054b\3\2\2\2\u05d9\u054f\3\2\2\2\u05d9\u0553\3")
        buf.write("\2\2\2\u05d9\u0557\3\2\2\2\u05d9\u055b\3\2\2\2\u05d9\u055f")
        buf.write("\3\2\2\2\u05d9\u056c\3\2\2\2\u05d9\u0570\3\2\2\2\u05d9")
        buf.write("\u0574\3\2\2\2\u05d9\u0578\3\2\2\2\u05d9\u057c\3\2\2\2")
        buf.write("\u05d9\u0580\3\2\2\2\u05d9\u0584\3\2\2\2\u05d9\u0588\3")
        buf.write("\2\2\2\u05d9\u058c\3\2\2\2\u05d9\u0590\3\2\2\2\u05d9\u0594")
        buf.write("\3\2\2\2\u05d9\u0598\3\2\2\2\u05d9\u059c\3\2\2\2\u05d9")
        buf.write("\u05a0\3\2\2\2\u05d9\u05a4\3\2\2\2\u05d9\u05a5\3\2\2\2")
        buf.write("\u05d9\u05a9\3\2\2\2\u05d9\u05ad\3\2\2\2\u05d9\u05b1\3")
        buf.write("\2\2\2\u05d9\u05b5\3\2\2\2\u05d9\u05b9\3\2\2\2\u05d9\u05bd")
        buf.write("\3\2\2\2\u05d9\u05c1\3\2\2\2\u05d9\u05c5\3\2\2\2\u05d9")
        buf.write("\u05c9\3\2\2\2\u05d9\u05cd\3\2\2\2\u05d9\u05d1\3\2\2\2")
        buf.write("\u05d9\u05d5\3\2\2\2\u05da\u0113\3\2\2\2\u05db\u05dc\t")
        buf.write("\6\2\2\u05dc\u0115\3\2\2\2\u05dd\u05de\t\7\2\2\u05de\u0117")
        buf.write("\3\2\2\2w\u011a\u011f\u0126\u0130\u013b\u013d\u0147\u014f")
        buf.write("\u0151\u0168\u016e\u0174\u017f\u018b\u018f\u0199\u019d")
        buf.write("\u01a1\u01a4\u01ab\u01bb\u01c0\u01c4\u01c8\u01d2\u01d5")
        buf.write("\u01db\u01e2\u01eb\u01fc\u0200\u0206\u020c\u0213\u0219")
        buf.write("\u0224\u0231\u0233\u0237\u0241\u0245\u024f\u0253\u0257")
        buf.write("\u025b\u0266\u026a\u026e\u0275\u0285\u028f\u0299\u029d")
        buf.write("\u02a1\u02a3\u02a7\u02ab\u02b4\u02bd\u02cb\u02d4\u02e2")
        buf.write("\u02e7\u02f6\u02fa\u02fe\u0300\u0304\u0308\u030d\u0317")
        buf.write("\u0327\u032c\u0336\u033a\u0340\u036a\u0377\u037b\u038b")
        buf.write("\u0390\u039a\u03a1\u03a5\u03a9\u03ae\u03bd\u03c2\u03d1")
        buf.write("\u03d4\u03e0\u03e5\u03f0\u041c\u0426\u0433\u043b\u0444")
        buf.write("\u0452\u0456\u045f\u046b\u0488\u048c\u049c\u04aa\u04c0")
        buf.write("\u04cf\u04d1\u04d8\u04df\u051a\u0523\u052a\u0533\u0567")
        buf.write("\u05d9")
        return buf.getvalue()


class AVScenariosParser ( Parser ):

    grammarFileName = "AVScenarios.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'+'", "'('", "')'", "'^'", "'*'", "'/'", 
                     "'-'", "'CreateScenario'", "'{'", "';'", "'}'", "'load'", 
                     "'AV'", "','", "'range'", "'&'", "'IMU'", "'ENU'", 
                     "'WGS84'", "'0'", "'1'", "'->'", "'related to'", "'pi'", 
                     "'deg'", "'rad'", "'EGO'", "'car'", "'bus'", "'Van'", 
                     "'truck'", "'bicycle'", "'motorbicycle'", "'tricycle'", 
                     "'red'", "'green'", "'blue'", "'black'", "'white'", 
                     "'Vehicle'", "'uniform'", "'Uniform'", "'Waypoint'", 
                     "'W'", "'WP'", "'waypoint'", "'w'", "'wp'", "'Pedestrian'", 
                     "'Obstacle'", "'sphere'", "'box'", "'cone'", "'cylinder'", 
                     "'Environment'", "':'", "'sunny'", "'rain'", "'snow'", 
                     "'fog'", "'wetness'", "'light'", "'middle'", "'heavy'", 
                     "'Intersection'", "'SpeedLimit'", "'Trace'", "'='", 
                     "'EXE'", "'=='", "'<'", "'<='", "'>'", "'>='", "'!='", 
                     "'G'", "'F'", "'X'", "'['", "']'", "'U'", "'dis'", 
                     "'ego'", "'perception'", "'truth'", "'diff'", "'vel'", 
                     "'spd'", "'acc'", "'~'", "'|'", "'|='", "'traffic'", 
                     "'norm'", "'.*'", "'./'", "'.+'", "'.-'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "String", "Variable_name", 
                      "Time", "Rgb_color", "Non_negative_value", "Non_negative_number", 
                      "WS", "LINE_COMMENT", "BLOCK_COMMENT" ]

    RULE_scenarios = 0
    RULE_string_expression = 1
    RULE_real_value_expression = 2
    RULE_coordinate_expression = 3
    RULE_scenario = 4
    RULE_npc_vehicles_parameter = 5
    RULE_pedestrians_parameter = 6
    RULE_obstacles_parameter = 7
    RULE_map_parameter = 8
    RULE_map_name = 9
    RULE_ego_parameter = 10
    RULE_ego_vehicle = 11
    RULE_parameter_list_ego = 12
    RULE_state_parameter = 13
    RULE_state_ = 14
    RULE_position = 15
    RULE_coordinate_frame = 16
    RULE_position_parameter = 17
    RULE_speed_parameter = 18
    RULE_speed = 19
    RULE_real_value = 20
    RULE_non_negative_real_value = 21
    RULE_float_value = 22
    RULE_number_value = 23
    RULE_coordinate = 24
    RULE_laneID_parameter = 25
    RULE_laneID = 26
    RULE_heading_parameter = 27
    RULE_heading = 28
    RULE_unit = 29
    RULE_direction = 30
    RULE_predefined_direction = 31
    RULE_vehicle_type_parameter = 32
    RULE_vehicle_type = 33
    RULE_type_parameter = 34
    RULE_type_ = 35
    RULE_specific_type = 36
    RULE_general_type = 37
    RULE_color_parameter = 38
    RULE_color = 39
    RULE_color_list = 40
    RULE_rgb_color = 41
    RULE_npc_vehicles = 42
    RULE_multi_npc_vehicles = 43
    RULE_npc_vehicle = 44
    RULE_npc_vehicle_parameter = 45
    RULE_parameter_list_npc = 46
    RULE_vehicle_motion_parameter = 47
    RULE_vehicle_motion = 48
    RULE_uniform_motion = 49
    RULE_uniform_index = 50
    RULE_waypoint_motion = 51
    RULE_state_list_parameter = 52
    RULE_state_list = 53
    RULE_multi_states = 54
    RULE_waypoint_index = 55
    RULE_pedestrians = 56
    RULE_multiple_pedestrians = 57
    RULE_pedestrian_parameter = 58
    RULE_pedestrian = 59
    RULE_parameter_list_ped = 60
    RULE_pedestrian_motion_parameter = 61
    RULE_pedestrian_motion = 62
    RULE_pedestrian_type_parameter = 63
    RULE_pedestrian_type = 64
    RULE_height_parameter = 65
    RULE_height = 66
    RULE_obstacles = 67
    RULE_multiple_obstacles = 68
    RULE_obstacle_parameter = 69
    RULE_obstacle = 70
    RULE_parameter_list_obs = 71
    RULE_shape_parameter = 72
    RULE_shape = 73
    RULE_sphere = 74
    RULE_box = 75
    RULE_cone = 76
    RULE_cylinder = 77
    RULE_env_parameter = 78
    RULE_env = 79
    RULE_parameter_list_env = 80
    RULE_weather_parameter = 81
    RULE_time_parameter = 82
    RULE_time = 83
    RULE_weather = 84
    RULE_multi_weathers = 85
    RULE_weather_statement_parameter = 86
    RULE_weather_statement = 87
    RULE_kind = 88
    RULE_weather_continuous_index_parameter = 89
    RULE_weather_discrete_level_parameter = 90
    RULE_weather_discrete_level = 91
    RULE_traffic = 92
    RULE_traffic_statement = 93
    RULE_intersection_traffic = 94
    RULE_meta_intersection_traffic_parameter = 95
    RULE_meta_intersection_traffic = 96
    RULE_intersection_ID_parameter = 97
    RULE_intersection_ID = 98
    RULE_lane_traffic = 99
    RULE_speed_limitation_parameter = 100
    RULE_speed_limitation = 101
    RULE_speed_range_parameter = 102
    RULE_speed_range = 103
    RULE_trace_assignment = 104
    RULE_trace_identifier = 105
    RULE_compare_operator = 106
    RULE_temporal_operator = 107
    RULE_temporal_operator1 = 108
    RULE_a = 109
    RULE_b = 110
    RULE_atom_statement_overall = 111
    RULE_atom_statement = 112
    RULE_distance_statement = 113
    RULE_position_element = 114
    RULE_ego_state_parameter = 115
    RULE_ego_state = 116
    RULE_agent_state_parameter = 117
    RULE_agent_state = 118
    RULE_agent_ground_truth_parameter = 119
    RULE_agent_ground_truth = 120
    RULE_perception_difference_statement = 121
    RULE_velocity_statement = 122
    RULE_velocity_parameter_for_statement = 123
    RULE_velocity_parameter = 124
    RULE_velocity = 125
    RULE_speed_statement = 126
    RULE_speed_parameter_for_statement = 127
    RULE_acceleration_statement = 128
    RULE_acceleration_parameter_for_statement = 129
    RULE_acceleration = 130
    RULE_atom_statement_parameter = 131
    RULE_atom_predicate = 132
    RULE_general_assertion = 133
    RULE_operator_related_assignments = 134
    RULE_assignment_statements = 135
    RULE_assignment_statement = 136
    RULE_identifier = 137
    RULE_arithmetic_operator = 138

    ruleNames =  [ "scenarios", "string_expression", "real_value_expression", 
                   "coordinate_expression", "scenario", "npc_vehicles_parameter", 
                   "pedestrians_parameter", "obstacles_parameter", "map_parameter", 
                   "map_name", "ego_parameter", "ego_vehicle", "parameter_list_ego", 
                   "state_parameter", "state_", "position", "coordinate_frame", 
                   "position_parameter", "speed_parameter", "speed", "real_value", 
                   "non_negative_real_value", "float_value", "number_value", 
                   "coordinate", "laneID_parameter", "laneID", "heading_parameter", 
                   "heading", "unit", "direction", "predefined_direction", 
                   "vehicle_type_parameter", "vehicle_type", "type_parameter", 
                   "type_", "specific_type", "general_type", "color_parameter", 
                   "color", "color_list", "rgb_color", "npc_vehicles", "multi_npc_vehicles", 
                   "npc_vehicle", "npc_vehicle_parameter", "parameter_list_npc", 
                   "vehicle_motion_parameter", "vehicle_motion", "uniform_motion", 
                   "uniform_index", "waypoint_motion", "state_list_parameter", 
                   "state_list", "multi_states", "waypoint_index", "pedestrians", 
                   "multiple_pedestrians", "pedestrian_parameter", "pedestrian", 
                   "parameter_list_ped", "pedestrian_motion_parameter", 
                   "pedestrian_motion", "pedestrian_type_parameter", "pedestrian_type", 
                   "height_parameter", "height", "obstacles", "multiple_obstacles", 
                   "obstacle_parameter", "obstacle", "parameter_list_obs", 
                   "shape_parameter", "shape", "sphere", "box", "cone", 
                   "cylinder", "env_parameter", "env", "parameter_list_env", 
                   "weather_parameter", "time_parameter", "time", "weather", 
                   "multi_weathers", "weather_statement_parameter", "weather_statement", 
                   "kind", "weather_continuous_index_parameter", "weather_discrete_level_parameter", 
                   "weather_discrete_level", "traffic", "traffic_statement", 
                   "intersection_traffic", "meta_intersection_traffic_parameter", 
                   "meta_intersection_traffic", "intersection_ID_parameter", 
                   "intersection_ID", "lane_traffic", "speed_limitation_parameter", 
                   "speed_limitation", "speed_range_parameter", "speed_range", 
                   "trace_assignment", "trace_identifier", "compare_operator", 
                   "temporal_operator", "temporal_operator1", "a", "b", 
                   "atom_statement_overall", "atom_statement", "distance_statement", 
                   "position_element", "ego_state_parameter", "ego_state", 
                   "agent_state_parameter", "agent_state", "agent_ground_truth_parameter", 
                   "agent_ground_truth", "perception_difference_statement", 
                   "velocity_statement", "velocity_parameter_for_statement", 
                   "velocity_parameter", "velocity", "speed_statement", 
                   "speed_parameter_for_statement", "acceleration_statement", 
                   "acceleration_parameter_for_statement", "acceleration", 
                   "atom_statement_parameter", "atom_predicate", "general_assertion", 
                   "operator_related_assignments", "assignment_statements", 
                   "assignment_statement", "identifier", "arithmetic_operator" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    T__89=90
    T__90=91
    T__91=92
    T__92=93
    T__93=94
    T__94=95
    T__95=96
    T__96=97
    T__97=98
    String=99
    Variable_name=100
    Time=101
    Rgb_color=102
    Non_negative_value=103
    Non_negative_number=104
    WS=105
    LINE_COMMENT=106
    BLOCK_COMMENT=107

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ScenariosContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_scenarios

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class EntryContext(ScenariosContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ScenariosContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def assignment_statements(self):
            return self.getTypedRuleContext(AVScenariosParser.Assignment_statementsContext,0)

        def EOF(self):
            return self.getToken(AVScenariosParser.EOF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry" ):
                listener.enterEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry" ):
                listener.exitEntry(self)



    def scenarios(self):

        localctx = AVScenariosParser.ScenariosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_scenarios)
        try:
            localctx = AVScenariosParser.EntryContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 278
            self.assignment_statements()
            self.state = 280
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 279
                self.match(AVScenariosParser.EOF)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class String_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_string_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class String_expression_for_string_expressionContext(String_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.String_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.String_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_expression_for_string_expression" ):
                listener.enterString_expression_for_string_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_expression_for_string_expression" ):
                listener.exitString_expression_for_string_expression(self)


    class String_idContext(String_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.String_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_id" ):
                listener.enterString_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_id" ):
                listener.exitString_id(self)


    class String_for_string_expressionContext(String_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.String_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def String(self):
            return self.getToken(AVScenariosParser.String, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_for_string_expression" ):
                listener.enterString_for_string_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_for_string_expression" ):
                listener.exitString_for_string_expression(self)



    def string_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.String_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 2
        self.enterRecursionRule(localctx, 2, self.RULE_string_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 285
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.String]:
                localctx = AVScenariosParser.String_for_string_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 283
                self.match(AVScenariosParser.String)
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.String_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 284
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 292
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.String_expression_for_string_expressionContext(self, AVScenariosParser.String_expressionContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_string_expression)
                    self.state = 287
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 288
                    self.match(AVScenariosParser.T__0)
                    self.state = 289
                    self.string_expression(3) 
                self.state = 294
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Real_value_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_real_value_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Real_value_expression_idContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReal_value_expression_id" ):
                listener.enterReal_value_expression_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReal_value_expression_id" ):
                listener.exitReal_value_expression_id(self)


    class Cifang_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCifang_of_real_value_expression" ):
                listener.enterCifang_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCifang_of_real_value_expression" ):
                listener.exitCifang_of_real_value_expression(self)


    class Real_value_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReal_value_of_real_value_expression" ):
                listener.enterReal_value_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReal_value_of_real_value_expression" ):
                listener.exitReal_value_of_real_value_expression(self)


    class Plus_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlus_of_real_value_expression" ):
                listener.enterPlus_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlus_of_real_value_expression" ):
                listener.exitPlus_of_real_value_expression(self)


    class Kuohao_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKuohao_of_real_value_expression" ):
                listener.enterKuohao_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKuohao_of_real_value_expression" ):
                listener.exitKuohao_of_real_value_expression(self)


    class Multi_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_of_real_value_expression" ):
                listener.enterMulti_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_of_real_value_expression" ):
                listener.exitMulti_of_real_value_expression(self)



    def real_value_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Real_value_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_real_value_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 302
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__0, AVScenariosParser.T__6, AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.Non_negative_value, AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Real_value_of_real_value_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 296
                self.real_value()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Kuohao_of_real_value_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 297
                self.match(AVScenariosParser.T__1)
                self.state = 298
                self.real_value_expression(0)
                self.state = 299
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Real_value_expression_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 301
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 315
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 313
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                    if la_ == 1:
                        localctx = AVScenariosParser.Cifang_of_real_value_expressionContext(self, AVScenariosParser.Real_value_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_value_expression)
                        self.state = 304
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 305
                        self.match(AVScenariosParser.T__3)
                        self.state = 306
                        self.real_value_expression(5)
                        pass

                    elif la_ == 2:
                        localctx = AVScenariosParser.Multi_of_real_value_expressionContext(self, AVScenariosParser.Real_value_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_value_expression)
                        self.state = 307
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 308
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==AVScenariosParser.T__4 or _la==AVScenariosParser.T__5):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 309
                        self.real_value_expression(4)
                        pass

                    elif la_ == 3:
                        localctx = AVScenariosParser.Plus_of_real_value_expressionContext(self, AVScenariosParser.Real_value_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_value_expression)
                        self.state = 310
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 311
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 312
                        self.real_value_expression(3)
                        pass

             
                self.state = 317
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Coordinate_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_coordinate_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Plus_of_coordinate_expressionContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def coordinate_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Coordinate_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlus_of_coordinate_expression" ):
                listener.enterPlus_of_coordinate_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlus_of_coordinate_expression" ):
                listener.exitPlus_of_coordinate_expression(self)


    class Coordinate_expression_idContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoordinate_expression_id" ):
                listener.enterCoordinate_expression_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoordinate_expression_id" ):
                listener.exitCoordinate_expression_id(self)


    class Coordinate_of_coordinate_expressionContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate(self):
            return self.getTypedRuleContext(AVScenariosParser.CoordinateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoordinate_of_coordinate_expression" ):
                listener.enterCoordinate_of_coordinate_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoordinate_of_coordinate_expression" ):
                listener.exitCoordinate_of_coordinate_expression(self)


    class Kuohao_of_coordinate_expressionContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKuohao_of_coordinate_expression" ):
                listener.enterKuohao_of_coordinate_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKuohao_of_coordinate_expression" ):
                listener.exitKuohao_of_coordinate_expression(self)


    class Muti_of_coordinate_expressionContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def coordinate_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Coordinate_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMuti_of_coordinate_expression" ):
                listener.enterMuti_of_coordinate_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMuti_of_coordinate_expression" ):
                listener.exitMuti_of_coordinate_expression(self)



    def coordinate_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Coordinate_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 6
        self.enterRecursionRule(localctx, 6, self.RULE_coordinate_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 325
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Coordinate_of_coordinate_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 319
                self.coordinate()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Kuohao_of_coordinate_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 320
                self.match(AVScenariosParser.T__1)
                self.state = 321
                self.coordinate_expression(0)
                self.state = 322
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Coordinate_expression_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 324
                self.identifier()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 335
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 333
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
                    if la_ == 1:
                        localctx = AVScenariosParser.Muti_of_coordinate_expressionContext(self, AVScenariosParser.Coordinate_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_coordinate_expression)
                        self.state = 327
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 328
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==AVScenariosParser.T__4 or _la==AVScenariosParser.T__5):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 329
                        self.coordinate_expression(4)
                        pass

                    elif la_ == 2:
                        localctx = AVScenariosParser.Plus_of_coordinate_expressionContext(self, AVScenariosParser.Coordinate_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_coordinate_expression)
                        self.state = 330
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 331
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 332
                        self.coordinate_expression(3)
                        pass

             
                self.state = 337
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ScenarioContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_scenario

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Create_scenarioContext(ScenarioContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ScenarioContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def map_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Map_parameterContext,0)

        def ego_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_parameterContext,0)

        def npc_vehicles_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicles_parameterContext,0)

        def pedestrians_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrians_parameterContext,0)

        def obstacles_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Obstacles_parameterContext,0)

        def env_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Env_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_scenario" ):
                listener.enterCreate_scenario(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_scenario" ):
                listener.exitCreate_scenario(self)



    def scenario(self):

        localctx = AVScenariosParser.ScenarioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_scenario)
        try:
            localctx = AVScenariosParser.Create_scenarioContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 338
            self.match(AVScenariosParser.T__7)
            self.state = 339
            self.match(AVScenariosParser.T__8)
            self.state = 340
            self.map_parameter()
            self.state = 341
            self.match(AVScenariosParser.T__9)
            self.state = 342
            self.ego_parameter()
            self.state = 343
            self.match(AVScenariosParser.T__9)
            self.state = 344
            self.npc_vehicles_parameter()
            self.state = 345
            self.match(AVScenariosParser.T__9)
            self.state = 346
            self.pedestrians_parameter()
            self.state = 347
            self.match(AVScenariosParser.T__9)
            self.state = 348
            self.obstacles_parameter()
            self.state = 349
            self.match(AVScenariosParser.T__9)
            self.state = 350
            self.env_parameter()
            self.state = 351
            self.match(AVScenariosParser.T__9)
            self.state = 352
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Npc_vehicles_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_npc_vehicles_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Npc_varContext(Npc_vehicles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_var" ):
                listener.enterNpc_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_var" ):
                listener.exitNpc_var(self)


    class Npc_emptyContext(Npc_vehicles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_empty" ):
                listener.enterNpc_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_empty" ):
                listener.exitNpc_empty(self)


    class Npc_npcContext(Npc_vehicles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def npc_vehicles(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehiclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_npc" ):
                listener.enterNpc_npc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_npc" ):
                listener.exitNpc_npc(self)



    def npc_vehicles_parameter(self):

        localctx = AVScenariosParser.Npc_vehicles_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_npc_vehicles_parameter)
        try:
            self.state = 358
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Npc_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 354
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Npc_npcContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 355
                self.npc_vehicles()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Npc_emptyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 356
                self.match(AVScenariosParser.T__8)
                self.state = 357
                self.match(AVScenariosParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrians_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrians_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrians_emptyContext(Pedestrians_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrians_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrians_empty" ):
                listener.enterPedestrians_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrians_empty" ):
                listener.exitPedestrians_empty(self)


    class Pedestrians_pedContext(Pedestrians_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrians_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrians(self):
            return self.getTypedRuleContext(AVScenariosParser.PedestriansContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrians_ped" ):
                listener.enterPedestrians_ped(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrians_ped" ):
                listener.exitPedestrians_ped(self)


    class Pedestrians_varContext(Pedestrians_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrians_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrians_var" ):
                listener.enterPedestrians_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrians_var" ):
                listener.exitPedestrians_var(self)



    def pedestrians_parameter(self):

        localctx = AVScenariosParser.Pedestrians_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_pedestrians_parameter)
        try:
            self.state = 364
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pedestrians_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 360
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pedestrians_pedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 361
                self.pedestrians()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Pedestrians_emptyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 362
                self.match(AVScenariosParser.T__8)
                self.state = 363
                self.match(AVScenariosParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Obstacles_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_obstacles_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Obstacles_emptyContext(Obstacles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_empty" ):
                listener.enterObstacles_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_empty" ):
                listener.exitObstacles_empty(self)


    class Obstacles_obsContext(Obstacles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def obstacles(self):
            return self.getTypedRuleContext(AVScenariosParser.ObstaclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_obs" ):
                listener.enterObstacles_obs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_obs" ):
                listener.exitObstacles_obs(self)


    class Obstacles_varContext(Obstacles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_var" ):
                listener.enterObstacles_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_var" ):
                listener.exitObstacles_var(self)



    def obstacles_parameter(self):

        localctx = AVScenariosParser.Obstacles_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_obstacles_parameter)
        try:
            self.state = 370
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Obstacles_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 366
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Obstacles_obsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 367
                self.obstacles()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Obstacles_emptyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 368
                self.match(AVScenariosParser.T__8)
                self.state = 369
                self.match(AVScenariosParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Map_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_map_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Map_load_nameContext(Map_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Map_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def map_name(self):
            return self.getTypedRuleContext(AVScenariosParser.Map_nameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMap_load_name" ):
                listener.enterMap_load_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMap_load_name" ):
                listener.exitMap_load_name(self)



    def map_parameter(self):

        localctx = AVScenariosParser.Map_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_map_parameter)
        try:
            localctx = AVScenariosParser.Map_load_nameContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 372
            self.match(AVScenariosParser.T__11)
            self.state = 373
            self.match(AVScenariosParser.T__1)
            self.state = 374
            self.map_name()
            self.state = 375
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Map_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_map_name

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Map_name_strContext(Map_nameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Map_nameContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMap_name_str" ):
                listener.enterMap_name_str(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMap_name_str" ):
                listener.exitMap_name_str(self)



    def map_name(self):

        localctx = AVScenariosParser.Map_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_map_name)
        try:
            localctx = AVScenariosParser.Map_name_strContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 377
            self.string_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ego_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_ego_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Ego_ego_vehicleContext(Ego_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_vehicle(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_vehicleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_ego_vehicle" ):
                listener.enterEgo_ego_vehicle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_ego_vehicle" ):
                listener.exitEgo_ego_vehicle(self)


    class Ego_ego_varContext(Ego_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_ego_var" ):
                listener.enterEgo_ego_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_ego_var" ):
                listener.exitEgo_ego_var(self)



    def ego_parameter(self):

        localctx = AVScenariosParser.Ego_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_ego_parameter)
        try:
            self.state = 381
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Ego_ego_vehicleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 379
                self.ego_vehicle()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Ego_ego_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 380
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ego_vehicleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_ego_vehicle

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Ego_avContext(Ego_vehicleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_vehicleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_ego(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_egoContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_av" ):
                listener.enterEgo_av(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_av" ):
                listener.exitEgo_av(self)



    def ego_vehicle(self):

        localctx = AVScenariosParser.Ego_vehicleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_ego_vehicle)
        try:
            localctx = AVScenariosParser.Ego_avContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 383
            self.match(AVScenariosParser.T__12)
            self.state = 384
            self.match(AVScenariosParser.T__1)
            self.state = 385
            self.parameter_list_ego()
            self.state = 386
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_egoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_ego

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_list_ego_Context(Parameter_list_egoContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_egoContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.State_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,i)

        def vehicle_type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_type_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_list_ego_" ):
                listener.enterPar_list_ego_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_list_ego_" ):
                listener.exitPar_list_ego_(self)



    def parameter_list_ego(self):

        localctx = AVScenariosParser.Parameter_list_egoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_parameter_list_ego)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.Par_list_ego_Context(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 388
            self.state_parameter()
            self.state = 389
            self.match(AVScenariosParser.T__13)
            self.state = 390
            self.state_parameter()
            self.state = 393
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AVScenariosParser.T__13:
                self.state = 391
                self.match(AVScenariosParser.T__13)
                self.state = 392
                self.vehicle_type_parameter()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_state_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class State_stateContext(State_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_(self):
            return self.getTypedRuleContext(AVScenariosParser.State_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_state" ):
                listener.enterState_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_state" ):
                listener.exitState_state(self)


    class State_state_varContext(State_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_state_var" ):
                listener.enterState_state_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_state_var" ):
                listener.exitState_state_var(self)



    def state_parameter(self):

        localctx = AVScenariosParser.State_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_state_parameter)
        try:
            self.state = 397
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.State_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 395
                self.state_()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.State_state_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 396
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_state_

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class State_positionContext(State_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def position_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Position_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_position" ):
                listener.enterState_position(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_position" ):
                listener.exitState_position(self)


    class State_position_heading_speedContext(State_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def position_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Position_parameterContext,0)

        def heading_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Heading_parameterContext,0)

        def speed_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_position_heading_speed" ):
                listener.enterState_position_heading_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_position_heading_speed" ):
                listener.exitState_position_heading_speed(self)



    def state_(self):

        localctx = AVScenariosParser.State_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_state_)
        self._la = 0 # Token type
        try:
            self.state = 415
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.State_positionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 399
                self.match(AVScenariosParser.T__1)
                self.state = 400
                self.position_parameter()
                self.state = 401
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.State_position_heading_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 403
                self.match(AVScenariosParser.T__1)
                self.state = 404
                self.position_parameter()
                self.state = 405
                self.match(AVScenariosParser.T__13)
                self.state = 407
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__0) | (1 << AVScenariosParser.T__1) | (1 << AVScenariosParser.T__6) | (1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__14) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__19) | (1 << AVScenariosParser.T__20) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)) | (1 << (AVScenariosParser.T__81 - 65)) | (1 << (AVScenariosParser.T__83 - 65)) | (1 << (AVScenariosParser.T__84 - 65)) | (1 << (AVScenariosParser.T__85 - 65)) | (1 << (AVScenariosParser.T__92 - 65)) | (1 << (AVScenariosParser.T__93 - 65)) | (1 << (AVScenariosParser.Variable_name - 65)) | (1 << (AVScenariosParser.Non_negative_value - 65)) | (1 << (AVScenariosParser.Non_negative_number - 65)))) != 0):
                    self.state = 406
                    self.heading_parameter()


                self.state = 411
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 409
                    self.match(AVScenariosParser.T__13)
                    self.state = 410
                    self.speed_parameter()


                self.state = 413
                self.match(AVScenariosParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_position

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pos_coor_coorContext(PositionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PositionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate(self):
            return self.getTypedRuleContext(AVScenariosParser.CoordinateContext,0)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_coor_coor" ):
                listener.enterPos_coor_coor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_coor_coor" ):
                listener.exitPos_coor_coor(self)


    class Pos_coor_range1Context(PositionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PositionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_coor_range1" ):
                listener.enterPos_coor_range1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_coor_range1" ):
                listener.exitPos_coor_range1(self)


    class Pos_coor_coor2Context(PositionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PositionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_coor_coor2" ):
                listener.enterPos_coor_coor2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_coor_coor2" ):
                listener.exitPos_coor_coor2(self)



    def position(self):

        localctx = AVScenariosParser.PositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_position)
        try:
            self.state = 441
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pos_coor_coorContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 418
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
                if la_ == 1:
                    self.state = 417
                    self.coordinate_frame()


                self.state = 420
                self.coordinate()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pos_coor_coor2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 421
                self.coordinate_frame()
                self.state = 422
                self.coordinate_expression(0)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Pos_coor_range1Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 425
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
                if la_ == 1:
                    self.state = 424
                    self.coordinate_frame()


                self.state = 427
                self.coordinate_expression(0)
                self.state = 428
                self.match(AVScenariosParser.T__14)
                self.state = 429
                self.match(AVScenariosParser.T__1)
                self.state = 430
                self.real_value_expression(0)
                self.state = 431
                self.match(AVScenariosParser.T__13)
                self.state = 432
                self.real_value_expression(0)
                self.state = 433
                self.match(AVScenariosParser.T__2)
                self.state = 434
                self.match(AVScenariosParser.T__15)
                self.state = 435
                self.match(AVScenariosParser.T__1)
                self.state = 436
                self.real_value_expression(0)
                self.state = 437
                self.match(AVScenariosParser.T__13)
                self.state = 438
                self.real_value_expression(0)
                self.state = 439
                self.match(AVScenariosParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Coordinate_frameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_coordinate_frame

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Coor_imuContext(Coordinate_frameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_frameContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_imu" ):
                listener.enterCoor_imu(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_imu" ):
                listener.exitCoor_imu(self)


    class Coor_enuContext(Coordinate_frameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_frameContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_enu" ):
                listener.enterCoor_enu(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_enu" ):
                listener.exitCoor_enu(self)


    class Coor_wgs84Context(Coordinate_frameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_frameContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_wgs84" ):
                listener.enterCoor_wgs84(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_wgs84" ):
                listener.exitCoor_wgs84(self)



    def coordinate_frame(self):

        localctx = AVScenariosParser.Coordinate_frameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_coordinate_frame)
        try:
            self.state = 446
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__16]:
                localctx = AVScenariosParser.Coor_imuContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 443
                self.match(AVScenariosParser.T__16)
                pass
            elif token in [AVScenariosParser.T__17]:
                localctx = AVScenariosParser.Coor_enuContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 444
                self.match(AVScenariosParser.T__17)
                pass
            elif token in [AVScenariosParser.T__18]:
                localctx = AVScenariosParser.Coor_wgs84Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 445
                self.match(AVScenariosParser.T__18)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Position_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_position_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pos_pos_varContext(Position_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_pos_var" ):
                listener.enterPos_pos_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_pos_var" ):
                listener.exitPos_pos_var(self)


    class Pos_posContext(Position_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def position(self):
            return self.getTypedRuleContext(AVScenariosParser.PositionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_pos" ):
                listener.enterPos_pos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_pos" ):
                listener.exitPos_pos(self)



    def position_parameter(self):

        localctx = AVScenariosParser.Position_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_position_parameter)
        try:
            self.state = 450
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pos_posContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 448
                self.position()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pos_pos_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 449
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_speed_varContext(Speed_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_speed_var" ):
                listener.enterSpeed_speed_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_speed_var" ):
                listener.exitSpeed_speed_var(self)


    class Speed_speedContext(Speed_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed(self):
            return self.getTypedRuleContext(AVScenariosParser.SpeedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_speed" ):
                listener.enterSpeed_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_speed" ):
                listener.exitSpeed_speed(self)



    def speed_parameter(self):

        localctx = AVScenariosParser.Speed_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_speed_parameter)
        try:
            self.state = 454
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Speed_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 452
                self.speed()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Speed_speed_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 453
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SpeedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_rvContext(SpeedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.SpeedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_rv" ):
                listener.enterSpeed_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_rv" ):
                listener.exitSpeed_rv(self)


    class Speed_range_for_stateContext(SpeedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.SpeedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_range_for_state" ):
                listener.enterSpeed_range_for_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_range_for_state" ):
                listener.exitSpeed_range_for_state(self)



    def speed(self):

        localctx = AVScenariosParser.SpeedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_speed)
        try:
            self.state = 464
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__0, AVScenariosParser.T__1, AVScenariosParser.T__6, AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name, AVScenariosParser.Non_negative_value, AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Speed_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 456
                self.real_value_expression(0)
                pass
            elif token in [AVScenariosParser.T__14]:
                localctx = AVScenariosParser.Speed_range_for_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 457
                self.match(AVScenariosParser.T__14)
                self.state = 458
                self.match(AVScenariosParser.T__1)
                self.state = 459
                self.real_value_expression(0)
                self.state = 460
                self.match(AVScenariosParser.T__13)
                self.state = 461
                self.real_value_expression(0)
                self.state = 462
                self.match(AVScenariosParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Real_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_real_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RvContext(Real_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_valueContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def non_negative_real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Non_negative_real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRv" ):
                listener.enterRv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRv" ):
                listener.exitRv(self)



    def real_value(self):

        localctx = AVScenariosParser.Real_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_real_value)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.RvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 467
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6:
                self.state = 466
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 469
            self.non_negative_real_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Non_negative_real_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_non_negative_real_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Non_negative_rvContext(Non_negative_real_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Non_negative_real_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def float_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Float_valueContext,0)

        def number_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Number_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_rv" ):
                listener.enterNon_negative_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_rv" ):
                listener.exitNon_negative_rv(self)



    def non_negative_real_value(self):

        localctx = AVScenariosParser.Non_negative_real_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_non_negative_real_value)
        try:
            localctx = AVScenariosParser.Non_negative_rvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 473
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.Non_negative_value]:
                self.state = 471
                self.float_value()
                pass
            elif token in [AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.Non_negative_number]:
                self.state = 472
                self.number_value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Float_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_float_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Non_negative_floatContext(Float_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Float_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Non_negative_value(self):
            return self.getToken(AVScenariosParser.Non_negative_value, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_float" ):
                listener.enterNon_negative_float(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_float" ):
                listener.exitNon_negative_float(self)



    def float_value(self):

        localctx = AVScenariosParser.Float_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_float_value)
        try:
            localctx = AVScenariosParser.Non_negative_floatContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 475
            self.match(AVScenariosParser.Non_negative_value)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Number_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_number_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Non_negative_numberContext(Number_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Number_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Non_negative_number(self):
            return self.getToken(AVScenariosParser.Non_negative_number, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_number" ):
                listener.enterNon_negative_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_number" ):
                listener.exitNon_negative_number(self)


    class Non_negative_conflict_1Context(Number_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Number_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_conflict_1" ):
                listener.enterNon_negative_conflict_1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_conflict_1" ):
                listener.exitNon_negative_conflict_1(self)


    class Non_negative_conflict_0Context(Number_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Number_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_conflict_0" ):
                listener.enterNon_negative_conflict_0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_conflict_0" ):
                listener.exitNon_negative_conflict_0(self)



    def number_value(self):

        localctx = AVScenariosParser.Number_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_number_value)
        try:
            self.state = 480
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Non_negative_numberContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 477
                self.match(AVScenariosParser.Non_negative_number)
                pass
            elif token in [AVScenariosParser.T__19]:
                localctx = AVScenariosParser.Non_negative_conflict_0Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 478
                self.match(AVScenariosParser.T__19)
                pass
            elif token in [AVScenariosParser.T__20]:
                localctx = AVScenariosParser.Non_negative_conflict_1Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 479
                self.match(AVScenariosParser.T__20)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CoordinateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_coordinate

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Coor_laneID_rangeContext(CoordinateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.CoordinateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_laneID_range" ):
                listener.enterCoor_laneID_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_laneID_range" ):
                listener.exitCoor_laneID_range(self)


    class Coor_rv_rvContext(CoordinateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.CoordinateContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_rv_rv" ):
                listener.enterCoor_rv_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_rv_rv" ):
                listener.exitCoor_rv_rv(self)


    class Coor_laneID_rvContext(CoordinateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.CoordinateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_laneID_rv" ):
                listener.enterCoor_laneID_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_laneID_rv" ):
                listener.exitCoor_laneID_rv(self)



    def coordinate(self):

        localctx = AVScenariosParser.CoordinateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_coordinate)
        self._la = 0 # Token type
        try:
            self.state = 506
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Coor_rv_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 482
                self.match(AVScenariosParser.T__1)
                self.state = 483
                self.real_value_expression(0)
                self.state = 484
                self.match(AVScenariosParser.T__13)
                self.state = 485
                self.real_value_expression(0)
                self.state = 489
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 486
                    self.match(AVScenariosParser.T__13)
                    self.state = 487
                    localctx.op = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                        localctx.op = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 488
                    self.real_value_expression(0)


                self.state = 491
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Coor_laneID_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 493
                self.laneID_parameter()
                self.state = 494
                self.match(AVScenariosParser.T__21)
                self.state = 495
                self.real_value_expression(0)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Coor_laneID_rangeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 497
                self.laneID_parameter()
                self.state = 498
                self.match(AVScenariosParser.T__21)
                self.state = 499
                self.match(AVScenariosParser.T__14)
                self.state = 500
                self.match(AVScenariosParser.T__1)
                self.state = 501
                self.real_value_expression(0)
                self.state = 502
                self.match(AVScenariosParser.T__13)
                self.state = 503
                self.real_value_expression(0)
                self.state = 504
                self.match(AVScenariosParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LaneID_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_laneID_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LaneID_laneIDContext(LaneID_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.LaneID_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneIDContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaneID_laneID" ):
                listener.enterLaneID_laneID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaneID_laneID" ):
                listener.exitLaneID_laneID(self)


    class LaneID_laneID_varContext(LaneID_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.LaneID_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaneID_laneID_var" ):
                listener.enterLaneID_laneID_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaneID_laneID_var" ):
                listener.exitLaneID_laneID_var(self)



    def laneID_parameter(self):

        localctx = AVScenariosParser.LaneID_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_laneID_parameter)
        try:
            self.state = 510
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.LaneID_laneID_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 508
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.LaneID_laneIDContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 509
                self.laneID()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LaneIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_laneID

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LaneID_strContext(LaneIDContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.LaneIDContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaneID_str" ):
                listener.enterLaneID_str(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaneID_str" ):
                listener.exitLaneID_str(self)



    def laneID(self):

        localctx = AVScenariosParser.LaneIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_laneID)
        try:
            localctx = AVScenariosParser.LaneID_strContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 512
            self.string_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Heading_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_heading_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Head_varContext(Heading_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Heading_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_var" ):
                listener.enterHead_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_var" ):
                listener.exitHead_var(self)


    class Head_headingContext(Heading_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Heading_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def heading(self):
            return self.getTypedRuleContext(AVScenariosParser.HeadingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_heading" ):
                listener.enterHead_heading(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_heading" ):
                listener.exitHead_heading(self)



    def heading_parameter(self):

        localctx = AVScenariosParser.Heading_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_heading_parameter)
        try:
            self.state = 516
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Head_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 514
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Head_headingContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 515
                self.heading()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HeadingContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_heading

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Head_pi_value_rangeContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_pi_value_range" ):
                listener.enterHead_pi_value_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_pi_value_range" ):
                listener.exitHead_pi_value_range(self)


    class Head_pi_valueContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_pi_value" ):
                listener.enterHead_pi_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_pi_value" ):
                listener.exitHead_pi_value(self)


    class Head_value_rangeContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_value_range" ):
                listener.enterHead_value_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_value_range" ):
                listener.exitHead_value_range(self)


    class Head_only_pi_valueContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_only_pi_value" ):
                listener.enterHead_only_pi_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_only_pi_value" ):
                listener.exitHead_only_pi_value(self)


    class Head_valueContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_value" ):
                listener.enterHead_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_value" ):
                listener.exitHead_value(self)



    def heading(self):

        localctx = AVScenariosParser.HeadingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_heading)
        self._la = 0 # Token type
        try:
            self.state = 561
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Head_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 518
                self.real_value_expression(0)
                self.state = 519
                self.unit()
                self.state = 522
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 520
                    self.match(AVScenariosParser.T__22)
                    self.state = 521
                    self.direction()


                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Head_pi_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 524
                self.real_value_expression(0)
                self.state = 525
                self.match(AVScenariosParser.T__23)
                self.state = 526
                self.unit()
                self.state = 529
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 527
                    self.match(AVScenariosParser.T__22)
                    self.state = 528
                    self.direction()


                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Head_only_pi_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 531
                self.match(AVScenariosParser.T__23)
                self.state = 532
                self.unit()
                self.state = 535
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 533
                    self.match(AVScenariosParser.T__22)
                    self.state = 534
                    self.direction()


                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Head_value_rangeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 537
                self.match(AVScenariosParser.T__14)
                self.state = 538
                self.match(AVScenariosParser.T__1)
                self.state = 539
                self.real_value_expression(0)
                self.state = 540
                self.match(AVScenariosParser.T__13)
                self.state = 541
                self.real_value_expression(0)
                self.state = 542
                self.match(AVScenariosParser.T__2)
                self.state = 543
                self.unit()
                self.state = 546
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 544
                    self.match(AVScenariosParser.T__22)
                    self.state = 545
                    self.direction()


                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Head_pi_value_rangeContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 548
                self.match(AVScenariosParser.T__14)
                self.state = 549
                self.match(AVScenariosParser.T__1)
                self.state = 550
                self.real_value_expression(0)
                self.state = 551
                self.match(AVScenariosParser.T__23)
                self.state = 552
                self.match(AVScenariosParser.T__13)
                self.state = 553
                self.real_value_expression(0)
                self.state = 554
                self.match(AVScenariosParser.T__23)
                self.state = 555
                self.match(AVScenariosParser.T__2)
                self.state = 556
                self.unit()
                self.state = 559
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 557
                    self.match(AVScenariosParser.T__22)
                    self.state = 558
                    self.direction()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_unit

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Unit_degContext(UnitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.UnitContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_deg" ):
                listener.enterUnit_deg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_deg" ):
                listener.exitUnit_deg(self)


    class Unit_radContext(UnitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.UnitContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_rad" ):
                listener.enterUnit_rad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_rad" ):
                listener.exitUnit_rad(self)



    def unit(self):

        localctx = AVScenariosParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_unit)
        try:
            self.state = 565
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__24]:
                localctx = AVScenariosParser.Unit_degContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 563
                self.match(AVScenariosParser.T__24)
                pass
            elif token in [AVScenariosParser.T__25]:
                localctx = AVScenariosParser.Unit_radContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 564
                self.match(AVScenariosParser.T__25)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DirectionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_direction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Direction_preContext(DirectionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.DirectionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predefined_direction(self):
            return self.getTypedRuleContext(AVScenariosParser.Predefined_directionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirection_pre" ):
                listener.enterDirection_pre(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirection_pre" ):
                listener.exitDirection_pre(self)



    def direction(self):

        localctx = AVScenariosParser.DirectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_direction)
        try:
            localctx = AVScenariosParser.Direction_preContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 567
            self.predefined_direction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Predefined_directionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_predefined_direction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pre_idContext(Predefined_directionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Predefined_directionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPre_id" ):
                listener.enterPre_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPre_id" ):
                listener.exitPre_id(self)


    class Pre_laneContext(Predefined_directionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Predefined_directionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPre_lane" ):
                listener.enterPre_lane(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPre_lane" ):
                listener.exitPre_lane(self)


    class Pre_egoContext(Predefined_directionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Predefined_directionContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPre_ego" ):
                listener.enterPre_ego(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPre_ego" ):
                listener.exitPre_ego(self)



    def predefined_direction(self):

        localctx = AVScenariosParser.Predefined_directionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_predefined_direction)
        try:
            self.state = 575
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pre_laneContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 569
                self.laneID_parameter()
                self.state = 570
                self.match(AVScenariosParser.T__21)
                self.state = 571
                self.real_value_expression(0)
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pre_egoContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 573
                self.match(AVScenariosParser.T__26)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Pre_idContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 574
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vehicle_type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_vehicle_type_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Vehicle_vehicle_type_varContext(Vehicle_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_vehicle_type_var" ):
                listener.enterVehicle_vehicle_type_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_vehicle_type_var" ):
                listener.exitVehicle_vehicle_type_var(self)


    class Vehicle_vehicle_typeContext(Vehicle_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def vehicle_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_vehicle_type" ):
                listener.enterVehicle_vehicle_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_vehicle_type" ):
                listener.exitVehicle_vehicle_type(self)



    def vehicle_type_parameter(self):

        localctx = AVScenariosParser.Vehicle_type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_vehicle_type_parameter)
        try:
            self.state = 579
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Vehicle_vehicle_type_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 577
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Vehicle_vehicle_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 578
                self.vehicle_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vehicle_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_vehicle_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Vehicle_type_colorContext(Vehicle_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Type_parameterContext,0)

        def color_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Color_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_type_color" ):
                listener.enterVehicle_type_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_type_color" ):
                listener.exitVehicle_type_color(self)


    class Vehicle_type_Context(Vehicle_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Type_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_type_" ):
                listener.enterVehicle_type_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_type_" ):
                listener.exitVehicle_type_(self)



    def vehicle_type(self):

        localctx = AVScenariosParser.Vehicle_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_vehicle_type)
        self._la = 0 # Token type
        try:
            self.state = 593
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Vehicle_type_Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 581
                self.match(AVScenariosParser.T__1)
                self.state = 582
                self.type_parameter()
                self.state = 583
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Vehicle_type_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 585
                self.match(AVScenariosParser.T__1)
                self.state = 586
                self.type_parameter()
                self.state = 587
                self.match(AVScenariosParser.T__13)
                self.state = 589
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__34) | (1 << AVScenariosParser.T__35) | (1 << AVScenariosParser.T__36) | (1 << AVScenariosParser.T__37) | (1 << AVScenariosParser.T__38) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)) | (1 << (AVScenariosParser.T__81 - 65)) | (1 << (AVScenariosParser.T__83 - 65)) | (1 << (AVScenariosParser.T__84 - 65)) | (1 << (AVScenariosParser.T__85 - 65)) | (1 << (AVScenariosParser.T__92 - 65)) | (1 << (AVScenariosParser.T__93 - 65)) | (1 << (AVScenariosParser.Variable_name - 65)) | (1 << (AVScenariosParser.Rgb_color - 65)))) != 0):
                    self.state = 588
                    self.color_parameter()


                self.state = 591
                self.match(AVScenariosParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_type_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Type_type_Context(Type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def type_(self):
            return self.getTypedRuleContext(AVScenariosParser.Type_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_type_" ):
                listener.enterType_type_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_type_" ):
                listener.exitType_type_(self)


    class Type_varContext(Type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_var" ):
                listener.enterType_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_var" ):
                listener.exitType_var(self)



    def type_parameter(self):

        localctx = AVScenariosParser.Type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_type_parameter)
        try:
            self.state = 597
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Type_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 595
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Type_type_Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 596
                self.type_()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_type_

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Type_generalContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_type(self):
            return self.getTypedRuleContext(AVScenariosParser.General_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_general" ):
                listener.enterType_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_general" ):
                listener.exitType_general(self)


    class Type_specificContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def specific_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Specific_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_specific" ):
                listener.enterType_specific(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_specific" ):
                listener.exitType_specific(self)



    def type_(self):

        localctx = AVScenariosParser.Type_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_type_)
        try:
            self.state = 601
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Type_specificContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 599
                self.specific_type()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Type_generalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 600
                self.general_type()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Specific_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_specific_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Specific_strContext(Specific_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Specific_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecific_str" ):
                listener.enterSpecific_str(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecific_str" ):
                listener.exitSpecific_str(self)



    def specific_type(self):

        localctx = AVScenariosParser.Specific_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_specific_type)
        try:
            localctx = AVScenariosParser.Specific_strContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 603
            self.string_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class General_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_general_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class General_motorbicycleContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_motorbicycle" ):
                listener.enterGeneral_motorbicycle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_motorbicycle" ):
                listener.exitGeneral_motorbicycle(self)


    class General_truckContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_truck" ):
                listener.enterGeneral_truck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_truck" ):
                listener.exitGeneral_truck(self)


    class General_bicycleContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_bicycle" ):
                listener.enterGeneral_bicycle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_bicycle" ):
                listener.exitGeneral_bicycle(self)


    class General_tricycleContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_tricycle" ):
                listener.enterGeneral_tricycle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_tricycle" ):
                listener.exitGeneral_tricycle(self)


    class General_carContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_car" ):
                listener.enterGeneral_car(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_car" ):
                listener.exitGeneral_car(self)


    class General_vanContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_van" ):
                listener.enterGeneral_van(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_van" ):
                listener.exitGeneral_van(self)


    class General_busContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_bus" ):
                listener.enterGeneral_bus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_bus" ):
                listener.exitGeneral_bus(self)



    def general_type(self):

        localctx = AVScenariosParser.General_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_general_type)
        try:
            self.state = 612
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__27]:
                localctx = AVScenariosParser.General_carContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 605
                self.match(AVScenariosParser.T__27)
                pass
            elif token in [AVScenariosParser.T__28]:
                localctx = AVScenariosParser.General_busContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 606
                self.match(AVScenariosParser.T__28)
                pass
            elif token in [AVScenariosParser.T__29]:
                localctx = AVScenariosParser.General_vanContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 607
                self.match(AVScenariosParser.T__29)
                pass
            elif token in [AVScenariosParser.T__30]:
                localctx = AVScenariosParser.General_truckContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 608
                self.match(AVScenariosParser.T__30)
                pass
            elif token in [AVScenariosParser.T__31]:
                localctx = AVScenariosParser.General_bicycleContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 609
                self.match(AVScenariosParser.T__31)
                pass
            elif token in [AVScenariosParser.T__32]:
                localctx = AVScenariosParser.General_motorbicycleContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 610
                self.match(AVScenariosParser.T__32)
                pass
            elif token in [AVScenariosParser.T__33]:
                localctx = AVScenariosParser.General_tricycleContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 611
                self.match(AVScenariosParser.T__33)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Color_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_color_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Color_colorContext(Color_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def color(self):
            return self.getTypedRuleContext(AVScenariosParser.ColorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_color" ):
                listener.enterColor_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_color" ):
                listener.exitColor_color(self)


    class Color_varContext(Color_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_var" ):
                listener.enterColor_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_var" ):
                listener.exitColor_var(self)



    def color_parameter(self):

        localctx = AVScenariosParser.Color_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_color_parameter)
        try:
            self.state = 616
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Color_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 614
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__34, AVScenariosParser.T__35, AVScenariosParser.T__36, AVScenariosParser.T__37, AVScenariosParser.T__38, AVScenariosParser.Rgb_color]:
                localctx = AVScenariosParser.Color_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 615
                self.color()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ColorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_color

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Color_color_listContext(ColorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ColorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def color_list(self):
            return self.getTypedRuleContext(AVScenariosParser.Color_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_color_list" ):
                listener.enterColor_color_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_color_list" ):
                listener.exitColor_color_list(self)


    class Color_rgb_colorContext(ColorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ColorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rgb_color(self):
            return self.getTypedRuleContext(AVScenariosParser.Rgb_colorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_rgb_color" ):
                listener.enterColor_rgb_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_rgb_color" ):
                listener.exitColor_rgb_color(self)



    def color(self):

        localctx = AVScenariosParser.ColorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_color)
        try:
            self.state = 620
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__34, AVScenariosParser.T__35, AVScenariosParser.T__36, AVScenariosParser.T__37, AVScenariosParser.T__38]:
                localctx = AVScenariosParser.Color_color_listContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 618
                self.color_list()
                pass
            elif token in [AVScenariosParser.Rgb_color]:
                localctx = AVScenariosParser.Color_rgb_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 619
                self.rgb_color()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Color_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_color_list

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Color_blueContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_blue" ):
                listener.enterColor_blue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_blue" ):
                listener.exitColor_blue(self)


    class Color_redContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_red" ):
                listener.enterColor_red(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_red" ):
                listener.exitColor_red(self)


    class Color_whiteContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_white" ):
                listener.enterColor_white(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_white" ):
                listener.exitColor_white(self)


    class Color_blackContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_black" ):
                listener.enterColor_black(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_black" ):
                listener.exitColor_black(self)


    class Color_greenContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_green" ):
                listener.enterColor_green(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_green" ):
                listener.exitColor_green(self)



    def color_list(self):

        localctx = AVScenariosParser.Color_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_color_list)
        try:
            self.state = 627
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__34]:
                localctx = AVScenariosParser.Color_redContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 622
                self.match(AVScenariosParser.T__34)
                pass
            elif token in [AVScenariosParser.T__35]:
                localctx = AVScenariosParser.Color_greenContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 623
                self.match(AVScenariosParser.T__35)
                pass
            elif token in [AVScenariosParser.T__36]:
                localctx = AVScenariosParser.Color_blueContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 624
                self.match(AVScenariosParser.T__36)
                pass
            elif token in [AVScenariosParser.T__37]:
                localctx = AVScenariosParser.Color_blackContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 625
                self.match(AVScenariosParser.T__37)
                pass
            elif token in [AVScenariosParser.T__38]:
                localctx = AVScenariosParser.Color_whiteContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 626
                self.match(AVScenariosParser.T__38)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rgb_colorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_rgb_color

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Rgb_rgbContext(Rgb_colorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Rgb_colorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Rgb_color(self):
            return self.getToken(AVScenariosParser.Rgb_color, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRgb_rgb" ):
                listener.enterRgb_rgb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRgb_rgb" ):
                listener.exitRgb_rgb(self)



    def rgb_color(self):

        localctx = AVScenariosParser.Rgb_colorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_rgb_color)
        try:
            localctx = AVScenariosParser.Rgb_rgbContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 629
            self.match(AVScenariosParser.Rgb_color)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Npc_vehiclesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_npc_vehicles

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NpcContext(Npc_vehiclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehiclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_npc_vehicles(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_npc_vehiclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc" ):
                listener.enterNpc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc" ):
                listener.exitNpc(self)



    def npc_vehicles(self):

        localctx = AVScenariosParser.Npc_vehiclesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_npc_vehicles)
        try:
            localctx = AVScenariosParser.NpcContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 631
            self.match(AVScenariosParser.T__8)
            self.state = 632
            self.multi_npc_vehicles(0)
            self.state = 633
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_npc_vehiclesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multi_npc_vehicles

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Multi_multi_npcContext(Multi_npc_vehiclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_npc_vehiclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_npc_vehicles(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_npc_vehiclesContext,0)

        def npc_vehicle_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicle_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_multi_npc" ):
                listener.enterMulti_multi_npc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_multi_npc" ):
                listener.exitMulti_multi_npc(self)


    class Multi_npcContext(Multi_npc_vehiclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_npc_vehiclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def npc_vehicle_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicle_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_npc" ):
                listener.enterMulti_npc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_npc" ):
                listener.exitMulti_npc(self)



    def multi_npc_vehicles(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multi_npc_vehiclesContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 86
        self.enterRecursionRule(localctx, 86, self.RULE_multi_npc_vehicles, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Multi_npcContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 636
            self.npc_vehicle_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 643
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,49,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Multi_multi_npcContext(self, AVScenariosParser.Multi_npc_vehiclesContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multi_npc_vehicles)
                    self.state = 638
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 639
                    self.match(AVScenariosParser.T__13)
                    self.state = 640
                    self.npc_vehicle_parameter() 
                self.state = 645
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Npc_vehicleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_npc_vehicle

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Npc_vehicle_parContext(Npc_vehicleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_npc(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_npcContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_vehicle_par" ):
                listener.enterNpc_vehicle_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_vehicle_par" ):
                listener.exitNpc_vehicle_par(self)



    def npc_vehicle(self):

        localctx = AVScenariosParser.Npc_vehicleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_npc_vehicle)
        try:
            localctx = AVScenariosParser.Npc_vehicle_parContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 646
            self.match(AVScenariosParser.T__39)
            self.state = 647
            self.match(AVScenariosParser.T__1)
            self.state = 648
            self.parameter_list_npc()
            self.state = 649
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Npc_vehicle_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_npc_vehicle_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Npc_npc_vehicle_varContext(Npc_vehicle_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicle_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_npc_vehicle_var" ):
                listener.enterNpc_npc_vehicle_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_npc_vehicle_var" ):
                listener.exitNpc_npc_vehicle_var(self)


    class Npc_npc_vehicleContext(Npc_vehicle_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicle_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def npc_vehicle(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_npc_vehicle" ):
                listener.enterNpc_npc_vehicle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_npc_vehicle" ):
                listener.exitNpc_npc_vehicle(self)



    def npc_vehicle_parameter(self):

        localctx = AVScenariosParser.Npc_vehicle_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_npc_vehicle_parameter)
        try:
            self.state = 653
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Npc_npc_vehicleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 651
                self.npc_vehicle()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Npc_npc_vehicle_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 652
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_npcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_npc

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_npc_state_vehicleContext(Parameter_list_npcContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_npcContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)

        def vehicle_motion_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_motion_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_npc_state_vehicle" ):
                listener.enterPar_npc_state_vehicle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_npc_state_vehicle" ):
                listener.exitPar_npc_state_vehicle(self)


    class Par_npc_stateContext(Parameter_list_npcContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_npcContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_npc_state" ):
                listener.enterPar_npc_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_npc_state" ):
                listener.exitPar_npc_state(self)


    class Par_npc_state_vehicle_stateContext(Parameter_list_npcContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_npcContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.State_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,i)

        def vehicle_motion_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_motion_parameterContext,0)

        def vehicle_type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_type_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_npc_state_vehicle_state" ):
                listener.enterPar_npc_state_vehicle_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_npc_state_vehicle_state" ):
                listener.exitPar_npc_state_vehicle_state(self)



    def parameter_list_npc(self):

        localctx = AVScenariosParser.Parameter_list_npcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_parameter_list_npc)
        self._la = 0 # Token type
        try:
            self.state = 673
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Par_npc_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 655
                self.state_parameter()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Par_npc_state_vehicleContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 656
                self.state_parameter()
                self.state = 657
                self.match(AVScenariosParser.T__13)
                self.state = 658
                self.vehicle_motion_parameter()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Par_npc_state_vehicle_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 660
                self.state_parameter()
                self.state = 661
                self.match(AVScenariosParser.T__13)
                self.state = 663
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)) | (1 << (AVScenariosParser.T__81 - 65)) | (1 << (AVScenariosParser.T__83 - 65)) | (1 << (AVScenariosParser.T__84 - 65)) | (1 << (AVScenariosParser.T__85 - 65)) | (1 << (AVScenariosParser.T__92 - 65)) | (1 << (AVScenariosParser.T__93 - 65)) | (1 << (AVScenariosParser.Variable_name - 65)))) != 0):
                    self.state = 662
                    self.vehicle_motion_parameter()


                self.state = 665
                self.match(AVScenariosParser.T__13)
                self.state = 667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__1) | (1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)) | (1 << (AVScenariosParser.T__81 - 65)) | (1 << (AVScenariosParser.T__83 - 65)) | (1 << (AVScenariosParser.T__84 - 65)) | (1 << (AVScenariosParser.T__85 - 65)) | (1 << (AVScenariosParser.T__92 - 65)) | (1 << (AVScenariosParser.T__93 - 65)) | (1 << (AVScenariosParser.Variable_name - 65)))) != 0):
                    self.state = 666
                    self.state_parameter()


                self.state = 671
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 669
                    self.match(AVScenariosParser.T__13)
                    self.state = 670
                    self.vehicle_type_parameter()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vehicle_motion_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_vehicle_motion_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Vehicle_vehicle_motionContext(Vehicle_motion_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_motion_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def vehicle_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_vehicle_motion" ):
                listener.enterVehicle_vehicle_motion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_vehicle_motion" ):
                listener.exitVehicle_vehicle_motion(self)


    class Vehicle_vehicle_motion_varContext(Vehicle_motion_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_motion_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_vehicle_motion_var" ):
                listener.enterVehicle_vehicle_motion_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_vehicle_motion_var" ):
                listener.exitVehicle_vehicle_motion_var(self)



    def vehicle_motion_parameter(self):

        localctx = AVScenariosParser.Vehicle_motion_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_vehicle_motion_parameter)
        try:
            self.state = 677
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Vehicle_vehicle_motionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 675
                self.vehicle_motion()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Vehicle_vehicle_motion_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 676
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vehicle_motionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_vehicle_motion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Vehicle_motion_uniformContext(Vehicle_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def uniform_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Uniform_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_motion_uniform" ):
                listener.enterVehicle_motion_uniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_motion_uniform" ):
                listener.exitVehicle_motion_uniform(self)


    class Vehicle_motion_waypointContext(Vehicle_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def waypoint_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Waypoint_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_motion_waypoint" ):
                listener.enterVehicle_motion_waypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_motion_waypoint" ):
                listener.exitVehicle_motion_waypoint(self)



    def vehicle_motion(self):

        localctx = AVScenariosParser.Vehicle_motionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_vehicle_motion)
        try:
            self.state = 681
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__40, AVScenariosParser.T__41]:
                localctx = AVScenariosParser.Vehicle_motion_uniformContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 679
                self.uniform_motion()
                pass
            elif token in [AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47]:
                localctx = AVScenariosParser.Vehicle_motion_waypointContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 680
                self.waypoint_motion()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Uniform_motionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_uniform_motion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UniformContext(Uniform_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Uniform_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def uniform_index(self):
            return self.getTypedRuleContext(AVScenariosParser.Uniform_indexContext,0)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniform" ):
                listener.enterUniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniform" ):
                listener.exitUniform(self)



    def uniform_motion(self):

        localctx = AVScenariosParser.Uniform_motionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_uniform_motion)
        try:
            localctx = AVScenariosParser.UniformContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 683
            self.uniform_index()
            self.state = 684
            self.match(AVScenariosParser.T__1)
            self.state = 685
            self.state_parameter()
            self.state = 686
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Uniform_indexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_uniform_index

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Uniform_UniformContext(Uniform_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Uniform_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniform_Uniform" ):
                listener.enterUniform_Uniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniform_Uniform" ):
                listener.exitUniform_Uniform(self)


    class Uniform_uniformContext(Uniform_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Uniform_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniform_uniform" ):
                listener.enterUniform_uniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniform_uniform" ):
                listener.exitUniform_uniform(self)



    def uniform_index(self):

        localctx = AVScenariosParser.Uniform_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_uniform_index)
        try:
            self.state = 690
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__40]:
                localctx = AVScenariosParser.Uniform_uniformContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 688
                self.match(AVScenariosParser.T__40)
                pass
            elif token in [AVScenariosParser.T__41]:
                localctx = AVScenariosParser.Uniform_UniformContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 689
                self.match(AVScenariosParser.T__41)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Waypoint_motionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_waypoint_motion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class WaypointContext(Waypoint_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def waypoint_index(self):
            return self.getTypedRuleContext(AVScenariosParser.Waypoint_indexContext,0)

        def state_list_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_list_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint" ):
                listener.enterWaypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint" ):
                listener.exitWaypoint(self)



    def waypoint_motion(self):

        localctx = AVScenariosParser.Waypoint_motionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_waypoint_motion)
        try:
            localctx = AVScenariosParser.WaypointContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 692
            self.waypoint_index()
            self.state = 693
            self.match(AVScenariosParser.T__1)
            self.state = 694
            self.state_list_parameter()
            self.state = 695
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_list_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_state_list_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class State_state_listContext(State_list_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_list_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_list(self):
            return self.getTypedRuleContext(AVScenariosParser.State_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_state_list" ):
                listener.enterState_state_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_state_list" ):
                listener.exitState_state_list(self)


    class State_state_list_varContext(State_list_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_list_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_state_list_var" ):
                listener.enterState_state_list_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_state_list_var" ):
                listener.exitState_state_list_var(self)



    def state_list_parameter(self):

        localctx = AVScenariosParser.State_list_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_state_list_parameter)
        try:
            self.state = 699
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.State_state_list_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 697
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.State_state_listContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 698
                self.state_list()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_state_list

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class State_list_multiContext(State_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_listContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_states(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_statesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_list_multi" ):
                listener.enterState_list_multi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_list_multi" ):
                listener.exitState_list_multi(self)



    def state_list(self):

        localctx = AVScenariosParser.State_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_state_list)
        try:
            localctx = AVScenariosParser.State_list_multiContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 701
            self.match(AVScenariosParser.T__1)
            self.state = 702
            self.multi_states(0)
            self.state = 703
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_statesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multi_states

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Multi_states_parContext(Multi_statesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_statesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_states_par" ):
                listener.enterMulti_states_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_states_par" ):
                listener.exitMulti_states_par(self)


    class Multi_states_par_stateContext(Multi_statesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_statesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_states(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_statesContext,0)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_states_par_state" ):
                listener.enterMulti_states_par_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_states_par_state" ):
                listener.exitMulti_states_par_state(self)



    def multi_states(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multi_statesContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 108
        self.enterRecursionRule(localctx, 108, self.RULE_multi_states, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Multi_states_parContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 706
            self.state_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 713
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,59,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Multi_states_par_stateContext(self, AVScenariosParser.Multi_statesContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multi_states)
                    self.state = 708
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 709
                    self.match(AVScenariosParser.T__13)
                    self.state = 710
                    self.state_parameter() 
                self.state = 715
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,59,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Waypoint_indexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_waypoint_index

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Waypoint_WPContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_WP" ):
                listener.enterWaypoint_WP(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_WP" ):
                listener.exitWaypoint_WP(self)


    class Waypoint_wpContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_wp" ):
                listener.enterWaypoint_wp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_wp" ):
                listener.exitWaypoint_wp(self)


    class Waypoint_WContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_W" ):
                listener.enterWaypoint_W(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_W" ):
                listener.exitWaypoint_W(self)


    class Waypoint_wContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_w" ):
                listener.enterWaypoint_w(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_w" ):
                listener.exitWaypoint_w(self)


    class Waypoint_waypointContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_waypoint" ):
                listener.enterWaypoint_waypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_waypoint" ):
                listener.exitWaypoint_waypoint(self)


    class Waypoint_WaypointContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_Waypoint" ):
                listener.enterWaypoint_Waypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_Waypoint" ):
                listener.exitWaypoint_Waypoint(self)



    def waypoint_index(self):

        localctx = AVScenariosParser.Waypoint_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_waypoint_index)
        try:
            self.state = 722
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__42]:
                localctx = AVScenariosParser.Waypoint_WaypointContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 716
                self.match(AVScenariosParser.T__42)
                pass
            elif token in [AVScenariosParser.T__43]:
                localctx = AVScenariosParser.Waypoint_WContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 717
                self.match(AVScenariosParser.T__43)
                pass
            elif token in [AVScenariosParser.T__44]:
                localctx = AVScenariosParser.Waypoint_WPContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 718
                self.match(AVScenariosParser.T__44)
                pass
            elif token in [AVScenariosParser.T__45]:
                localctx = AVScenariosParser.Waypoint_waypointContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 719
                self.match(AVScenariosParser.T__45)
                pass
            elif token in [AVScenariosParser.T__46]:
                localctx = AVScenariosParser.Waypoint_wContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 720
                self.match(AVScenariosParser.T__46)
                pass
            elif token in [AVScenariosParser.T__47]:
                localctx = AVScenariosParser.Waypoint_wpContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 721
                self.match(AVScenariosParser.T__47)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PedestriansContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrians

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrians_multiContext(PedestriansContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PedestriansContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiple_pedestrians(self):
            return self.getTypedRuleContext(AVScenariosParser.Multiple_pedestriansContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrians_multi" ):
                listener.enterPedestrians_multi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrians_multi" ):
                listener.exitPedestrians_multi(self)



    def pedestrians(self):

        localctx = AVScenariosParser.PedestriansContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_pedestrians)
        try:
            localctx = AVScenariosParser.Pedestrians_multiContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 724
            self.match(AVScenariosParser.T__8)
            self.state = 725
            self.multiple_pedestrians(0)
            self.state = 726
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multiple_pedestriansContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multiple_pedestrians

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Multi_multi_pedestrianContext(Multiple_pedestriansContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multiple_pedestriansContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiple_pedestrians(self):
            return self.getTypedRuleContext(AVScenariosParser.Multiple_pedestriansContext,0)

        def pedestrian_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_multi_pedestrian" ):
                listener.enterMulti_multi_pedestrian(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_multi_pedestrian" ):
                listener.exitMulti_multi_pedestrian(self)


    class Multi_pedestrianContext(Multiple_pedestriansContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multiple_pedestriansContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrian_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_pedestrian" ):
                listener.enterMulti_pedestrian(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_pedestrian" ):
                listener.exitMulti_pedestrian(self)



    def multiple_pedestrians(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multiple_pedestriansContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 114
        self.enterRecursionRule(localctx, 114, self.RULE_multiple_pedestrians, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Multi_pedestrianContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 729
            self.pedestrian_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 736
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,61,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Multi_multi_pedestrianContext(self, AVScenariosParser.Multiple_pedestriansContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multiple_pedestrians)
                    self.state = 731
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 732
                    self.match(AVScenariosParser.T__13)
                    self.state = 733
                    self.pedestrian_parameter() 
                self.state = 738
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,61,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Pedestrian_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_pedestrian_varContext(Pedestrian_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_pedestrian_var" ):
                listener.enterPedestrian_pedestrian_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_pedestrian_var" ):
                listener.exitPedestrian_pedestrian_var(self)


    class Pedestrian_pedestrianContext(Pedestrian_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrian(self):
            return self.getTypedRuleContext(AVScenariosParser.PedestrianContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_pedestrian" ):
                listener.enterPedestrian_pedestrian(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_pedestrian" ):
                listener.exitPedestrian_pedestrian(self)



    def pedestrian_parameter(self):

        localctx = AVScenariosParser.Pedestrian_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_pedestrian_parameter)
        try:
            self.state = 741
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pedestrian_pedestrianContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 739
                self.pedestrian()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pedestrian_pedestrian_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 740
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PedestrianContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_parContext(PedestrianContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PedestrianContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_ped(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_pedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_par" ):
                listener.enterPedestrian_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_par" ):
                listener.exitPedestrian_par(self)



    def pedestrian(self):

        localctx = AVScenariosParser.PedestrianContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_pedestrian)
        try:
            localctx = AVScenariosParser.Pedestrian_parContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 743
            self.match(AVScenariosParser.T__48)
            self.state = 744
            self.match(AVScenariosParser.T__1)
            self.state = 745
            self.parameter_list_ped()
            self.state = 746
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_pedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_ped

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_ped_state_ped_stateContext(Parameter_list_pedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_pedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.State_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,i)

        def pedestrian_motion_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_motion_parameterContext,0)

        def pedestrian_type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_type_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_ped_state_ped_state" ):
                listener.enterPar_ped_state_ped_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_ped_state_ped_state" ):
                listener.exitPar_ped_state_ped_state(self)


    class Par_ped_state_pedContext(Parameter_list_pedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_pedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)

        def pedestrian_motion_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_motion_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_ped_state_ped" ):
                listener.enterPar_ped_state_ped(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_ped_state_ped" ):
                listener.exitPar_ped_state_ped(self)


    class Par_ped_stateContext(Parameter_list_pedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_pedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_ped_state" ):
                listener.enterPar_ped_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_ped_state" ):
                listener.exitPar_ped_state(self)



    def parameter_list_ped(self):

        localctx = AVScenariosParser.Parameter_list_pedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_parameter_list_ped)
        self._la = 0 # Token type
        try:
            self.state = 766
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Par_ped_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 748
                self.state_parameter()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Par_ped_state_pedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 749
                self.state_parameter()
                self.state = 750
                self.match(AVScenariosParser.T__13)
                self.state = 751
                self.pedestrian_motion_parameter()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Par_ped_state_ped_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 753
                self.state_parameter()
                self.state = 754
                self.match(AVScenariosParser.T__13)
                self.state = 756
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)) | (1 << (AVScenariosParser.T__81 - 65)) | (1 << (AVScenariosParser.T__83 - 65)) | (1 << (AVScenariosParser.T__84 - 65)) | (1 << (AVScenariosParser.T__85 - 65)) | (1 << (AVScenariosParser.T__92 - 65)) | (1 << (AVScenariosParser.T__93 - 65)) | (1 << (AVScenariosParser.Variable_name - 65)))) != 0):
                    self.state = 755
                    self.pedestrian_motion_parameter()


                self.state = 758
                self.match(AVScenariosParser.T__13)
                self.state = 760
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__1) | (1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)) | (1 << (AVScenariosParser.T__81 - 65)) | (1 << (AVScenariosParser.T__83 - 65)) | (1 << (AVScenariosParser.T__84 - 65)) | (1 << (AVScenariosParser.T__85 - 65)) | (1 << (AVScenariosParser.T__92 - 65)) | (1 << (AVScenariosParser.T__93 - 65)) | (1 << (AVScenariosParser.Variable_name - 65)))) != 0):
                    self.state = 759
                    self.state_parameter()


                self.state = 764
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 762
                    self.match(AVScenariosParser.T__13)
                    self.state = 763
                    self.pedestrian_type_parameter()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrian_motion_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_motion_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_motion_pedestrian_varContext(Pedestrian_motion_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_motion_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_motion_pedestrian_var" ):
                listener.enterPedestrian_motion_pedestrian_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_motion_pedestrian_var" ):
                listener.exitPedestrian_motion_pedestrian_var(self)


    class Pedestrian_motion_pedestrianContext(Pedestrian_motion_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_motion_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrian_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_motion_pedestrian" ):
                listener.enterPedestrian_motion_pedestrian(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_motion_pedestrian" ):
                listener.exitPedestrian_motion_pedestrian(self)



    def pedestrian_motion_parameter(self):

        localctx = AVScenariosParser.Pedestrian_motion_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_pedestrian_motion_parameter)
        try:
            self.state = 770
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pedestrian_motion_pedestrianContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 768
                self.pedestrian_motion()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pedestrian_motion_pedestrian_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 769
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrian_motionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_motion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_waypointContext(Pedestrian_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def waypoint_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Waypoint_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_waypoint" ):
                listener.enterPedestrian_waypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_waypoint" ):
                listener.exitPedestrian_waypoint(self)


    class Pedestrian_uniformContext(Pedestrian_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def uniform_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Uniform_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_uniform" ):
                listener.enterPedestrian_uniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_uniform" ):
                listener.exitPedestrian_uniform(self)



    def pedestrian_motion(self):

        localctx = AVScenariosParser.Pedestrian_motionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_pedestrian_motion)
        try:
            self.state = 774
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__40, AVScenariosParser.T__41]:
                localctx = AVScenariosParser.Pedestrian_uniformContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 772
                self.uniform_motion()
                pass
            elif token in [AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47]:
                localctx = AVScenariosParser.Pedestrian_waypointContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 773
                self.waypoint_motion()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrian_type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_type_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_pedestrian_typeContext(Pedestrian_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrian_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_pedestrian_type" ):
                listener.enterPedestrian_pedestrian_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_pedestrian_type" ):
                listener.exitPedestrian_pedestrian_type(self)


    class Pedestrian_pedestrian_type_varContext(Pedestrian_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_pedestrian_type_var" ):
                listener.enterPedestrian_pedestrian_type_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_pedestrian_type_var" ):
                listener.exitPedestrian_pedestrian_type_var(self)


    class Pedestrian_type_nameContext(Pedestrian_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def String(self):
            return self.getToken(AVScenariosParser.String, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_type_name" ):
                listener.enterPedestrian_type_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_type_name" ):
                listener.exitPedestrian_type_name(self)



    def pedestrian_type_parameter(self):

        localctx = AVScenariosParser.Pedestrian_type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_pedestrian_type_parameter)
        try:
            self.state = 779
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Pedestrian_pedestrian_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 776
                self.pedestrian_type()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Pedestrian_pedestrian_type_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 777
                self.identifier()
                pass
            elif token in [AVScenariosParser.String]:
                localctx = AVScenariosParser.Pedestrian_type_nameContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 778
                self.match(AVScenariosParser.String)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrian_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_type_height_colorContext(Pedestrian_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def height_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Height_parameterContext,0)

        def color_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Color_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_type_height_color" ):
                listener.enterPedestrian_type_height_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_type_height_color" ):
                listener.exitPedestrian_type_height_color(self)



    def pedestrian_type(self):

        localctx = AVScenariosParser.Pedestrian_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_pedestrian_type)
        try:
            localctx = AVScenariosParser.Pedestrian_type_height_colorContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 781
            self.match(AVScenariosParser.T__1)
            self.state = 782
            self.height_parameter()
            self.state = 783
            self.match(AVScenariosParser.T__13)
            self.state = 784
            self.color_parameter()
            self.state = 785
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Height_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_height_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Height_varContext(Height_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Height_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeight_var" ):
                listener.enterHeight_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeight_var" ):
                listener.exitHeight_var(self)


    class Height_heightContext(Height_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Height_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def height(self):
            return self.getTypedRuleContext(AVScenariosParser.HeightContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeight_height" ):
                listener.enterHeight_height(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeight_height" ):
                listener.exitHeight_height(self)



    def height_parameter(self):

        localctx = AVScenariosParser.Height_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_height_parameter)
        try:
            self.state = 789
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Height_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 787
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Height_heightContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 788
                self.height()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HeightContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_height

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Height_rvContext(HeightContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeightContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeight_rv" ):
                listener.enterHeight_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeight_rv" ):
                listener.exitHeight_rv(self)



    def height(self):

        localctx = AVScenariosParser.HeightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_height)
        try:
            localctx = AVScenariosParser.Height_rvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 791
            self.real_value_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ObstaclesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_obstacles

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Obstacles_multiContext(ObstaclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ObstaclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiple_obstacles(self):
            return self.getTypedRuleContext(AVScenariosParser.Multiple_obstaclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_multi" ):
                listener.enterObstacles_multi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_multi" ):
                listener.exitObstacles_multi(self)



    def obstacles(self):

        localctx = AVScenariosParser.ObstaclesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_obstacles)
        try:
            localctx = AVScenariosParser.Obstacles_multiContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 793
            self.match(AVScenariosParser.T__8)
            self.state = 794
            self.multiple_obstacles(0)
            self.state = 795
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multiple_obstaclesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multiple_obstacles

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Obstacles_obstacleContext(Multiple_obstaclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multiple_obstaclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def obstacle_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Obstacle_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_obstacle" ):
                listener.enterObstacles_obstacle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_obstacle" ):
                listener.exitObstacles_obstacle(self)


    class Obstacles_multi_obstacleContext(Multiple_obstaclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multiple_obstaclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiple_obstacles(self):
            return self.getTypedRuleContext(AVScenariosParser.Multiple_obstaclesContext,0)

        def obstacle_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Obstacle_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_multi_obstacle" ):
                listener.enterObstacles_multi_obstacle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_multi_obstacle" ):
                listener.exitObstacles_multi_obstacle(self)



    def multiple_obstacles(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multiple_obstaclesContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 136
        self.enterRecursionRule(localctx, 136, self.RULE_multiple_obstacles, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Obstacles_obstacleContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 798
            self.obstacle_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 805
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,71,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Obstacles_multi_obstacleContext(self, AVScenariosParser.Multiple_obstaclesContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multiple_obstacles)
                    self.state = 800
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 801
                    self.match(AVScenariosParser.T__13)
                    self.state = 802
                    self.obstacle_parameter() 
                self.state = 807
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,71,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Obstacle_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_obstacle_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Obstacle_obstacle_varContext(Obstacle_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacle_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacle_obstacle_var" ):
                listener.enterObstacle_obstacle_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacle_obstacle_var" ):
                listener.exitObstacle_obstacle_var(self)


    class Obstacle_obstacleContext(Obstacle_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacle_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def obstacle(self):
            return self.getTypedRuleContext(AVScenariosParser.ObstacleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacle_obstacle" ):
                listener.enterObstacle_obstacle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacle_obstacle" ):
                listener.exitObstacle_obstacle(self)



    def obstacle_parameter(self):

        localctx = AVScenariosParser.Obstacle_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_obstacle_parameter)
        try:
            self.state = 810
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Obstacle_obstacleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 808
                self.obstacle()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Obstacle_obstacle_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 809
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ObstacleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_obstacle

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Obstacle_paraContext(ObstacleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ObstacleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_obs(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_obsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacle_para" ):
                listener.enterObstacle_para(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacle_para" ):
                listener.exitObstacle_para(self)



    def obstacle(self):

        localctx = AVScenariosParser.ObstacleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_obstacle)
        try:
            localctx = AVScenariosParser.Obstacle_paraContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 812
            self.match(AVScenariosParser.T__49)
            self.state = 813
            self.match(AVScenariosParser.T__1)
            self.state = 814
            self.parameter_list_obs()
            self.state = 815
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_obsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_obs

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_position_shapeContext(Parameter_list_obsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_obsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def position_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Position_parameterContext,0)

        def shape_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Shape_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_position_shape" ):
                listener.enterPar_position_shape(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_position_shape" ):
                listener.exitPar_position_shape(self)



    def parameter_list_obs(self):

        localctx = AVScenariosParser.Parameter_list_obsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_parameter_list_obs)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.Par_position_shapeContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 817
            self.position_parameter()
            self.state = 820
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AVScenariosParser.T__13:
                self.state = 818
                self.match(AVScenariosParser.T__13)
                self.state = 819
                self.shape_parameter()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shape_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_shape_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Shape_shape_varContext(Shape_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Shape_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_shape_var" ):
                listener.enterShape_shape_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_shape_var" ):
                listener.exitShape_shape_var(self)


    class Shape_shapeContext(Shape_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Shape_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def shape(self):
            return self.getTypedRuleContext(AVScenariosParser.ShapeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_shape" ):
                listener.enterShape_shape(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_shape" ):
                listener.exitShape_shape(self)



    def shape_parameter(self):

        localctx = AVScenariosParser.Shape_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_shape_parameter)
        try:
            self.state = 824
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Shape_shape_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 822
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Shape_shapeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 823
                self.shape()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ShapeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_shape

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Shape_cylinderContext(ShapeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ShapeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cylinder(self):
            return self.getTypedRuleContext(AVScenariosParser.CylinderContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_cylinder" ):
                listener.enterShape_cylinder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_cylinder" ):
                listener.exitShape_cylinder(self)


    class Shape_sphereContext(ShapeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ShapeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def sphere(self):
            return self.getTypedRuleContext(AVScenariosParser.SphereContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_sphere" ):
                listener.enterShape_sphere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_sphere" ):
                listener.exitShape_sphere(self)


    class Shape_boxContext(ShapeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ShapeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def box(self):
            return self.getTypedRuleContext(AVScenariosParser.BoxContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_box" ):
                listener.enterShape_box(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_box" ):
                listener.exitShape_box(self)


    class Shape_coneContext(ShapeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ShapeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cone(self):
            return self.getTypedRuleContext(AVScenariosParser.ConeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_cone" ):
                listener.enterShape_cone(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_cone" ):
                listener.exitShape_cone(self)



    def shape(self):

        localctx = AVScenariosParser.ShapeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_shape)
        try:
            self.state = 830
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Shape_sphereContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 826
                self.sphere()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Shape_boxContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 827
                self.box()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Shape_coneContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 828
                self.cone()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Shape_cylinderContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 829
                self.cylinder()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SphereContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_sphere

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Sphere_sphereContext(SphereContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.SphereContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSphere_sphere" ):
                listener.enterSphere_sphere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSphere_sphere" ):
                listener.exitSphere_sphere(self)



    def sphere(self):

        localctx = AVScenariosParser.SphereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_sphere)
        try:
            localctx = AVScenariosParser.Sphere_sphereContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 832
            self.match(AVScenariosParser.T__1)
            self.state = 833
            self.match(AVScenariosParser.T__50)
            self.state = 834
            self.match(AVScenariosParser.T__13)
            self.state = 835
            self.real_value_expression(0)
            self.state = 836
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_box

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Box_boxContext(BoxContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.BoxContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBox_box" ):
                listener.enterBox_box(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBox_box" ):
                listener.exitBox_box(self)



    def box(self):

        localctx = AVScenariosParser.BoxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_box)
        try:
            localctx = AVScenariosParser.Box_boxContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 838
            self.match(AVScenariosParser.T__1)
            self.state = 839
            self.match(AVScenariosParser.T__51)
            self.state = 840
            self.match(AVScenariosParser.T__13)
            self.state = 841
            self.real_value_expression(0)
            self.state = 842
            self.match(AVScenariosParser.T__13)
            self.state = 843
            self.real_value_expression(0)
            self.state = 844
            self.match(AVScenariosParser.T__13)
            self.state = 845
            self.real_value_expression(0)
            self.state = 846
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_cone

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Cone_coneContext(ConeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ConeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCone_cone" ):
                listener.enterCone_cone(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCone_cone" ):
                listener.exitCone_cone(self)



    def cone(self):

        localctx = AVScenariosParser.ConeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_cone)
        try:
            localctx = AVScenariosParser.Cone_coneContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 848
            self.match(AVScenariosParser.T__1)
            self.state = 849
            self.match(AVScenariosParser.T__52)
            self.state = 850
            self.match(AVScenariosParser.T__13)
            self.state = 851
            self.real_value_expression(0)
            self.state = 852
            self.match(AVScenariosParser.T__13)
            self.state = 853
            self.real_value_expression(0)
            self.state = 854
            self.match(AVScenariosParser.T__13)
            self.state = 855
            self.real_value_expression(0)
            self.state = 856
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CylinderContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_cylinder

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Cylinder_cylinderContext(CylinderContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.CylinderContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCylinder_cylinder" ):
                listener.enterCylinder_cylinder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCylinder_cylinder" ):
                listener.exitCylinder_cylinder(self)



    def cylinder(self):

        localctx = AVScenariosParser.CylinderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_cylinder)
        try:
            localctx = AVScenariosParser.Cylinder_cylinderContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 858
            self.match(AVScenariosParser.T__1)
            self.state = 859
            self.match(AVScenariosParser.T__53)
            self.state = 860
            self.match(AVScenariosParser.T__13)
            self.state = 861
            self.real_value_expression(0)
            self.state = 862
            self.match(AVScenariosParser.T__13)
            self.state = 863
            self.real_value_expression(0)
            self.state = 864
            self.match(AVScenariosParser.T__13)
            self.state = 865
            self.real_value_expression(0)
            self.state = 866
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Env_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_env_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Env_varContext(Env_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Env_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnv_var" ):
                listener.enterEnv_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnv_var" ):
                listener.exitEnv_var(self)


    class Env_emptyContext(Env_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Env_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnv_empty" ):
                listener.enterEnv_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnv_empty" ):
                listener.exitEnv_empty(self)


    class Env_envContext(Env_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Env_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def env(self):
            return self.getTypedRuleContext(AVScenariosParser.EnvContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnv_env" ):
                listener.enterEnv_env(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnv_env" ):
                listener.exitEnv_env(self)



    def env_parameter(self):

        localctx = AVScenariosParser.Env_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_env_parameter)
        try:
            self.state = 872
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Env_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 868
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Env_envContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 869
                self.env()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Env_emptyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 870
                self.match(AVScenariosParser.T__8)
                self.state = 871
                self.match(AVScenariosParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_env

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Env_parContext(EnvContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.EnvContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_env(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_envContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnv_par" ):
                listener.enterEnv_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnv_par" ):
                listener.exitEnv_par(self)



    def env(self):

        localctx = AVScenariosParser.EnvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_env)
        try:
            localctx = AVScenariosParser.Env_parContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 874
            self.match(AVScenariosParser.T__54)
            self.state = 875
            self.match(AVScenariosParser.T__1)
            self.state = 876
            self.parameter_list_env()
            self.state = 877
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_envContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_env

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_time_weatherContext(Parameter_list_envContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_envContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def time_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Time_parameterContext,0)

        def weather_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_time_weather" ):
                listener.enterPar_time_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_time_weather" ):
                listener.exitPar_time_weather(self)



    def parameter_list_env(self):

        localctx = AVScenariosParser.Parameter_list_envContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_parameter_list_env)
        try:
            localctx = AVScenariosParser.Par_time_weatherContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 879
            self.time_parameter()
            self.state = 880
            self.match(AVScenariosParser.T__13)
            self.state = 881
            self.weather_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_varContext(Weather_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_var" ):
                listener.enterWeather_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_var" ):
                listener.exitWeather_var(self)


    class Weather_wtrContext(Weather_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def weather(self):
            return self.getTypedRuleContext(AVScenariosParser.WeatherContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_wtr" ):
                listener.enterWeather_wtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_wtr" ):
                listener.exitWeather_wtr(self)



    def weather_parameter(self):

        localctx = AVScenariosParser.Weather_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_weather_parameter)
        try:
            self.state = 885
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Weather_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 883
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__8]:
                localctx = AVScenariosParser.Weather_wtrContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 884
                self.weather()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Time_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_time_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Time_timeContext(Time_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Time_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def time(self):
            return self.getTypedRuleContext(AVScenariosParser.TimeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_time" ):
                listener.enterTime_time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_time" ):
                listener.exitTime_time(self)


    class Time_time_varContext(Time_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Time_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_time_var" ):
                listener.enterTime_time_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_time_var" ):
                listener.exitTime_time_var(self)



    def time_parameter(self):

        localctx = AVScenariosParser.Time_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_time_parameter)
        try:
            self.state = 889
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.Time]:
                localctx = AVScenariosParser.Time_timeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 887
                self.time()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Time_time_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 888
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_time

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Time_TimeContext(TimeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.TimeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Time(self):
            return self.getToken(AVScenariosParser.Time, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_Time" ):
                listener.enterTime_Time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_Time" ):
                listener.exitTime_Time(self)



    def time(self):

        localctx = AVScenariosParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_time)
        try:
            localctx = AVScenariosParser.Time_TimeContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 891
            self.match(AVScenariosParser.Time)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WeatherContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class WeathersContext(WeatherContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.WeatherContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_weathers(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_weathersContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeathers" ):
                listener.enterWeathers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeathers" ):
                listener.exitWeathers(self)



    def weather(self):

        localctx = AVScenariosParser.WeatherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_weather)
        try:
            localctx = AVScenariosParser.WeathersContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 893
            self.match(AVScenariosParser.T__8)
            self.state = 894
            self.multi_weathers(0)
            self.state = 895
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_weathersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multi_weathers

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Weathers_multi_weatherContext(Multi_weathersContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_weathersContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_weathers(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_weathersContext,0)

        def weather_statement_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_statement_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeathers_multi_weather" ):
                listener.enterWeathers_multi_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeathers_multi_weather" ):
                listener.exitWeathers_multi_weather(self)


    class Weathers_weatherContext(Multi_weathersContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_weathersContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def weather_statement_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_statement_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeathers_weather" ):
                listener.enterWeathers_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeathers_weather" ):
                listener.exitWeathers_weather(self)



    def multi_weathers(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multi_weathersContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 170
        self.enterRecursionRule(localctx, 170, self.RULE_multi_weathers, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Weathers_weatherContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 898
            self.weather_statement_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 905
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,79,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Weathers_multi_weatherContext(self, AVScenariosParser.Multi_weathersContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multi_weathers)
                    self.state = 900
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 901
                    self.match(AVScenariosParser.T__13)
                    self.state = 902
                    self.weather_statement_parameter() 
                self.state = 907
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,79,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Weather_statement_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_statement_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_weatherContext(Weather_statement_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_statement_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def weather_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_weather" ):
                listener.enterWeather_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_weather" ):
                listener.exitWeather_weather(self)


    class Weather_weather_varContext(Weather_statement_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_statement_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_weather_var" ):
                listener.enterWeather_weather_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_weather_var" ):
                listener.exitWeather_weather_var(self)



    def weather_statement_parameter(self):

        localctx = AVScenariosParser.Weather_statement_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_weather_statement_parameter)
        try:
            self.state = 910
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Weather_weather_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 908
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__56, AVScenariosParser.T__57, AVScenariosParser.T__58, AVScenariosParser.T__59, AVScenariosParser.T__60]:
                localctx = AVScenariosParser.Weather_weatherContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 909
                self.weather_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_discreteContext(Weather_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def kind(self):
            return self.getTypedRuleContext(AVScenariosParser.KindContext,0)

        def weather_discrete_level_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_discrete_level_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete" ):
                listener.enterWeather_discrete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete" ):
                listener.exitWeather_discrete(self)


    class Weather_continuousContext(Weather_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def kind(self):
            return self.getTypedRuleContext(AVScenariosParser.KindContext,0)

        def weather_continuous_index_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_continuous_index_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_continuous" ):
                listener.enterWeather_continuous(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_continuous" ):
                listener.exitWeather_continuous(self)



    def weather_statement(self):

        localctx = AVScenariosParser.Weather_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_weather_statement)
        try:
            self.state = 920
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Weather_continuousContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 912
                self.kind()
                self.state = 913
                self.match(AVScenariosParser.T__55)
                self.state = 914
                self.weather_continuous_index_parameter()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Weather_discreteContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 916
                self.kind()
                self.state = 917
                self.match(AVScenariosParser.T__55)
                self.state = 918
                self.weather_discrete_level_parameter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KindContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_kind

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Kind_sunnyContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_sunny" ):
                listener.enterKind_sunny(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_sunny" ):
                listener.exitKind_sunny(self)


    class Kind_snowContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_snow" ):
                listener.enterKind_snow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_snow" ):
                listener.exitKind_snow(self)


    class Kind_rainContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_rain" ):
                listener.enterKind_rain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_rain" ):
                listener.exitKind_rain(self)


    class Kind_fogContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_fog" ):
                listener.enterKind_fog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_fog" ):
                listener.exitKind_fog(self)


    class Kind_wetnessContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_wetness" ):
                listener.enterKind_wetness(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_wetness" ):
                listener.exitKind_wetness(self)



    def kind(self):

        localctx = AVScenariosParser.KindContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_kind)
        try:
            self.state = 927
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__56]:
                localctx = AVScenariosParser.Kind_sunnyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 922
                self.match(AVScenariosParser.T__56)
                pass
            elif token in [AVScenariosParser.T__57]:
                localctx = AVScenariosParser.Kind_rainContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 923
                self.match(AVScenariosParser.T__57)
                pass
            elif token in [AVScenariosParser.T__58]:
                localctx = AVScenariosParser.Kind_snowContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 924
                self.match(AVScenariosParser.T__58)
                pass
            elif token in [AVScenariosParser.T__59]:
                localctx = AVScenariosParser.Kind_fogContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 925
                self.match(AVScenariosParser.T__59)
                pass
            elif token in [AVScenariosParser.T__60]:
                localctx = AVScenariosParser.Kind_wetnessContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 926
                self.match(AVScenariosParser.T__60)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_continuous_index_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_continuous_index_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_continuous_varContext(Weather_continuous_index_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_continuous_index_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_continuous_var" ):
                listener.enterWeather_continuous_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_continuous_var" ):
                listener.exitWeather_continuous_var(self)


    class Weather_continuous_valueContext(Weather_continuous_index_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_continuous_index_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def float_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Float_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_continuous_value" ):
                listener.enterWeather_continuous_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_continuous_value" ):
                listener.exitWeather_continuous_value(self)



    def weather_continuous_index_parameter(self):

        localctx = AVScenariosParser.Weather_continuous_index_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_weather_continuous_index_parameter)
        try:
            self.state = 931
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.Non_negative_value]:
                localctx = AVScenariosParser.Weather_continuous_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 929
                self.float_value()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Weather_continuous_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 930
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_discrete_level_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_discrete_level_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_discrete_varContext(Weather_discrete_level_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_level_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_var" ):
                listener.enterWeather_discrete_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_var" ):
                listener.exitWeather_discrete_var(self)


    class Weather_discrete_level_parContext(Weather_discrete_level_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_level_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def weather_discrete_level(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_discrete_levelContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_level_par" ):
                listener.enterWeather_discrete_level_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_level_par" ):
                listener.exitWeather_discrete_level_par(self)



    def weather_discrete_level_parameter(self):

        localctx = AVScenariosParser.Weather_discrete_level_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_weather_discrete_level_parameter)
        try:
            self.state = 935
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__61, AVScenariosParser.T__62, AVScenariosParser.T__63]:
                localctx = AVScenariosParser.Weather_discrete_level_parContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 933
                self.weather_discrete_level()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Weather_discrete_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 934
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_discrete_levelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_discrete_level

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_discrete_middleContext(Weather_discrete_levelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_levelContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_middle" ):
                listener.enterWeather_discrete_middle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_middle" ):
                listener.exitWeather_discrete_middle(self)


    class Weather_discrete_heavyContext(Weather_discrete_levelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_levelContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_heavy" ):
                listener.enterWeather_discrete_heavy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_heavy" ):
                listener.exitWeather_discrete_heavy(self)


    class Weather_discrete_lightContext(Weather_discrete_levelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_levelContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_light" ):
                listener.enterWeather_discrete_light(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_light" ):
                listener.exitWeather_discrete_light(self)



    def weather_discrete_level(self):

        localctx = AVScenariosParser.Weather_discrete_levelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_weather_discrete_level)
        try:
            self.state = 940
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__61]:
                localctx = AVScenariosParser.Weather_discrete_lightContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 937
                self.match(AVScenariosParser.T__61)
                pass
            elif token in [AVScenariosParser.T__62]:
                localctx = AVScenariosParser.Weather_discrete_middleContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 938
                self.match(AVScenariosParser.T__62)
                pass
            elif token in [AVScenariosParser.T__63]:
                localctx = AVScenariosParser.Weather_discrete_heavyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 939
                self.match(AVScenariosParser.T__63)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TrafficContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_traffic

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Traffic_trafficContext(TrafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.TrafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def traffic_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Traffic_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_traffic" ):
                listener.enterTraffic_traffic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_traffic" ):
                listener.exitTraffic_traffic(self)



    def traffic(self):

        localctx = AVScenariosParser.TrafficContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_traffic)
        try:
            localctx = AVScenariosParser.Traffic_trafficContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 942
            self.match(AVScenariosParser.T__8)
            self.state = 943
            self.traffic_statement()
            self.state = 944
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Traffic_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_traffic_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Traffic_stmtContext(Traffic_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Traffic_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def intersection_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Intersection_trafficContext,0)

        def lane_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Lane_trafficContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_stmt" ):
                listener.enterTraffic_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_stmt" ):
                listener.exitTraffic_stmt(self)



    def traffic_statement(self):

        localctx = AVScenariosParser.Traffic_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_traffic_statement)
        try:
            localctx = AVScenariosParser.Traffic_stmtContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 946
            self.intersection_traffic()
            self.state = 947
            self.match(AVScenariosParser.T__13)
            self.state = 948
            self.lane_traffic(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Intersection_trafficContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_intersection_traffic

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IntersectionContext(Intersection_trafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Intersection_trafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def meta_intersection_traffic_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Meta_intersection_traffic_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Meta_intersection_traffic_parameterContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection" ):
                listener.enterIntersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection" ):
                listener.exitIntersection(self)



    def intersection_traffic(self):

        localctx = AVScenariosParser.Intersection_trafficContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_intersection_traffic)
        try:
            localctx = AVScenariosParser.IntersectionContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 950
            self.meta_intersection_traffic_parameter()
            self.state = 955
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 951
                    self.match(AVScenariosParser.T__13)
                    self.state = 952
                    self.meta_intersection_traffic_parameter() 
                self.state = 957
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Meta_intersection_traffic_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_meta_intersection_traffic_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Meta_intersection_metaContext(Meta_intersection_traffic_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Meta_intersection_traffic_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def meta_intersection_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Meta_intersection_trafficContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeta_intersection_meta" ):
                listener.enterMeta_intersection_meta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeta_intersection_meta" ):
                listener.exitMeta_intersection_meta(self)


    class Meta_intersection_meta_varContext(Meta_intersection_traffic_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Meta_intersection_traffic_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeta_intersection_meta_var" ):
                listener.enterMeta_intersection_meta_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeta_intersection_meta_var" ):
                listener.exitMeta_intersection_meta_var(self)



    def meta_intersection_traffic_parameter(self):

        localctx = AVScenariosParser.Meta_intersection_traffic_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_meta_intersection_traffic_parameter)
        try:
            self.state = 960
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Meta_intersection_meta_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 958
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Meta_intersection_metaContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 959
                self.meta_intersection_traffic()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Meta_intersection_trafficContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_meta_intersection_traffic

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Meta_intersection_intersectionContext(Meta_intersection_trafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Meta_intersection_trafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def intersection_ID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Intersection_ID_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeta_intersection_intersection" ):
                listener.enterMeta_intersection_intersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeta_intersection_intersection" ):
                listener.exitMeta_intersection_intersection(self)



    def meta_intersection_traffic(self):

        localctx = AVScenariosParser.Meta_intersection_trafficContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_meta_intersection_traffic)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.Meta_intersection_intersectionContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 962
            self.match(AVScenariosParser.T__64)
            self.state = 963
            self.match(AVScenariosParser.T__1)
            self.state = 964
            self.intersection_ID_parameter()
            self.state = 965
            self.match(AVScenariosParser.T__13)
            self.state = 966
            _la = self._input.LA(1)
            if not(_la==AVScenariosParser.T__19 or _la==AVScenariosParser.T__20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 967
            self.match(AVScenariosParser.T__13)
            self.state = 968
            _la = self._input.LA(1)
            if not(_la==AVScenariosParser.T__19 or _la==AVScenariosParser.T__20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 969
            self.match(AVScenariosParser.T__13)
            self.state = 970
            _la = self._input.LA(1)
            if not(_la==AVScenariosParser.T__19 or _la==AVScenariosParser.T__20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 971
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Intersection_ID_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_intersection_ID_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Intersection_intersection_varContext(Intersection_ID_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Intersection_ID_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection_intersection_var" ):
                listener.enterIntersection_intersection_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection_intersection_var" ):
                listener.exitIntersection_intersection_var(self)


    class Intersection_intersectionContext(Intersection_ID_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Intersection_ID_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def intersection_ID(self):
            return self.getTypedRuleContext(AVScenariosParser.Intersection_IDContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection_intersection" ):
                listener.enterIntersection_intersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection_intersection" ):
                listener.exitIntersection_intersection(self)



    def intersection_ID_parameter(self):

        localctx = AVScenariosParser.Intersection_ID_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_intersection_ID_parameter)
        try:
            self.state = 975
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__0, AVScenariosParser.T__6, AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Intersection_intersectionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 973
                self.intersection_ID()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Intersection_intersection_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 974
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Intersection_IDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_intersection_ID

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Intersection_signalContext(Intersection_IDContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Intersection_IDContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def number_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Number_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection_signal" ):
                listener.enterIntersection_signal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection_signal" ):
                listener.exitIntersection_signal(self)



    def intersection_ID(self):

        localctx = AVScenariosParser.Intersection_IDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_intersection_ID)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.Intersection_signalContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 978
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6:
                self.state = 977
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 980
            self.number_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Lane_trafficContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_lane_traffic

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Lane_lane_speed_limitContext(Lane_trafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Lane_trafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def lane_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Lane_trafficContext,0)

        def speed_limitation_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_limitation_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLane_lane_speed_limit" ):
                listener.enterLane_lane_speed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLane_lane_speed_limit" ):
                listener.exitLane_lane_speed_limit(self)


    class Lane_speed_limitContext(Lane_trafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Lane_trafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed_limitation_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_limitation_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLane_speed_limit" ):
                listener.enterLane_speed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLane_speed_limit" ):
                listener.exitLane_speed_limit(self)



    def lane_traffic(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Lane_trafficContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 198
        self.enterRecursionRule(localctx, 198, self.RULE_lane_traffic, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Lane_speed_limitContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 983
            self.speed_limitation_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 990
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,90,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Lane_lane_speed_limitContext(self, AVScenariosParser.Lane_trafficContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_lane_traffic)
                    self.state = 985
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 986
                    self.match(AVScenariosParser.T__13)
                    self.state = 987
                    self.speed_limitation_parameter() 
                self.state = 992
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,90,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Speed_limitation_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_limitation_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_limitContext(Speed_limitation_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_limitation_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed_limitation(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_limitationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_limit" ):
                listener.enterSpeed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_limit" ):
                listener.exitSpeed_limit(self)


    class Speed_limit_varContext(Speed_limitation_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_limitation_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_limit_var" ):
                listener.enterSpeed_limit_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_limit_var" ):
                listener.exitSpeed_limit_var(self)



    def speed_limitation_parameter(self):

        localctx = AVScenariosParser.Speed_limitation_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_speed_limitation_parameter)
        try:
            self.state = 995
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Speed_limitContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 993
                self.speed_limitation()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Speed_limit_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 994
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_limitationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_limitation

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_limit_speed_limitContext(Speed_limitationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_limitationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def speed_range_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_range_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_limit_speed_limit" ):
                listener.enterSpeed_limit_speed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_limit_speed_limit" ):
                listener.exitSpeed_limit_speed_limit(self)



    def speed_limitation(self):

        localctx = AVScenariosParser.Speed_limitationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_speed_limitation)
        try:
            localctx = AVScenariosParser.Speed_limit_speed_limitContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 997
            self.match(AVScenariosParser.T__65)
            self.state = 998
            self.match(AVScenariosParser.T__1)
            self.state = 999
            self.laneID_parameter()
            self.state = 1000
            self.match(AVScenariosParser.T__13)
            self.state = 1001
            self.speed_range_parameter()
            self.state = 1002
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_range_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_range_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_range_varContext(Speed_range_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_range_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_range_var" ):
                listener.enterSpeed_range_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_range_var" ):
                listener.exitSpeed_range_var(self)


    class Speed_range_speedContext(Speed_range_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_range_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed_range(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_rangeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_range_speed" ):
                listener.enterSpeed_range_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_range_speed" ):
                listener.exitSpeed_range_speed(self)



    def speed_range_parameter(self):

        localctx = AVScenariosParser.Speed_range_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_speed_range_parameter)
        try:
            self.state = 1006
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__81, AVScenariosParser.T__83, AVScenariosParser.T__84, AVScenariosParser.T__85, AVScenariosParser.T__92, AVScenariosParser.T__93, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Speed_range_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1004
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Speed_range_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1005
                self.speed_range()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_rangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_range

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_range_valueContext(Speed_rangeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_rangeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_range_value" ):
                listener.enterSpeed_range_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_range_value" ):
                listener.exitSpeed_range_value(self)



    def speed_range(self):

        localctx = AVScenariosParser.Speed_rangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_speed_range)
        try:
            localctx = AVScenariosParser.Speed_range_valueContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1008
            self.match(AVScenariosParser.T__1)
            self.state = 1009
            self.real_value_expression(0)
            self.state = 1010
            self.match(AVScenariosParser.T__13)
            self.state = 1011
            self.real_value_expression(0)
            self.state = 1012
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Trace_assignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_trace_assignment

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Trace_scenarioContext(Trace_assignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Trace_assignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrace_scenario" ):
                listener.enterTrace_scenario(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrace_scenario" ):
                listener.exitTrace_scenario(self)



    def trace_assignment(self):

        localctx = AVScenariosParser.Trace_assignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_trace_assignment)
        try:
            localctx = AVScenariosParser.Trace_scenarioContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1014
            self.match(AVScenariosParser.T__66)
            self.state = 1015
            self.identifier()
            self.state = 1016
            self.match(AVScenariosParser.T__67)
            self.state = 1017
            self.match(AVScenariosParser.T__68)
            self.state = 1018
            self.match(AVScenariosParser.T__1)
            self.state = 1019
            self.identifier()
            self.state = 1020
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Trace_identifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_trace_identifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Trace_idContext(Trace_identifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Trace_identifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrace_id" ):
                listener.enterTrace_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrace_id" ):
                listener.exitTrace_id(self)



    def trace_identifier(self):

        localctx = AVScenariosParser.Trace_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_trace_identifier)
        try:
            localctx = AVScenariosParser.Trace_idContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1022
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compare_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_compare_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompare_operator" ):
                listener.enterCompare_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompare_operator" ):
                listener.exitCompare_operator(self)




    def compare_operator(self):

        localctx = AVScenariosParser.Compare_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_compare_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1024
            _la = self._input.LA(1)
            if not(((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (AVScenariosParser.T__69 - 70)) | (1 << (AVScenariosParser.T__70 - 70)) | (1 << (AVScenariosParser.T__71 - 70)) | (1 << (AVScenariosParser.T__72 - 70)) | (1 << (AVScenariosParser.T__73 - 70)) | (1 << (AVScenariosParser.T__74 - 70)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Temporal_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def a(self):
            return self.getTypedRuleContext(AVScenariosParser.AContext,0)


        def b(self):
            return self.getTypedRuleContext(AVScenariosParser.BContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_temporal_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporal_operator" ):
                listener.enterTemporal_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporal_operator" ):
                listener.exitTemporal_operator(self)




    def temporal_operator(self):

        localctx = AVScenariosParser.Temporal_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_temporal_operator)
        try:
            self.state = 1050
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1026
                self.match(AVScenariosParser.T__75)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1027
                self.match(AVScenariosParser.T__76)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1028
                self.match(AVScenariosParser.T__77)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1029
                self.match(AVScenariosParser.T__75)
                self.state = 1030
                self.match(AVScenariosParser.T__78)
                self.state = 1031
                self.a()
                self.state = 1032
                self.match(AVScenariosParser.T__13)
                self.state = 1033
                self.b()
                self.state = 1034
                self.match(AVScenariosParser.T__79)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1036
                self.match(AVScenariosParser.T__76)
                self.state = 1037
                self.match(AVScenariosParser.T__78)
                self.state = 1038
                self.a()
                self.state = 1039
                self.match(AVScenariosParser.T__13)
                self.state = 1040
                self.b()
                self.state = 1041
                self.match(AVScenariosParser.T__79)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1043
                self.match(AVScenariosParser.T__77)
                self.state = 1044
                self.match(AVScenariosParser.T__78)
                self.state = 1045
                self.a()
                self.state = 1046
                self.match(AVScenariosParser.T__13)
                self.state = 1047
                self.b()
                self.state = 1048
                self.match(AVScenariosParser.T__79)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Temporal_operator1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def a(self):
            return self.getTypedRuleContext(AVScenariosParser.AContext,0)


        def b(self):
            return self.getTypedRuleContext(AVScenariosParser.BContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_temporal_operator1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporal_operator1" ):
                listener.enterTemporal_operator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporal_operator1" ):
                listener.exitTemporal_operator1(self)




    def temporal_operator1(self):

        localctx = AVScenariosParser.Temporal_operator1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_temporal_operator1)
        try:
            self.state = 1060
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1052
                self.match(AVScenariosParser.T__80)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1053
                self.match(AVScenariosParser.T__80)
                self.state = 1054
                self.match(AVScenariosParser.T__78)
                self.state = 1055
                self.a()
                self.state = 1056
                self.match(AVScenariosParser.T__13)
                self.state = 1057
                self.b()
                self.state = 1058
                self.match(AVScenariosParser.T__79)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_a

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class A_rvContext(AContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.AContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterA_rv" ):
                listener.enterA_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitA_rv" ):
                listener.exitA_rv(self)



    def a(self):

        localctx = AVScenariosParser.AContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_a)
        try:
            localctx = AVScenariosParser.A_rvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1062
            self.real_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_b

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class B_rvContext(BContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.BContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterB_rv" ):
                listener.enterB_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitB_rv" ):
                listener.exitB_rv(self)



    def b(self):

        localctx = AVScenariosParser.BContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_b)
        try:
            localctx = AVScenariosParser.B_rvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1064
            self.real_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Atom_statement_overallContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_atom_statement_overall

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Atom_statement_overall_atom_statementContext(Atom_statement_overallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_overallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_overall_atom_statement" ):
                listener.enterAtom_statement_overall_atom_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_overall_atom_statement" ):
                listener.exitAtom_statement_overall_atom_statement(self)


    class Atom_statement_overall_with_kuohaoContext(Atom_statement_overallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_overallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_statement_overall(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_statement_overallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_overall_with_kuohao" ):
                listener.enterAtom_statement_overall_with_kuohao(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_overall_with_kuohao" ):
                listener.exitAtom_statement_overall_with_kuohao(self)


    class Atom_statement_idContext(Atom_statement_overallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_overallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_id" ):
                listener.enterAtom_statement_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_id" ):
                listener.exitAtom_statement_id(self)


    class Atom_statement_overall_combinationContext(Atom_statement_overallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_overallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_statement_overall(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Atom_statement_overallContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Atom_statement_overallContext,i)

        def arithmetic_operator(self):
            return self.getTypedRuleContext(AVScenariosParser.Arithmetic_operatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_overall_combination" ):
                listener.enterAtom_statement_overall_combination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_overall_combination" ):
                listener.exitAtom_statement_overall_combination(self)



    def atom_statement_overall(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Atom_statement_overallContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 222
        self.enterRecursionRule(localctx, 222, self.RULE_atom_statement_overall, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1073
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Atom_statement_overall_atom_statementContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1067
                self.atom_statement()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Atom_statement_overall_with_kuohaoContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1068
                self.match(AVScenariosParser.T__1)
                self.state = 1069
                self.atom_statement_overall(0)
                self.state = 1070
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Atom_statement_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1072
                self.identifier()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1081
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,96,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Atom_statement_overall_combinationContext(self, AVScenariosParser.Atom_statement_overallContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_atom_statement_overall)
                    self.state = 1075
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 1076
                    self.arithmetic_operator()
                    self.state = 1077
                    self.atom_statement_overall(3) 
                self.state = 1083
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,96,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Atom_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_atom_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Acceleration_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def acceleration_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Acceleration_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_statement_for_general_statement" ):
                listener.enterAcceleration_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_statement_for_general_statement" ):
                listener.exitAcceleration_statement_for_general_statement(self)


    class Velocity_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def velocity_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Velocity_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_statement_for_general_statement" ):
                listener.enterVelocity_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_statement_for_general_statement" ):
                listener.exitVelocity_statement_for_general_statement(self)


    class Distance_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def distance_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Distance_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistance_statement_for_general_statement" ):
                listener.enterDistance_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistance_statement_for_general_statement" ):
                listener.exitDistance_statement_for_general_statement(self)


    class Perception_difference_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def perception_difference_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Perception_difference_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPerception_difference_statement_for_general_statement" ):
                listener.enterPerception_difference_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPerception_difference_statement_for_general_statement" ):
                listener.exitPerception_difference_statement_for_general_statement(self)


    class Speed_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_statement_for_general_statement" ):
                listener.enterSpeed_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_statement_for_general_statement" ):
                listener.exitSpeed_statement_for_general_statement(self)


    class Real_value_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReal_value_for_general_statement" ):
                listener.enterReal_value_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReal_value_for_general_statement" ):
                listener.exitReal_value_for_general_statement(self)



    def atom_statement(self):

        localctx = AVScenariosParser.Atom_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_atom_statement)
        try:
            self.state = 1090
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__81]:
                localctx = AVScenariosParser.Distance_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1084
                self.distance_statement()
                pass
            elif token in [AVScenariosParser.T__85]:
                localctx = AVScenariosParser.Perception_difference_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1085
                self.perception_difference_statement()
                pass
            elif token in [AVScenariosParser.T__86]:
                localctx = AVScenariosParser.Velocity_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1086
                self.velocity_statement()
                pass
            elif token in [AVScenariosParser.T__87]:
                localctx = AVScenariosParser.Speed_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1087
                self.speed_statement()
                pass
            elif token in [AVScenariosParser.T__88]:
                localctx = AVScenariosParser.Acceleration_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1088
                self.acceleration_statement()
                pass
            elif token in [AVScenariosParser.T__0, AVScenariosParser.T__6, AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.Non_negative_value, AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Real_value_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1089
                self.real_value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Distance_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def position_element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Position_elementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Position_elementContext,i)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_distance_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistance_statement" ):
                listener.enterDistance_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistance_statement" ):
                listener.exitDistance_statement(self)




    def distance_statement(self):

        localctx = AVScenariosParser.Distance_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_distance_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1092
            self.match(AVScenariosParser.T__81)
            self.state = 1093
            self.match(AVScenariosParser.T__1)
            self.state = 1094
            self.position_element()
            self.state = 1095
            self.match(AVScenariosParser.T__13)
            self.state = 1096
            self.position_element()
            self.state = 1097
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Position_elementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_position_element

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_ground_truth_parameter_for_distanceContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_ground_truth_parameter_for_distance" ):
                listener.enterAgent_ground_truth_parameter_for_distance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_ground_truth_parameter_for_distance" ):
                listener.exitAgent_ground_truth_parameter_for_distance(self)


    class Agent_state_parameter_for_distanceContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_state_parameter_for_distance" ):
                listener.enterAgent_state_parameter_for_distance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_state_parameter_for_distance" ):
                listener.exitAgent_state_parameter_for_distance(self)


    class Ego_state_parameter_for_distanceContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_state_parameter_for_distance" ):
                listener.enterEgo_state_parameter_for_distance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_state_parameter_for_distance" ):
                listener.exitEgo_state_parameter_for_distance(self)


    class Position_parameter_for_generalContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def position(self):
            return self.getTypedRuleContext(AVScenariosParser.PositionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition_parameter_for_general" ):
                listener.enterPosition_parameter_for_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition_parameter_for_general" ):
                listener.exitPosition_parameter_for_general(self)


    class Position_element_idContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition_element_id" ):
                listener.enterPosition_element_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition_element_id" ):
                listener.exitPosition_element_id(self)



    def position_element(self):

        localctx = AVScenariosParser.Position_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_position_element)
        try:
            self.state = 1104
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,98,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Ego_state_parameter_for_distanceContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1099
                self.ego_state()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Agent_state_parameter_for_distanceContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1100
                self.agent_state()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Agent_ground_truth_parameter_for_distanceContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1101
                self.agent_ground_truth()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Position_parameter_for_generalContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1102
                self.position()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Position_element_idContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1103
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ego_state_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_ego_state_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Ego_state_idContext(Ego_state_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_state_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_state_id" ):
                listener.enterEgo_state_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_state_id" ):
                listener.exitEgo_state_id(self)


    class Ego_state_parContext(Ego_state_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_state_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_state_par" ):
                listener.enterEgo_state_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_state_par" ):
                listener.exitEgo_state_par(self)



    def ego_state_parameter(self):

        localctx = AVScenariosParser.Ego_state_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_ego_state_parameter)
        try:
            self.state = 1108
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Ego_state_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1106
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Ego_state_parContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1107
                self.ego_state()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ego_stateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_ego_state

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Ego_state_for_generalContext(Ego_stateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_stateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_identifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_state_for_general" ):
                listener.enterEgo_state_for_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_state_for_general" ):
                listener.exitEgo_state_for_general(self)



    def ego_state(self):

        localctx = AVScenariosParser.Ego_stateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_ego_state)
        try:
            localctx = AVScenariosParser.Ego_state_for_generalContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1110
            self.trace_identifier()
            self.state = 1111
            self.match(AVScenariosParser.T__78)
            self.state = 1112
            self.match(AVScenariosParser.T__82)
            self.state = 1113
            self.match(AVScenariosParser.T__79)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Agent_state_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_agent_state_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_state_parContext(Agent_state_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_state_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_state_par" ):
                listener.enterAgent_state_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_state_par" ):
                listener.exitAgent_state_par(self)


    class Agent_state_idContext(Agent_state_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_state_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_state_id" ):
                listener.enterAgent_state_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_state_id" ):
                listener.exitAgent_state_id(self)



    def agent_state_parameter(self):

        localctx = AVScenariosParser.Agent_state_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_agent_state_parameter)
        try:
            self.state = 1117
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Agent_state_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1115
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Agent_state_parContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1116
                self.agent_state()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Agent_stateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_agent_state

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_state_for_generalContext(Agent_stateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_stateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_identifierContext,0)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_state_for_general" ):
                listener.enterAgent_state_for_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_state_for_general" ):
                listener.exitAgent_state_for_general(self)



    def agent_state(self):

        localctx = AVScenariosParser.Agent_stateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_agent_state)
        try:
            localctx = AVScenariosParser.Agent_state_for_generalContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1119
            self.trace_identifier()
            self.state = 1120
            self.match(AVScenariosParser.T__78)
            self.state = 1121
            self.match(AVScenariosParser.T__83)
            self.state = 1122
            self.match(AVScenariosParser.T__79)
            self.state = 1123
            self.match(AVScenariosParser.T__78)
            self.state = 1124
            self.identifier()
            self.state = 1125
            self.match(AVScenariosParser.T__79)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Agent_ground_truth_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_agent_ground_truth_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_ground_truth_idContext(Agent_ground_truth_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_ground_truth_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_ground_truth_id" ):
                listener.enterAgent_ground_truth_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_ground_truth_id" ):
                listener.exitAgent_ground_truth_id(self)


    class Agent_ground_truth_parContext(Agent_ground_truth_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_ground_truth_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_ground_truth_par" ):
                listener.enterAgent_ground_truth_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_ground_truth_par" ):
                listener.exitAgent_ground_truth_par(self)



    def agent_ground_truth_parameter(self):

        localctx = AVScenariosParser.Agent_ground_truth_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_agent_ground_truth_parameter)
        try:
            self.state = 1129
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Agent_ground_truth_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1127
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Agent_ground_truth_parContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1128
                self.agent_ground_truth()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Agent_ground_truthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_agent_ground_truth

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_ground_truth_for_generalContext(Agent_ground_truthContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_ground_truthContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_identifierContext,0)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_ground_truth_for_general" ):
                listener.enterAgent_ground_truth_for_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_ground_truth_for_general" ):
                listener.exitAgent_ground_truth_for_general(self)



    def agent_ground_truth(self):

        localctx = AVScenariosParser.Agent_ground_truthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_agent_ground_truth)
        try:
            localctx = AVScenariosParser.Agent_ground_truth_for_generalContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1131
            self.trace_identifier()
            self.state = 1132
            self.match(AVScenariosParser.T__78)
            self.state = 1133
            self.match(AVScenariosParser.T__84)
            self.state = 1134
            self.match(AVScenariosParser.T__79)
            self.state = 1135
            self.match(AVScenariosParser.T__78)
            self.state = 1136
            self.identifier()
            self.state = 1137
            self.match(AVScenariosParser.T__79)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Perception_difference_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def agent_state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_state_parameterContext,0)


        def agent_ground_truth_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truth_parameterContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_perception_difference_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPerception_difference_statement" ):
                listener.enterPerception_difference_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPerception_difference_statement" ):
                listener.exitPerception_difference_statement(self)




    def perception_difference_statement(self):

        localctx = AVScenariosParser.Perception_difference_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_perception_difference_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1139
            self.match(AVScenariosParser.T__85)
            self.state = 1140
            self.match(AVScenariosParser.T__1)
            self.state = 1141
            self.agent_state_parameter()
            self.state = 1142
            self.match(AVScenariosParser.T__13)
            self.state = 1143
            self.agent_ground_truth_parameter()
            self.state = 1144
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Velocity_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def velocity_parameter_for_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Velocity_parameter_for_statementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Velocity_parameter_for_statementContext,i)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_velocity_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_statement" ):
                listener.enterVelocity_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_statement" ):
                listener.exitVelocity_statement(self)




    def velocity_statement(self):

        localctx = AVScenariosParser.Velocity_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_velocity_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1146
            self.match(AVScenariosParser.T__86)
            self.state = 1147
            self.match(AVScenariosParser.T__1)
            self.state = 1148
            self.velocity_parameter_for_statement()
            self.state = 1149
            self.match(AVScenariosParser.T__13)
            self.state = 1150
            self.velocity_parameter_for_statement()
            self.state = 1151
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Velocity_parameter_for_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_velocity_parameter_for_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Velocity_element_agent_stateContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_agent_state" ):
                listener.enterVelocity_element_agent_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_agent_state" ):
                listener.exitVelocity_element_agent_state(self)


    class Velocity_element_ego_stateContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_ego_state" ):
                listener.enterVelocity_element_ego_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_ego_state" ):
                listener.exitVelocity_element_ego_state(self)


    class Velocity_element_idContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_id" ):
                listener.enterVelocity_element_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_id" ):
                listener.exitVelocity_element_id(self)


    class Velocity_element_velocityContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def velocity(self):
            return self.getTypedRuleContext(AVScenariosParser.VelocityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_velocity" ):
                listener.enterVelocity_element_velocity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_velocity" ):
                listener.exitVelocity_element_velocity(self)


    class Velocity_element_agent_ground_truthContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_agent_ground_truth" ):
                listener.enterVelocity_element_agent_ground_truth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_agent_ground_truth" ):
                listener.exitVelocity_element_agent_ground_truth(self)



    def velocity_parameter_for_statement(self):

        localctx = AVScenariosParser.Velocity_parameter_for_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_velocity_parameter_for_statement)
        try:
            self.state = 1158
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Velocity_element_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1153
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Velocity_element_ego_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1154
                self.ego_state()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Velocity_element_agent_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1155
                self.agent_state()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Velocity_element_agent_ground_truthContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1156
                self.agent_ground_truth()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Velocity_element_velocityContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1157
                self.velocity()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Velocity_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def velocity(self):
            return self.getTypedRuleContext(AVScenariosParser.VelocityContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_velocity_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_parameter" ):
                listener.enterVelocity_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_parameter" ):
                listener.exitVelocity_parameter(self)




    def velocity_parameter(self):

        localctx = AVScenariosParser.Velocity_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_velocity_parameter)
        try:
            self.state = 1162
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1160
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1161
                self.velocity()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VelocityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_velocity

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Velocity_valueContext(VelocityContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.VelocityContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_value" ):
                listener.enterVelocity_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_value" ):
                listener.exitVelocity_value(self)



    def velocity(self):

        localctx = AVScenariosParser.VelocityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_velocity)
        try:
            localctx = AVScenariosParser.Velocity_valueContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1164
            self.coordinate_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def speed_parameter_for_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Speed_parameter_for_statementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Speed_parameter_for_statementContext,i)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_statement" ):
                listener.enterSpeed_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_statement" ):
                listener.exitSpeed_statement(self)




    def speed_statement(self):

        localctx = AVScenariosParser.Speed_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_speed_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1166
            self.match(AVScenariosParser.T__87)
            self.state = 1167
            self.match(AVScenariosParser.T__1)
            self.state = 1168
            self.speed_parameter_for_statement()
            self.state = 1169
            self.match(AVScenariosParser.T__13)
            self.state = 1170
            self.speed_parameter_for_statement()
            self.state = 1171
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_parameter_for_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_parameter_for_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_element_speedContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed(self):
            return self.getTypedRuleContext(AVScenariosParser.SpeedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_speed" ):
                listener.enterSpeed_element_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_speed" ):
                listener.exitSpeed_element_speed(self)


    class Speed_element_ego_stateContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_ego_state" ):
                listener.enterSpeed_element_ego_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_ego_state" ):
                listener.exitSpeed_element_ego_state(self)


    class Speed_element_agent_stateContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_agent_state" ):
                listener.enterSpeed_element_agent_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_agent_state" ):
                listener.exitSpeed_element_agent_state(self)


    class Speed_element_idContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_id" ):
                listener.enterSpeed_element_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_id" ):
                listener.exitSpeed_element_id(self)


    class Speed_element_agent_ground_truthContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_agent_ground_truth" ):
                listener.enterSpeed_element_agent_ground_truth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_agent_ground_truth" ):
                listener.exitSpeed_element_agent_ground_truth(self)



    def speed_parameter_for_statement(self):

        localctx = AVScenariosParser.Speed_parameter_for_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_speed_parameter_for_statement)
        try:
            self.state = 1178
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Speed_element_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1173
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Speed_element_ego_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1174
                self.ego_state()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Speed_element_agent_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1175
                self.agent_state()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Speed_element_agent_ground_truthContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1176
                self.agent_ground_truth()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Speed_element_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1177
                self.speed()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Acceleration_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def acceleration_parameter_for_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Acceleration_parameter_for_statementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Acceleration_parameter_for_statementContext,i)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_acceleration_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_statement" ):
                listener.enterAcceleration_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_statement" ):
                listener.exitAcceleration_statement(self)




    def acceleration_statement(self):

        localctx = AVScenariosParser.Acceleration_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_acceleration_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1180
            self.match(AVScenariosParser.T__88)
            self.state = 1181
            self.match(AVScenariosParser.T__1)
            self.state = 1182
            self.acceleration_parameter_for_statement()
            self.state = 1183
            self.match(AVScenariosParser.T__13)
            self.state = 1184
            self.acceleration_parameter_for_statement()
            self.state = 1185
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Acceleration_parameter_for_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_acceleration_parameter_for_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Acceleration_element_agent_stateContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_agent_state" ):
                listener.enterAcceleration_element_agent_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_agent_state" ):
                listener.exitAcceleration_element_agent_state(self)


    class Acceleration_element_agent_groundContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_agent_ground" ):
                listener.enterAcceleration_element_agent_ground(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_agent_ground" ):
                listener.exitAcceleration_element_agent_ground(self)


    class Acceleration_element_idContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_id" ):
                listener.enterAcceleration_element_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_id" ):
                listener.exitAcceleration_element_id(self)


    class Acceleration_element_accContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def acceleration(self):
            return self.getTypedRuleContext(AVScenariosParser.AccelerationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_acc" ):
                listener.enterAcceleration_element_acc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_acc" ):
                listener.exitAcceleration_element_acc(self)


    class Acceleration_element_ego_stateContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_ego_state" ):
                listener.enterAcceleration_element_ego_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_ego_state" ):
                listener.exitAcceleration_element_ego_state(self)



    def acceleration_parameter_for_statement(self):

        localctx = AVScenariosParser.Acceleration_parameter_for_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_acceleration_parameter_for_statement)
        try:
            self.state = 1192
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Acceleration_element_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1187
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Acceleration_element_ego_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1188
                self.ego_state()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Acceleration_element_agent_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1189
                self.agent_state()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Acceleration_element_agent_groundContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1190
                self.agent_ground_truth()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Acceleration_element_accContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1191
                self.acceleration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AccelerationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_acceleration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration" ):
                listener.enterAcceleration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration" ):
                listener.exitAcceleration(self)




    def acceleration(self):

        localctx = AVScenariosParser.AccelerationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_acceleration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1194
            self.coordinate_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Atom_statement_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_atom_statement_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Atom_statement_varContext(Atom_statement_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_statement_overall(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_statement_overallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_var" ):
                listener.enterAtom_statement_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_var" ):
                listener.exitAtom_statement_var(self)



    def atom_statement_parameter(self):

        localctx = AVScenariosParser.Atom_statement_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_atom_statement_parameter)
        try:
            localctx = AVScenariosParser.Atom_statement_varContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1196
            self.atom_statement_overall(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Atom_predicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom_statement_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Atom_statement_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Atom_statement_parameterContext,i)


        def compare_operator(self):
            return self.getTypedRuleContext(AVScenariosParser.Compare_operatorContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_atom_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_predicate" ):
                listener.enterAtom_predicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_predicate" ):
                listener.exitAtom_predicate(self)




    def atom_predicate(self):

        localctx = AVScenariosParser.Atom_predicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_atom_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1198
            self.atom_statement_parameter()
            self.state = 1199
            self.compare_operator()
            self.state = 1200
            self.atom_statement_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class General_assertionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_general_assertion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class General_assertion3Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.General_assertionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,i)

        def temporal_operator1(self):
            return self.getTypedRuleContext(AVScenariosParser.Temporal_operator1Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion3" ):
                listener.enterGeneral_assertion3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion3" ):
                listener.exitGeneral_assertion3(self)


    class General_assertion4Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.General_assertionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion4" ):
                listener.enterGeneral_assertion4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion4" ):
                listener.exitGeneral_assertion4(self)


    class General_assertion5Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.General_assertionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion5" ):
                listener.enterGeneral_assertion5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion5" ):
                listener.exitGeneral_assertion5(self)


    class General_assertion6Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.General_assertionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion6" ):
                listener.enterGeneral_assertion6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion6" ):
                listener.exitGeneral_assertion6(self)


    class General_assertion0_0Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion0_0" ):
                listener.enterGeneral_assertion0_0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion0_0" ):
                listener.exitGeneral_assertion0_0(self)


    class General_assertion0Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_predicate(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_predicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion0" ):
                listener.enterGeneral_assertion0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion0" ):
                listener.exitGeneral_assertion0(self)


    class General_assertion1Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion1" ):
                listener.enterGeneral_assertion1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion1" ):
                listener.exitGeneral_assertion1(self)


    class General_assertion2Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def temporal_operator(self):
            return self.getTypedRuleContext(AVScenariosParser.Temporal_operatorContext,0)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion2" ):
                listener.enterGeneral_assertion2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion2" ):
                listener.exitGeneral_assertion2(self)


    class General_assertion_idContext(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion_id" ):
                listener.enterGeneral_assertion_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion_id" ):
                listener.exitGeneral_assertion_id(self)



    def general_assertion(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.General_assertionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 266
        self.enterRecursionRule(localctx, 266, self.RULE_general_assertion, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1214
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.General_assertion0Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1203
                self.atom_predicate()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.General_assertion0_0Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1204
                self.match(AVScenariosParser.T__1)
                self.state = 1205
                self.general_assertion(0)
                self.state = 1206
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.General_assertion1Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1208
                self.match(AVScenariosParser.T__89)
                self.state = 1209
                self.general_assertion(7)
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.General_assertion2Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1210
                self.temporal_operator()
                self.state = 1211
                self.general_assertion(6)
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.General_assertion_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1213
                self.identifier()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1231
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,108,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1229
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
                    if la_ == 1:
                        localctx = AVScenariosParser.General_assertion3Context(self, AVScenariosParser.General_assertionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_general_assertion)
                        self.state = 1216
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 1217
                        self.temporal_operator1()
                        self.state = 1218
                        self.general_assertion(6)
                        pass

                    elif la_ == 2:
                        localctx = AVScenariosParser.General_assertion4Context(self, AVScenariosParser.General_assertionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_general_assertion)
                        self.state = 1220
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 1221
                        self.match(AVScenariosParser.T__15)
                        self.state = 1222
                        self.general_assertion(5)
                        pass

                    elif la_ == 3:
                        localctx = AVScenariosParser.General_assertion5Context(self, AVScenariosParser.General_assertionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_general_assertion)
                        self.state = 1223
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 1224
                        self.match(AVScenariosParser.T__90)
                        self.state = 1225
                        self.general_assertion(4)
                        pass

                    elif la_ == 4:
                        localctx = AVScenariosParser.General_assertion6Context(self, AVScenariosParser.General_assertionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_general_assertion)
                        self.state = 1226
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 1227
                        self.match(AVScenariosParser.T__21)
                        self.state = 1228
                        self.general_assertion(3)
                        pass

             
                self.state = 1233
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,108,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Operator_related_assignmentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,0)


        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def atom_statement_overall(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_statement_overallContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_operator_related_assignments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator_related_assignments" ):
                listener.enterOperator_related_assignments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator_related_assignments" ):
                listener.exitOperator_related_assignments(self)




    def operator_related_assignments(self):

        localctx = AVScenariosParser.Operator_related_assignmentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_operator_related_assignments)
        try:
            self.state = 1238
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1234
                self.string_expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1235
                self.real_value_expression(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1236
                self.coordinate_expression(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1237
                self.atom_statement_overall(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assignment_statementsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_assignment_statements

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AssignsContext(Assignment_statementsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def assignment_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Assignment_statementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Assignment_statementContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssigns" ):
                listener.enterAssigns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssigns" ):
                listener.exitAssigns(self)



    def assignment_statements(self):

        localctx = AVScenariosParser.Assignment_statementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_assignment_statements)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.AssignsContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1245
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__66 - 65)) | (1 << (AVScenariosParser.T__68 - 65)) | (1 << (AVScenariosParser.T__81 - 65)) | (1 << (AVScenariosParser.T__83 - 65)) | (1 << (AVScenariosParser.T__84 - 65)) | (1 << (AVScenariosParser.T__85 - 65)) | (1 << (AVScenariosParser.T__92 - 65)) | (1 << (AVScenariosParser.T__93 - 65)) | (1 << (AVScenariosParser.Variable_name - 65)))) != 0):
                self.state = 1240
                self.assignment_statement()
                self.state = 1241
                self.match(AVScenariosParser.T__9)
                self.state = 1247
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assignment_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_assignment_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Assign_speed_limitContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def speed_limitation(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_limitationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_speed_limit" ):
                listener.enterAssign_speed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_speed_limit" ):
                listener.exitAssign_speed_limit(self)


    class Assignperception_difference_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def perception_difference_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Perception_difference_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignperception_difference_statement" ):
                listener.enterAssignperception_difference_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignperception_difference_statement" ):
                listener.exitAssignperception_difference_statement(self)


    class Assign_obstaclesContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def obstacles(self):
            return self.getTypedRuleContext(AVScenariosParser.ObstaclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_obstacles" ):
                listener.enterAssign_obstacles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_obstacles" ):
                listener.exitAssign_obstacles(self)


    class Assign_npcsContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def npc_vehicles(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehiclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_npcs" ):
                listener.enterAssign_npcs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_npcs" ):
                listener.exitAssign_npcs(self)


    class Assign_agent_groundContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_agent_ground" ):
                listener.enterAssign_agent_ground(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_agent_ground" ):
                listener.exitAssign_agent_ground(self)


    class Assign_stateContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def state_(self):
            return self.getTypedRuleContext(AVScenariosParser.State_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_state" ):
                listener.enterAssign_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_state" ):
                listener.exitAssign_state(self)


    class Assign_name_two_variablesContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_name_two_variables" ):
                listener.enterAssign_name_two_variables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_name_two_variables" ):
                listener.exitAssign_name_two_variables(self)


    class Assign_name_three_variablesContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_name_three_variables" ):
                listener.enterAssign_name_three_variables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_name_three_variables" ):
                listener.exitAssign_name_three_variables(self)


    class Assign_special_case_of_coordinateContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_special_case_of_coordinate" ):
                listener.enterAssign_special_case_of_coordinate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_special_case_of_coordinate" ):
                listener.exitAssign_special_case_of_coordinate(self)


    class Assign_lane_rangeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_lane_range" ):
                listener.enterAssign_lane_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_lane_range" ):
                listener.exitAssign_lane_range(self)


    class Assign_shapeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def shape(self):
            return self.getTypedRuleContext(AVScenariosParser.ShapeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_shape" ):
                listener.enterAssign_shape(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_shape" ):
                listener.exitAssign_shape(self)


    class Assign_position_range_extensionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def position(self):
            return self.getTypedRuleContext(AVScenariosParser.PositionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_position_range_extension" ):
                listener.enterAssign_position_range_extension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_position_range_extension" ):
                listener.exitAssign_position_range_extension(self)


    class Assign_waypoint_motionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def waypoint_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Waypoint_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_waypoint_motion" ):
                listener.enterAssign_waypoint_motion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_waypoint_motion" ):
                listener.exitAssign_waypoint_motion(self)


    class Assign_obsContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def obstacle(self):
            return self.getTypedRuleContext(AVScenariosParser.ObstacleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_obs" ):
                listener.enterAssign_obs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_obs" ):
                listener.exitAssign_obs(self)


    class Assign_general_assertionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_identifierContext,0)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_general_assertion" ):
                listener.enterAssign_general_assertion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_general_assertion" ):
                listener.exitAssign_general_assertion(self)


    class Assign_egoContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def ego_vehicle(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_vehicleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_ego" ):
                listener.enterAssign_ego(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_ego" ):
                listener.exitAssign_ego(self)


    class Assign_pedContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def pedestrian(self):
            return self.getTypedRuleContext(AVScenariosParser.PedestrianContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_ped" ):
                listener.enterAssign_ped(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_ped" ):
                listener.exitAssign_ped(self)


    class Assign_timeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def time(self):
            return self.getTypedRuleContext(AVScenariosParser.TimeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_time" ):
                listener.enterAssign_time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_time" ):
                listener.exitAssign_time(self)


    class Assign_state_listContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def state_list(self):
            return self.getTypedRuleContext(AVScenariosParser.State_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_state_list" ):
                listener.enterAssign_state_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_state_list" ):
                listener.exitAssign_state_list(self)


    class Assign_traceContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_assignment(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_assignmentContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_trace" ):
                listener.enterAssign_trace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_trace" ):
                listener.exitAssign_trace(self)


    class Assign_general_assertion_to_varContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_general_assertion_to_var" ):
                listener.enterAssign_general_assertion_to_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_general_assertion_to_var" ):
                listener.exitAssign_general_assertion_to_var(self)


    class Assign_pedestrian_typeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def pedestrian_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_pedestrian_type" ):
                listener.enterAssign_pedestrian_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_pedestrian_type" ):
                listener.exitAssign_pedestrian_type(self)


    class Assign_velocity_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def velocity_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Velocity_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_velocity_statement" ):
                listener.enterAssign_velocity_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_velocity_statement" ):
                listener.exitAssign_velocity_statement(self)


    class Assign_speedContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def speed(self):
            return self.getTypedRuleContext(AVScenariosParser.SpeedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_speed" ):
                listener.enterAssign_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_speed" ):
                listener.exitAssign_speed(self)


    class Assign_distance_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def distance_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Distance_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_distance_statement" ):
                listener.enterAssign_distance_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_distance_statement" ):
                listener.exitAssign_distance_statement(self)


    class Assign_operator_related_assignmentsContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def operator_related_assignments(self):
            return self.getTypedRuleContext(AVScenariosParser.Operator_related_assignmentsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_operator_related_assignments" ):
                listener.enterAssign_operator_related_assignments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_operator_related_assignments" ):
                listener.exitAssign_operator_related_assignments(self)


    class Assign_npcContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def npc_vehicle(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_npc" ):
                listener.enterAssign_npc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_npc" ):
                listener.exitAssign_npc(self)


    class Assign_variableContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_variable" ):
                listener.enterAssign_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_variable" ):
                listener.exitAssign_variable(self)


    class Assign_case_of_positionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_case_of_position" ):
                listener.enterAssign_case_of_position(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_case_of_position" ):
                listener.exitAssign_case_of_position(self)


    class Assign_envContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def env(self):
            return self.getTypedRuleContext(AVScenariosParser.EnvContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_env" ):
                listener.enterAssign_env(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_env" ):
                listener.exitAssign_env(self)


    class Assign_acceleration_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def acceleration_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Acceleration_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_acceleration_statement" ):
                listener.enterAssign_acceleration_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_acceleration_statement" ):
                listener.exitAssign_acceleration_statement(self)


    class Assign_ego_stateContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_ego_state" ):
                listener.enterAssign_ego_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_ego_state" ):
                listener.exitAssign_ego_state(self)


    class Assign_pedestriansContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def pedestrians(self):
            return self.getTypedRuleContext(AVScenariosParser.PedestriansContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_pedestrians" ):
                listener.enterAssign_pedestrians(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_pedestrians" ):
                listener.exitAssign_pedestrians(self)


    class Assign_trafficContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.TrafficContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_traffic" ):
                listener.enterAssign_traffic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_traffic" ):
                listener.exitAssign_traffic(self)


    class Assign_vehicle_typeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def vehicle_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_vehicle_type" ):
                listener.enterAssign_vehicle_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_vehicle_type" ):
                listener.exitAssign_vehicle_type(self)


    class Assign_lane_rvContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_lane_rv" ):
                listener.enterAssign_lane_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_lane_rv" ):
                listener.exitAssign_lane_rv(self)


    class Assign_speed_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def speed_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_speed_statement" ):
                listener.enterAssign_speed_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_speed_statement" ):
                listener.exitAssign_speed_statement(self)


    class Assign_weatherContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def weather(self):
            return self.getTypedRuleContext(AVScenariosParser.WeatherContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_weather" ):
                listener.enterAssign_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_weather" ):
                listener.exitAssign_weather(self)


    class Assign_intersectionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def meta_intersection_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Meta_intersection_trafficContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_intersection" ):
                listener.enterAssign_intersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_intersection" ):
                listener.exitAssign_intersection(self)


    class Assign_weather_stmtContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def weather_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_weather_stmt" ):
                listener.enterAssign_weather_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_weather_stmt" ):
                listener.exitAssign_weather_stmt(self)


    class Assign_headingContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def heading(self):
            return self.getTypedRuleContext(AVScenariosParser.HeadingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_heading" ):
                listener.enterAssign_heading(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_heading" ):
                listener.exitAssign_heading(self)


    class Assign_scenarioContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def scenario(self):
            return self.getTypedRuleContext(AVScenariosParser.ScenarioContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_scenario" ):
                listener.enterAssign_scenario(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_scenario" ):
                listener.exitAssign_scenario(self)


    class Assign_uniform_motionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def uniform_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Uniform_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_uniform_motion" ):
                listener.enterAssign_uniform_motion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_uniform_motion" ):
                listener.exitAssign_uniform_motion(self)


    class Assign_general_typeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def general_type(self):
            return self.getTypedRuleContext(AVScenariosParser.General_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_general_type" ):
                listener.enterAssign_general_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_general_type" ):
                listener.exitAssign_general_type(self)


    class Assign_variablesContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_variables" ):
                listener.enterAssign_variables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_variables" ):
                listener.exitAssign_variables(self)


    class Assign_rv_rvContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_rv_rv" ):
                listener.enterAssign_rv_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_rv_rv" ):
                listener.exitAssign_rv_rv(self)


    class Assign_colorContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def color(self):
            return self.getTypedRuleContext(AVScenariosParser.ColorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_color" ):
                listener.enterAssign_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_color" ):
                listener.exitAssign_color(self)


    class Assign_agent_stateContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_agent_state" ):
                listener.enterAssign_agent_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_agent_state" ):
                listener.exitAssign_agent_state(self)


    class Assign_weather_discreteContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def weather_discrete_level(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_discrete_levelContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_weather_discrete" ):
                listener.enterAssign_weather_discrete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_weather_discrete" ):
                listener.exitAssign_weather_discrete(self)



    def assignment_statement(self):

        localctx = AVScenariosParser.Assignment_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_assignment_statement)
        self._la = 0 # Token type
        try:
            self.state = 1495
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Assign_scenarioContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1248
                self.identifier()
                self.state = 1249
                self.match(AVScenariosParser.T__67)
                self.state = 1250
                self.scenario()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Assign_egoContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1252
                self.identifier()
                self.state = 1253
                self.match(AVScenariosParser.T__67)
                self.state = 1254
                self.ego_vehicle()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Assign_variableContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1256
                self.identifier()
                self.state = 1257
                self.match(AVScenariosParser.T__67)
                self.state = 1258
                self.match(AVScenariosParser.T__1)
                self.state = 1259
                self.identifier()
                self.state = 1260
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Assign_name_two_variablesContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1262
                self.identifier()
                self.state = 1263
                self.match(AVScenariosParser.T__67)
                self.state = 1264
                self.match(AVScenariosParser.T__1)
                self.state = 1265
                self.identifier()
                self.state = 1266
                self.match(AVScenariosParser.T__13)
                self.state = 1267
                self.identifier()
                self.state = 1268
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Assign_name_three_variablesContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1270
                self.identifier()
                self.state = 1271
                self.match(AVScenariosParser.T__67)
                self.state = 1272
                self.match(AVScenariosParser.T__1)
                self.state = 1273
                self.identifier()
                self.state = 1274
                self.match(AVScenariosParser.T__13)
                self.state = 1275
                self.identifier()
                self.state = 1276
                self.match(AVScenariosParser.T__13)
                self.state = 1277
                self.identifier()
                self.state = 1278
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 6:
                localctx = AVScenariosParser.Assign_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1280
                self.identifier()
                self.state = 1281
                self.match(AVScenariosParser.T__67)
                self.state = 1282
                self.state_()
                pass

            elif la_ == 7:
                localctx = AVScenariosParser.Assign_vehicle_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1284
                self.identifier()
                self.state = 1285
                self.match(AVScenariosParser.T__67)
                self.state = 1286
                self.vehicle_type()
                pass

            elif la_ == 8:
                localctx = AVScenariosParser.Assign_state_listContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1288
                self.identifier()
                self.state = 1289
                self.match(AVScenariosParser.T__67)
                self.state = 1290
                self.state_list()
                pass

            elif la_ == 9:
                localctx = AVScenariosParser.Assign_pedestrian_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 1292
                self.identifier()
                self.state = 1293
                self.match(AVScenariosParser.T__67)
                self.state = 1294
                self.pedestrian_type()
                pass

            elif la_ == 10:
                localctx = AVScenariosParser.Assign_case_of_positionContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 1296
                self.identifier()
                self.state = 1297
                self.match(AVScenariosParser.T__67)
                self.state = 1298
                self.coordinate_frame()
                self.state = 1299
                self.coordinate_expression(0)
                pass

            elif la_ == 11:
                localctx = AVScenariosParser.Assign_rv_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 1301
                self.identifier()
                self.state = 1302
                self.match(AVScenariosParser.T__67)
                self.state = 1304
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18))) != 0):
                    self.state = 1303
                    self.coordinate_frame()


                self.state = 1306
                self.match(AVScenariosParser.T__1)
                self.state = 1307
                self.real_value_expression(0)
                self.state = 1308
                self.match(AVScenariosParser.T__13)
                self.state = 1309
                self.real_value_expression(0)
                self.state = 1313
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 1310
                    self.match(AVScenariosParser.T__13)
                    self.state = 1311
                    localctx.op = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                        localctx.op = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1312
                    self.real_value_expression(0)


                self.state = 1315
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 12:
                localctx = AVScenariosParser.Assign_lane_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 1317
                self.identifier()
                self.state = 1318
                self.match(AVScenariosParser.T__67)
                self.state = 1320
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,113,self._ctx)
                if la_ == 1:
                    self.state = 1319
                    self.coordinate_frame()


                self.state = 1322
                self.laneID_parameter()
                self.state = 1323
                self.match(AVScenariosParser.T__21)
                self.state = 1324
                self.real_value_expression(0)
                pass

            elif la_ == 13:
                localctx = AVScenariosParser.Assign_lane_rangeContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 1326
                self.identifier()
                self.state = 1327
                self.match(AVScenariosParser.T__67)
                self.state = 1329
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,114,self._ctx)
                if la_ == 1:
                    self.state = 1328
                    self.coordinate_frame()


                self.state = 1331
                self.laneID_parameter()
                self.state = 1332
                self.match(AVScenariosParser.T__21)
                self.state = 1333
                self.match(AVScenariosParser.T__14)
                self.state = 1334
                self.match(AVScenariosParser.T__1)
                self.state = 1335
                self.real_value_expression(0)
                self.state = 1336
                self.match(AVScenariosParser.T__13)
                self.state = 1337
                self.real_value_expression(0)
                self.state = 1338
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 14:
                localctx = AVScenariosParser.Assign_special_case_of_coordinateContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 1340
                self.identifier()
                self.state = 1341
                self.match(AVScenariosParser.T__67)
                self.state = 1342
                self.coordinate_frame()
                self.state = 1343
                self.identifier()
                pass

            elif la_ == 15:
                localctx = AVScenariosParser.Assign_headingContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 1345
                self.identifier()
                self.state = 1346
                self.match(AVScenariosParser.T__67)
                self.state = 1347
                self.heading()
                pass

            elif la_ == 16:
                localctx = AVScenariosParser.Assign_general_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 1349
                self.identifier()
                self.state = 1350
                self.match(AVScenariosParser.T__67)
                self.state = 1351
                self.general_type()
                pass

            elif la_ == 17:
                localctx = AVScenariosParser.Assign_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 1353
                self.identifier()
                self.state = 1354
                self.match(AVScenariosParser.T__67)
                self.state = 1355
                self.color()
                pass

            elif la_ == 18:
                localctx = AVScenariosParser.Assign_npcContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 1357
                self.identifier()
                self.state = 1358
                self.match(AVScenariosParser.T__67)
                self.state = 1359
                self.npc_vehicle()
                pass

            elif la_ == 19:
                localctx = AVScenariosParser.Assign_uniform_motionContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 1361
                self.identifier()
                self.state = 1362
                self.match(AVScenariosParser.T__67)
                self.state = 1363
                self.uniform_motion()
                pass

            elif la_ == 20:
                localctx = AVScenariosParser.Assign_waypoint_motionContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 1365
                self.identifier()
                self.state = 1366
                self.match(AVScenariosParser.T__67)
                self.state = 1367
                self.waypoint_motion()
                pass

            elif la_ == 21:
                localctx = AVScenariosParser.Assign_state_listContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 1369
                self.identifier()
                self.state = 1370
                self.match(AVScenariosParser.T__67)
                self.state = 1371
                self.state_list()
                pass

            elif la_ == 22:
                localctx = AVScenariosParser.Assign_variablesContext(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 1373
                self.identifier()
                self.state = 1374
                self.match(AVScenariosParser.T__67)
                self.state = 1375
                self.match(AVScenariosParser.T__8)
                self.state = 1376
                self.identifier()
                self.state = 1381
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==AVScenariosParser.T__13:
                    self.state = 1377
                    self.match(AVScenariosParser.T__13)
                    self.state = 1378
                    self.identifier()
                    self.state = 1383
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1384
                self.match(AVScenariosParser.T__10)
                pass

            elif la_ == 23:
                localctx = AVScenariosParser.Assign_pedestriansContext(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 1386
                self.identifier()
                self.state = 1387
                self.match(AVScenariosParser.T__67)
                self.state = 1388
                self.pedestrians()
                pass

            elif la_ == 24:
                localctx = AVScenariosParser.Assign_npcsContext(self, localctx)
                self.enterOuterAlt(localctx, 24)
                self.state = 1390
                self.identifier()
                self.state = 1391
                self.match(AVScenariosParser.T__67)
                self.state = 1392
                self.npc_vehicles()
                pass

            elif la_ == 25:
                localctx = AVScenariosParser.Assign_obstaclesContext(self, localctx)
                self.enterOuterAlt(localctx, 25)
                self.state = 1394
                self.identifier()
                self.state = 1395
                self.match(AVScenariosParser.T__67)
                self.state = 1396
                self.obstacles()
                pass

            elif la_ == 26:
                localctx = AVScenariosParser.Assign_weatherContext(self, localctx)
                self.enterOuterAlt(localctx, 26)
                self.state = 1398
                self.identifier()
                self.state = 1399
                self.match(AVScenariosParser.T__67)
                self.state = 1400
                self.weather()
                pass

            elif la_ == 27:
                localctx = AVScenariosParser.Assign_trafficContext(self, localctx)
                self.enterOuterAlt(localctx, 27)
                self.state = 1402
                self.identifier()
                self.state = 1403
                self.match(AVScenariosParser.T__67)
                self.state = 1404
                self.traffic()
                pass

            elif la_ == 28:
                localctx = AVScenariosParser.Assign_pedContext(self, localctx)
                self.enterOuterAlt(localctx, 28)
                self.state = 1406
                self.identifier()
                self.state = 1407
                self.match(AVScenariosParser.T__67)
                self.state = 1408
                self.pedestrian()
                pass

            elif la_ == 29:
                localctx = AVScenariosParser.Assign_obsContext(self, localctx)
                self.enterOuterAlt(localctx, 29)
                self.state = 1410
                self.identifier()
                self.state = 1411
                self.match(AVScenariosParser.T__67)
                self.state = 1412
                self.obstacle()
                pass

            elif la_ == 30:
                localctx = AVScenariosParser.Assign_shapeContext(self, localctx)
                self.enterOuterAlt(localctx, 30)
                self.state = 1414
                self.identifier()
                self.state = 1415
                self.match(AVScenariosParser.T__67)
                self.state = 1416
                self.shape()
                pass

            elif la_ == 31:
                localctx = AVScenariosParser.Assign_envContext(self, localctx)
                self.enterOuterAlt(localctx, 31)
                self.state = 1418
                self.identifier()
                self.state = 1419
                self.match(AVScenariosParser.T__67)
                self.state = 1420
                self.env()
                pass

            elif la_ == 32:
                localctx = AVScenariosParser.Assign_timeContext(self, localctx)
                self.enterOuterAlt(localctx, 32)
                self.state = 1422
                self.identifier()
                self.state = 1423
                self.match(AVScenariosParser.T__67)
                self.state = 1424
                self.time()
                pass

            elif la_ == 33:
                localctx = AVScenariosParser.Assign_weather_stmtContext(self, localctx)
                self.enterOuterAlt(localctx, 33)
                self.state = 1426
                self.identifier()
                self.state = 1427
                self.match(AVScenariosParser.T__67)
                self.state = 1428
                self.weather_statement()
                pass

            elif la_ == 34:
                localctx = AVScenariosParser.Assign_weather_discreteContext(self, localctx)
                self.enterOuterAlt(localctx, 34)
                self.state = 1430
                self.identifier()
                self.state = 1431
                self.match(AVScenariosParser.T__67)
                self.state = 1432
                self.weather_discrete_level()
                pass

            elif la_ == 35:
                localctx = AVScenariosParser.Assign_intersectionContext(self, localctx)
                self.enterOuterAlt(localctx, 35)
                self.state = 1434
                self.identifier()
                self.state = 1435
                self.match(AVScenariosParser.T__67)
                self.state = 1436
                self.meta_intersection_traffic()
                pass

            elif la_ == 36:
                localctx = AVScenariosParser.Assign_speed_limitContext(self, localctx)
                self.enterOuterAlt(localctx, 36)
                self.state = 1438
                self.identifier()
                self.state = 1439
                self.match(AVScenariosParser.T__67)
                self.state = 1440
                self.speed_limitation()
                pass

            elif la_ == 37:
                localctx = AVScenariosParser.Assign_traceContext(self, localctx)
                self.enterOuterAlt(localctx, 37)
                self.state = 1442
                self.trace_assignment()
                pass

            elif la_ == 38:
                localctx = AVScenariosParser.Assign_distance_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 38)
                self.state = 1443
                self.identifier()
                self.state = 1444
                self.match(AVScenariosParser.T__67)
                self.state = 1445
                self.distance_statement()
                pass

            elif la_ == 39:
                localctx = AVScenariosParser.Assignperception_difference_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 39)
                self.state = 1447
                self.identifier()
                self.state = 1448
                self.match(AVScenariosParser.T__67)
                self.state = 1449
                self.perception_difference_statement()
                pass

            elif la_ == 40:
                localctx = AVScenariosParser.Assign_velocity_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 40)
                self.state = 1451
                self.identifier()
                self.state = 1452
                self.match(AVScenariosParser.T__67)
                self.state = 1453
                self.velocity_statement()
                pass

            elif la_ == 41:
                localctx = AVScenariosParser.Assign_speed_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 41)
                self.state = 1455
                self.identifier()
                self.state = 1456
                self.match(AVScenariosParser.T__67)
                self.state = 1457
                self.speed_statement()
                pass

            elif la_ == 42:
                localctx = AVScenariosParser.Assign_acceleration_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 42)
                self.state = 1459
                self.identifier()
                self.state = 1460
                self.match(AVScenariosParser.T__67)
                self.state = 1461
                self.acceleration_statement()
                pass

            elif la_ == 43:
                localctx = AVScenariosParser.Assign_operator_related_assignmentsContext(self, localctx)
                self.enterOuterAlt(localctx, 43)
                self.state = 1463
                self.identifier()
                self.state = 1464
                self.match(AVScenariosParser.T__67)
                self.state = 1465
                self.operator_related_assignments()
                pass

            elif la_ == 44:
                localctx = AVScenariosParser.Assign_general_assertion_to_varContext(self, localctx)
                self.enterOuterAlt(localctx, 44)
                self.state = 1467
                self.identifier()
                self.state = 1468
                self.match(AVScenariosParser.T__67)
                self.state = 1469
                self.general_assertion(0)
                pass

            elif la_ == 45:
                localctx = AVScenariosParser.Assign_general_assertionContext(self, localctx)
                self.enterOuterAlt(localctx, 45)
                self.state = 1471
                self.trace_identifier()
                self.state = 1472
                self.match(AVScenariosParser.T__91)
                self.state = 1473
                self.general_assertion(0)
                pass

            elif la_ == 46:
                localctx = AVScenariosParser.Assign_agent_groundContext(self, localctx)
                self.enterOuterAlt(localctx, 46)
                self.state = 1475
                self.identifier()
                self.state = 1476
                self.match(AVScenariosParser.T__67)
                self.state = 1477
                self.agent_ground_truth()
                pass

            elif la_ == 47:
                localctx = AVScenariosParser.Assign_ego_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 47)
                self.state = 1479
                self.identifier()
                self.state = 1480
                self.match(AVScenariosParser.T__67)
                self.state = 1481
                self.ego_state()
                pass

            elif la_ == 48:
                localctx = AVScenariosParser.Assign_agent_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 48)
                self.state = 1483
                self.identifier()
                self.state = 1484
                self.match(AVScenariosParser.T__67)
                self.state = 1485
                self.agent_state()
                pass

            elif la_ == 49:
                localctx = AVScenariosParser.Assign_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 49)
                self.state = 1487
                self.identifier()
                self.state = 1488
                self.match(AVScenariosParser.T__67)
                self.state = 1489
                self.speed()
                pass

            elif la_ == 50:
                localctx = AVScenariosParser.Assign_position_range_extensionContext(self, localctx)
                self.enterOuterAlt(localctx, 50)
                self.state = 1491
                self.identifier()
                self.state = 1492
                self.match(AVScenariosParser.T__67)
                self.state = 1493
                self.position()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Variable_name(self):
            return self.getToken(AVScenariosParser.Variable_name, 0)

        def getRuleIndex(self):
            return AVScenariosParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = AVScenariosParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1497
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)) | (1 << (AVScenariosParser.T__81 - 65)) | (1 << (AVScenariosParser.T__83 - 65)) | (1 << (AVScenariosParser.T__84 - 65)) | (1 << (AVScenariosParser.T__85 - 65)) | (1 << (AVScenariosParser.T__92 - 65)) | (1 << (AVScenariosParser.T__93 - 65)) | (1 << (AVScenariosParser.Variable_name - 65)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arithmetic_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_arithmetic_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmetic_operator" ):
                listener.enterArithmetic_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmetic_operator" ):
                listener.exitArithmetic_operator(self)




    def arithmetic_operator(self):

        localctx = AVScenariosParser.Arithmetic_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_arithmetic_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1499
            _la = self._input.LA(1)
            if not(((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & ((1 << (AVScenariosParser.T__94 - 95)) | (1 << (AVScenariosParser.T__95 - 95)) | (1 << (AVScenariosParser.T__96 - 95)) | (1 << (AVScenariosParser.T__97 - 95)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[1] = self.string_expression_sempred
        self._predicates[2] = self.real_value_expression_sempred
        self._predicates[3] = self.coordinate_expression_sempred
        self._predicates[43] = self.multi_npc_vehicles_sempred
        self._predicates[54] = self.multi_states_sempred
        self._predicates[57] = self.multiple_pedestrians_sempred
        self._predicates[68] = self.multiple_obstacles_sempred
        self._predicates[85] = self.multi_weathers_sempred
        self._predicates[99] = self.lane_traffic_sempred
        self._predicates[111] = self.atom_statement_overall_sempred
        self._predicates[133] = self.general_assertion_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def string_expression_sempred(self, localctx:String_expressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def real_value_expression_sempred(self, localctx:Real_value_expressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 2)
         

    def coordinate_expression_sempred(self, localctx:Coordinate_expressionContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 2)
         

    def multi_npc_vehicles_sempred(self, localctx:Multi_npc_vehiclesContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 1)
         

    def multi_states_sempred(self, localctx:Multi_statesContext, predIndex:int):
            if predIndex == 7:
                return self.precpred(self._ctx, 2)
         

    def multiple_pedestrians_sempred(self, localctx:Multiple_pedestriansContext, predIndex:int):
            if predIndex == 8:
                return self.precpred(self._ctx, 1)
         

    def multiple_obstacles_sempred(self, localctx:Multiple_obstaclesContext, predIndex:int):
            if predIndex == 9:
                return self.precpred(self._ctx, 1)
         

    def multi_weathers_sempred(self, localctx:Multi_weathersContext, predIndex:int):
            if predIndex == 10:
                return self.precpred(self._ctx, 1)
         

    def lane_traffic_sempred(self, localctx:Lane_trafficContext, predIndex:int):
            if predIndex == 11:
                return self.precpred(self._ctx, 1)
         

    def atom_statement_overall_sempred(self, localctx:Atom_statement_overallContext, predIndex:int):
            if predIndex == 12:
                return self.precpred(self._ctx, 2)
         

    def general_assertion_sempred(self, localctx:General_assertionContext, predIndex:int):
            if predIndex == 13:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 2)
         




