# Generated from AVScenarios.g4 by ANTLR 4.7.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
from typing.io import TextIO
import sys

def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u009d")
        buf.write("\u0643\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084")
        buf.write("\t\u0084\4\u0085\t\u0085\4\u0086\t\u0086\4\u0087\t\u0087")
        buf.write("\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a\4\u008b")
        buf.write("\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e")
        buf.write("\3\2\3\2\5\2\u011f\n\2\3\3\3\3\3\3\5\3\u0124\n\3\3\3\3")
        buf.write("\3\3\3\7\3\u0129\n\3\f\3\16\3\u012c\13\3\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\3\4\5\4\u0135\n\4\3\4\3\4\3\4\3\4\3\4\3\4\3")
        buf.write("\4\3\4\3\4\7\4\u0140\n\4\f\4\16\4\u0143\13\4\3\5\3\5\3")
        buf.write("\5\3\5\3\5\3\5\3\5\5\5\u014c\n\5\3\5\3\5\3\5\3\5\3\5\3")
        buf.write("\5\7\5\u0154\n\5\f\5\16\5\u0157\13\5\3\6\3\6\3\6\3\6\3")
        buf.write("\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\6\3\7\3\7")
        buf.write("\3\7\3\7\5\7\u016d\n\7\3\b\3\b\3\b\3\b\5\b\u0173\n\b\3")
        buf.write("\t\3\t\3\t\3\t\5\t\u0179\n\t\3\n\3\n\3\n\3\n\3\n\3\13")
        buf.write("\3\13\3\f\3\f\5\f\u0184\n\f\3\r\3\r\3\r\3\r\3\r\3\16\3")
        buf.write("\16\3\16\3\16\3\16\5\16\u0190\n\16\3\17\3\17\5\17\u0194")
        buf.write("\n\17\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u019e")
        buf.write("\n\20\3\20\3\20\5\20\u01a2\n\20\3\20\3\20\5\20\u01a6\n")
        buf.write("\20\3\21\5\21\u01a9\n\21\3\21\3\21\3\21\3\21\3\21\5\21")
        buf.write("\u01b0\n\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3\21\3")
        buf.write("\21\3\21\3\21\3\21\3\21\3\21\5\21\u01c0\n\21\3\22\3\22")
        buf.write("\3\22\5\22\u01c5\n\22\3\23\3\23\5\23\u01c9\n\23\3\24\3")
        buf.write("\24\5\24\u01cd\n\24\3\25\3\25\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\5\25\u01d7\n\25\3\26\5\26\u01da\n\26\3\26\3\26\3")
        buf.write("\27\3\27\5\27\u01e0\n\27\3\30\3\30\3\31\3\31\3\31\5\31")
        buf.write("\u01e7\n\31\3\32\3\32\3\32\3\32\3\32\3\32\3\32\5\32\u01f0")
        buf.write("\n\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32\3\32")
        buf.write("\3\32\3\32\3\32\3\32\3\32\5\32\u0201\n\32\3\33\3\33\5")
        buf.write("\33\u0205\n\33\3\34\3\34\3\35\3\35\5\35\u020b\n\35\3\36")
        buf.write("\3\36\3\36\3\36\5\36\u0211\n\36\3\36\3\36\3\36\3\36\3")
        buf.write("\36\5\36\u0218\n\36\3\36\3\36\3\36\3\36\5\36\u021e\n\36")
        buf.write("\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\5\36\u0229")
        buf.write("\n\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36\3\36")
        buf.write("\3\36\5\36\u0236\n\36\5\36\u0238\n\36\3\37\3\37\5\37\u023c")
        buf.write("\n\37\3 \3 \3!\3!\3!\3!\3!\3!\5!\u0246\n!\3\"\3\"\5\"")
        buf.write("\u024a\n\"\3#\3#\3#\3#\3#\3#\3#\3#\5#\u0254\n#\3#\3#\5")
        buf.write("#\u0258\n#\3$\3$\5$\u025c\n$\3%\3%\5%\u0260\n%\3&\3&\3")
        buf.write("\'\3\'\3\'\3\'\3\'\3\'\3\'\5\'\u026b\n\'\3(\3(\5(\u026f")
        buf.write("\n(\3)\3)\5)\u0273\n)\3*\3*\3*\3*\3*\5*\u027a\n*\3+\3")
        buf.write("+\3,\3,\3,\3,\3-\3-\3-\3-\3-\3-\7-\u0288\n-\f-\16-\u028b")
        buf.write("\13-\3.\3.\3.\3.\3.\3/\3/\5/\u0294\n/\3\60\3\60\3\60\3")
        buf.write("\60\3\60\3\60\3\60\3\60\5\60\u029e\n\60\3\60\3\60\5\60")
        buf.write("\u02a2\n\60\3\60\3\60\5\60\u02a6\n\60\5\60\u02a8\n\60")
        buf.write("\3\61\3\61\5\61\u02ac\n\61\3\62\3\62\5\62\u02b0\n\62\3")
        buf.write("\63\3\63\3\63\3\63\3\63\3\64\3\64\5\64\u02b9\n\64\3\65")
        buf.write("\3\65\3\65\3\65\3\65\3\66\3\66\5\66\u02c2\n\66\3\67\3")
        buf.write("\67\3\67\3\67\38\38\38\38\38\38\78\u02ce\n8\f8\168\u02d1")
        buf.write("\138\39\39\39\39\39\39\59\u02d9\n9\3:\3:\3:\3:\3;\3;\3")
        buf.write(";\3;\3;\3;\7;\u02e5\n;\f;\16;\u02e8\13;\3<\3<\5<\u02ec")
        buf.write("\n<\3=\3=\3=\3=\3=\3>\3>\3>\3>\3>\3>\3>\3>\5>\u02fb\n")
        buf.write(">\3>\3>\5>\u02ff\n>\3>\3>\5>\u0303\n>\5>\u0305\n>\3?\3")
        buf.write("?\5?\u0309\n?\3@\3@\5@\u030d\n@\3A\3A\3A\5A\u0312\nA\3")
        buf.write("B\3B\3B\3B\3B\3B\3C\3C\5C\u031c\nC\3D\3D\3E\3E\3E\3E\3")
        buf.write("F\3F\3F\3F\3F\3F\7F\u032a\nF\fF\16F\u032d\13F\3G\3G\5")
        buf.write("G\u0331\nG\3H\3H\3H\3H\3H\3I\3I\3I\5I\u033b\nI\3J\3J\5")
        buf.write("J\u033f\nJ\3K\3K\3K\3K\5K\u0345\nK\3L\3L\3L\3L\3L\3L\3")
        buf.write("M\3M\3M\3M\3M\3M\3M\3M\3M\3M\3N\3N\3N\3N\3N\3N\3N\3N\3")
        buf.write("N\3N\3O\3O\3O\3O\3O\3O\3O\3O\3O\3O\3P\3P\3P\3P\5P\u036f")
        buf.write("\nP\3Q\3Q\3Q\3Q\3Q\3R\3R\3R\3R\3S\3S\5S\u037c\nS\3T\3")
        buf.write("T\5T\u0380\nT\3U\3U\3V\3V\3V\3V\3W\3W\3W\3W\3W\3W\7W\u038e")
        buf.write("\nW\fW\16W\u0391\13W\3X\3X\5X\u0395\nX\3Y\3Y\3Y\3Y\3Y")
        buf.write("\3Y\3Y\3Y\5Y\u039f\nY\3Z\3Z\3Z\3Z\3Z\5Z\u03a6\nZ\3[\3")
        buf.write("[\5[\u03aa\n[\3\\\3\\\5\\\u03ae\n\\\3]\3]\3]\5]\u03b3")
        buf.write("\n]\3^\3^\3^\3^\3_\3_\3_\3_\3`\3`\3`\7`\u03c0\n`\f`\16")
        buf.write("`\u03c3\13`\3a\3a\5a\u03c7\na\3b\3b\3b\3b\3b\3b\3b\3b")
        buf.write("\3b\3b\3b\3c\3c\5c\u03d6\nc\3d\5d\u03d9\nd\3d\3d\3e\3")
        buf.write("e\3e\3e\3e\3e\7e\u03e3\ne\fe\16e\u03e6\13e\3f\3f\5f\u03ea")
        buf.write("\nf\3g\3g\3g\3g\3g\3g\3g\3h\3h\5h\u03f5\nh\3i\3i\3i\3")
        buf.write("i\3i\3i\3j\3j\3j\3j\3j\3j\3j\3j\3k\3k\3l\3l\3m\3m\3m\3")
        buf.write("m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3m\3")
        buf.write("m\3m\3m\5m\u0421\nm\3n\3n\3n\3n\3n\3n\3n\3n\5n\u042b\n")
        buf.write("n\3o\3o\3p\3p\3q\3q\3q\3q\3q\3q\3q\5q\u0438\nq\3q\3q\3")
        buf.write("q\3q\7q\u043e\nq\fq\16q\u0441\13q\3r\3r\3r\3r\3r\3r\3")
        buf.write("r\5r\u044a\nr\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3")
        buf.write("s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3")
        buf.write("s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3")
        buf.write("s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\3s\5s\u0489\ns\3t\3t\3")
        buf.write("t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3t\3")
        buf.write("t\3t\3t\3t\3t\3t\3t\3t\5t\u04a7\nt\3u\3u\3u\3u\3u\3u\3")
        buf.write("u\3v\3v\3v\3v\3v\5v\u04b5\nv\3w\3w\5w\u04b9\nw\3x\3x\3")
        buf.write("x\3x\3x\3y\3y\5y\u04c2\ny\3z\3z\3z\3z\3z\3z\3z\3z\3{\3")
        buf.write("{\5{\u04ce\n{\3|\3|\3|\3|\3|\3|\3|\3|\3}\3}\3}\3}\3}\3")
        buf.write("}\3}\3~\3~\3~\3~\3~\3~\3~\3\177\3\177\3\177\3\177\3\177")
        buf.write("\5\177\u04eb\n\177\3\u0080\3\u0080\5\u0080\u04ef\n\u0080")
        buf.write("\3\u0081\3\u0081\3\u0082\3\u0082\3\u0082\3\u0082\3\u0082")
        buf.write("\3\u0082\3\u0082\3\u0083\3\u0083\3\u0083\3\u0083\3\u0083")
        buf.write("\5\u0083\u04ff\n\u0083\3\u0084\3\u0084\3\u0084\3\u0084")
        buf.write("\3\u0084\3\u0084\3\u0084\3\u0085\3\u0085\3\u0085\3\u0085")
        buf.write("\3\u0085\5\u0085\u050d\n\u0085\3\u0086\3\u0086\3\u0087")
        buf.write("\3\u0087\3\u0088\3\u0088\3\u0088\3\u0088\3\u0089\3\u0089")
        buf.write("\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089")
        buf.write("\3\u0089\3\u0089\3\u0089\3\u0089\5\u0089\u0524\n\u0089")
        buf.write("\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089")
        buf.write("\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089\7\u0089")
        buf.write("\u0533\n\u0089\f\u0089\16\u0089\u0536\13\u0089\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\5\u008a\u053c\n\u008a\3\u008b")
        buf.write("\3\u008b\3\u008b\7\u008b\u0541\n\u008b\f\u008b\16\u008b")
        buf.write("\u0544\13\u008b\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\5\u008c\u057e\n\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\5\u008c\u0587")
        buf.write("\n\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\5\u008c")
        buf.write("\u058e\n\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\5\u008c\u0597\n\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\7\u008c\u05c9\n\u008c")
        buf.write("\f\u008c\16\u008c\u05cc\13\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\5\u008c\u063d\n\u008c\3\u008d")
        buf.write("\3\u008d\3\u008e\3\u008e\3\u008e\2\r\4\6\bXnt\u008a\u00ac")
        buf.write("\u00c8\u00e0\u0110\u008f\2\4\6\b\n\f\16\20\22\24\26\30")
        buf.write("\32\34\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`b")
        buf.write("dfhjlnprtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c")
        buf.write("\u008e\u0090\u0092\u0094\u0096\u0098\u009a\u009c\u009e")
        buf.write("\u00a0\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae\u00b0")
        buf.write("\u00b2\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0\u00c2")
        buf.write("\u00c4\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4")
        buf.write("\u00d6\u00d8\u00da\u00dc\u00de\u00e0\u00e2\u00e4\u00e6")
        buf.write("\u00e8\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4\u00f6\u00f8")
        buf.write("\u00fa\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108\u010a")
        buf.write("\u010c\u010e\u0110\u0112\u0114\u0116\u0118\u011a\2\b\3")
        buf.write("\2\7\b\4\2\3\3\t\t\3\2\26\27\3\2HM\16\2\n\n\16\17\23\25")
        buf.write("\32$*\6499CDGG\u0085\u0085\u0087\u0089\u008f\u0090\u0096")
        buf.write("\u0096\3\2\u0091\u0094\2\u06d0\2\u011c\3\2\2\2\4\u0123")
        buf.write("\3\2\2\2\6\u0134\3\2\2\2\b\u014b\3\2\2\2\n\u0158\3\2\2")
        buf.write("\2\f\u016c\3\2\2\2\16\u0172\3\2\2\2\20\u0178\3\2\2\2\22")
        buf.write("\u017a\3\2\2\2\24\u017f\3\2\2\2\26\u0183\3\2\2\2\30\u0185")
        buf.write("\3\2\2\2\32\u018a\3\2\2\2\34\u0193\3\2\2\2\36\u01a5\3")
        buf.write("\2\2\2 \u01bf\3\2\2\2\"\u01c4\3\2\2\2$\u01c8\3\2\2\2&")
        buf.write("\u01cc\3\2\2\2(\u01d6\3\2\2\2*\u01d9\3\2\2\2,\u01df\3")
        buf.write("\2\2\2.\u01e1\3\2\2\2\60\u01e6\3\2\2\2\62\u0200\3\2\2")
        buf.write("\2\64\u0204\3\2\2\2\66\u0206\3\2\2\28\u020a\3\2\2\2:\u0237")
        buf.write("\3\2\2\2<\u023b\3\2\2\2>\u023d\3\2\2\2@\u0245\3\2\2\2")
        buf.write("B\u0249\3\2\2\2D\u0257\3\2\2\2F\u025b\3\2\2\2H\u025f\3")
        buf.write("\2\2\2J\u0261\3\2\2\2L\u026a\3\2\2\2N\u026e\3\2\2\2P\u0272")
        buf.write("\3\2\2\2R\u0279\3\2\2\2T\u027b\3\2\2\2V\u027d\3\2\2\2")
        buf.write("X\u0281\3\2\2\2Z\u028c\3\2\2\2\\\u0293\3\2\2\2^\u02a7")
        buf.write("\3\2\2\2`\u02ab\3\2\2\2b\u02af\3\2\2\2d\u02b1\3\2\2\2")
        buf.write("f\u02b8\3\2\2\2h\u02ba\3\2\2\2j\u02c1\3\2\2\2l\u02c3\3")
        buf.write("\2\2\2n\u02c7\3\2\2\2p\u02d8\3\2\2\2r\u02da\3\2\2\2t\u02de")
        buf.write("\3\2\2\2v\u02eb\3\2\2\2x\u02ed\3\2\2\2z\u0304\3\2\2\2")
        buf.write("|\u0308\3\2\2\2~\u030c\3\2\2\2\u0080\u0311\3\2\2\2\u0082")
        buf.write("\u0313\3\2\2\2\u0084\u031b\3\2\2\2\u0086\u031d\3\2\2\2")
        buf.write("\u0088\u031f\3\2\2\2\u008a\u0323\3\2\2\2\u008c\u0330\3")
        buf.write("\2\2\2\u008e\u0332\3\2\2\2\u0090\u0337\3\2\2\2\u0092\u033e")
        buf.write("\3\2\2\2\u0094\u0344\3\2\2\2\u0096\u0346\3\2\2\2\u0098")
        buf.write("\u034c\3\2\2\2\u009a\u0356\3\2\2\2\u009c\u0360\3\2\2\2")
        buf.write("\u009e\u036e\3\2\2\2\u00a0\u0370\3\2\2\2\u00a2\u0375\3")
        buf.write("\2\2\2\u00a4\u037b\3\2\2\2\u00a6\u037f\3\2\2\2\u00a8\u0381")
        buf.write("\3\2\2\2\u00aa\u0383\3\2\2\2\u00ac\u0387\3\2\2\2\u00ae")
        buf.write("\u0394\3\2\2\2\u00b0\u039e\3\2\2\2\u00b2\u03a5\3\2\2\2")
        buf.write("\u00b4\u03a9\3\2\2\2\u00b6\u03ad\3\2\2\2\u00b8\u03b2\3")
        buf.write("\2\2\2\u00ba\u03b4\3\2\2\2\u00bc\u03b8\3\2\2\2\u00be\u03bc")
        buf.write("\3\2\2\2\u00c0\u03c6\3\2\2\2\u00c2\u03c8\3\2\2\2\u00c4")
        buf.write("\u03d5\3\2\2\2\u00c6\u03d8\3\2\2\2\u00c8\u03dc\3\2\2\2")
        buf.write("\u00ca\u03e9\3\2\2\2\u00cc\u03eb\3\2\2\2\u00ce\u03f4\3")
        buf.write("\2\2\2\u00d0\u03f6\3\2\2\2\u00d2\u03fc\3\2\2\2\u00d4\u0404")
        buf.write("\3\2\2\2\u00d6\u0406\3\2\2\2\u00d8\u0420\3\2\2\2\u00da")
        buf.write("\u042a\3\2\2\2\u00dc\u042c\3\2\2\2\u00de\u042e\3\2\2\2")
        buf.write("\u00e0\u0437\3\2\2\2\u00e2\u0449\3\2\2\2\u00e4\u0488\3")
        buf.write("\2\2\2\u00e6\u04a6\3\2\2\2\u00e8\u04a8\3\2\2\2\u00ea\u04b4")
        buf.write("\3\2\2\2\u00ec\u04b8\3\2\2\2\u00ee\u04ba\3\2\2\2\u00f0")
        buf.write("\u04c1\3\2\2\2\u00f2\u04c3\3\2\2\2\u00f4\u04cd\3\2\2\2")
        buf.write("\u00f6\u04cf\3\2\2\2\u00f8\u04d7\3\2\2\2\u00fa\u04de\3")
        buf.write("\2\2\2\u00fc\u04ea\3\2\2\2\u00fe\u04ee\3\2\2\2\u0100\u04f0")
        buf.write("\3\2\2\2\u0102\u04f2\3\2\2\2\u0104\u04fe\3\2\2\2\u0106")
        buf.write("\u0500\3\2\2\2\u0108\u050c\3\2\2\2\u010a\u050e\3\2\2\2")
        buf.write("\u010c\u0510\3\2\2\2\u010e\u0512\3\2\2\2\u0110\u0523\3")
        buf.write("\2\2\2\u0112\u053b\3\2\2\2\u0114\u0542\3\2\2\2\u0116\u063c")
        buf.write("\3\2\2\2\u0118\u063e\3\2\2\2\u011a\u0640\3\2\2\2\u011c")
        buf.write("\u011e\5\u0114\u008b\2\u011d\u011f\7\2\2\3\u011e\u011d")
        buf.write("\3\2\2\2\u011e\u011f\3\2\2\2\u011f\3\3\2\2\2\u0120\u0121")
        buf.write("\b\3\1\2\u0121\u0124\7\u0095\2\2\u0122\u0124\5\u0118\u008d")
        buf.write("\2\u0123\u0120\3\2\2\2\u0123\u0122\3\2\2\2\u0124\u012a")
        buf.write("\3\2\2\2\u0125\u0126\f\4\2\2\u0126\u0127\7\3\2\2\u0127")
        buf.write("\u0129\5\4\3\5\u0128\u0125\3\2\2\2\u0129\u012c\3\2\2\2")
        buf.write("\u012a\u0128\3\2\2\2\u012a\u012b\3\2\2\2\u012b\5\3\2\2")
        buf.write("\2\u012c\u012a\3\2\2\2\u012d\u012e\b\4\1\2\u012e\u0135")
        buf.write("\5*\26\2\u012f\u0130\7\4\2\2\u0130\u0131\5\6\4\2\u0131")
        buf.write("\u0132\7\5\2\2\u0132\u0135\3\2\2\2\u0133\u0135\5\u0118")
        buf.write("\u008d\2\u0134\u012d\3\2\2\2\u0134\u012f\3\2\2\2\u0134")
        buf.write("\u0133\3\2\2\2\u0135\u0141\3\2\2\2\u0136\u0137\f\6\2\2")
        buf.write("\u0137\u0138\7\6\2\2\u0138\u0140\5\6\4\7\u0139\u013a\f")
        buf.write("\5\2\2\u013a\u013b\t\2\2\2\u013b\u0140\5\6\4\6\u013c\u013d")
        buf.write("\f\4\2\2\u013d\u013e\t\3\2\2\u013e\u0140\5\6\4\5\u013f")
        buf.write("\u0136\3\2\2\2\u013f\u0139\3\2\2\2\u013f\u013c\3\2\2\2")
        buf.write("\u0140\u0143\3\2\2\2\u0141\u013f\3\2\2\2\u0141\u0142\3")
        buf.write("\2\2\2\u0142\7\3\2\2\2\u0143\u0141\3\2\2\2\u0144\u0145")
        buf.write("\b\5\1\2\u0145\u014c\5\62\32\2\u0146\u0147\7\4\2\2\u0147")
        buf.write("\u0148\5\b\5\2\u0148\u0149\7\5\2\2\u0149\u014c\3\2\2\2")
        buf.write("\u014a\u014c\5\u0118\u008d\2\u014b\u0144\3\2\2\2\u014b")
        buf.write("\u0146\3\2\2\2\u014b\u014a\3\2\2\2\u014c\u0155\3\2\2\2")
        buf.write("\u014d\u014e\f\5\2\2\u014e\u014f\t\2\2\2\u014f\u0154\5")
        buf.write("\b\5\6\u0150\u0151\f\4\2\2\u0151\u0152\t\3\2\2\u0152\u0154")
        buf.write("\5\b\5\5\u0153\u014d\3\2\2\2\u0153\u0150\3\2\2\2\u0154")
        buf.write("\u0157\3\2\2\2\u0155\u0153\3\2\2\2\u0155\u0156\3\2\2\2")
        buf.write("\u0156\t\3\2\2\2\u0157\u0155\3\2\2\2\u0158\u0159\7\n\2")
        buf.write("\2\u0159\u015a\7\13\2\2\u015a\u015b\5\22\n\2\u015b\u015c")
        buf.write("\7\f\2\2\u015c\u015d\5\26\f\2\u015d\u015e\7\f\2\2\u015e")
        buf.write("\u015f\5\f\7\2\u015f\u0160\7\f\2\2\u0160\u0161\5\16\b")
        buf.write("\2\u0161\u0162\7\f\2\2\u0162\u0163\5\20\t\2\u0163\u0164")
        buf.write("\7\f\2\2\u0164\u0165\5\u009eP\2\u0165\u0166\7\f\2\2\u0166")
        buf.write("\u0167\7\r\2\2\u0167\13\3\2\2\2\u0168\u016d\5\u0118\u008d")
        buf.write("\2\u0169\u016d\5V,\2\u016a\u016b\7\13\2\2\u016b\u016d")
        buf.write("\7\r\2\2\u016c\u0168\3\2\2\2\u016c\u0169\3\2\2\2\u016c")
        buf.write("\u016a\3\2\2\2\u016d\r\3\2\2\2\u016e\u0173\5\u0118\u008d")
        buf.write("\2\u016f\u0173\5r:\2\u0170\u0171\7\13\2\2\u0171\u0173")
        buf.write("\7\r\2\2\u0172\u016e\3\2\2\2\u0172\u016f\3\2\2\2\u0172")
        buf.write("\u0170\3\2\2\2\u0173\17\3\2\2\2\u0174\u0179\5\u0118\u008d")
        buf.write("\2\u0175\u0179\5\u0088E\2\u0176\u0177\7\13\2\2\u0177\u0179")
        buf.write("\7\r\2\2\u0178\u0174\3\2\2\2\u0178\u0175\3\2\2\2\u0178")
        buf.write("\u0176\3\2\2\2\u0179\21\3\2\2\2\u017a\u017b\7\16\2\2\u017b")
        buf.write("\u017c\7\4\2\2\u017c\u017d\5\24\13\2\u017d\u017e\7\5\2")
        buf.write("\2\u017e\23\3\2\2\2\u017f\u0180\5\4\3\2\u0180\25\3\2\2")
        buf.write("\2\u0181\u0184\5\30\r\2\u0182\u0184\5\u0118\u008d\2\u0183")
        buf.write("\u0181\3\2\2\2\u0183\u0182\3\2\2\2\u0184\27\3\2\2\2\u0185")
        buf.write("\u0186\7\17\2\2\u0186\u0187\7\4\2\2\u0187\u0188\5\32\16")
        buf.write("\2\u0188\u0189\7\5\2\2\u0189\31\3\2\2\2\u018a\u018b\5")
        buf.write("\34\17\2\u018b\u018c\7\20\2\2\u018c\u018f\5\34\17\2\u018d")
        buf.write("\u018e\7\20\2\2\u018e\u0190\5B\"\2\u018f\u018d\3\2\2\2")
        buf.write("\u018f\u0190\3\2\2\2\u0190\33\3\2\2\2\u0191\u0194\5\36")
        buf.write("\20\2\u0192\u0194\5\u0118\u008d\2\u0193\u0191\3\2\2\2")
        buf.write("\u0193\u0192\3\2\2\2\u0194\35\3\2\2\2\u0195\u0196\7\4")
        buf.write("\2\2\u0196\u0197\5$\23\2\u0197\u0198\7\5\2\2\u0198\u01a6")
        buf.write("\3\2\2\2\u0199\u019a\7\4\2\2\u019a\u019b\5$\23\2\u019b")
        buf.write("\u019d\7\20\2\2\u019c\u019e\58\35\2\u019d\u019c\3\2\2")
        buf.write("\2\u019d\u019e\3\2\2\2\u019e\u01a1\3\2\2\2\u019f\u01a0")
        buf.write("\7\20\2\2\u01a0\u01a2\5&\24\2\u01a1\u019f\3\2\2\2\u01a1")
        buf.write("\u01a2\3\2\2\2\u01a2\u01a3\3\2\2\2\u01a3\u01a4\7\5\2\2")
        buf.write("\u01a4\u01a6\3\2\2\2\u01a5\u0195\3\2\2\2\u01a5\u0199\3")
        buf.write("\2\2\2\u01a6\37\3\2\2\2\u01a7\u01a9\5\"\22\2\u01a8\u01a7")
        buf.write("\3\2\2\2\u01a8\u01a9\3\2\2\2\u01a9\u01aa\3\2\2\2\u01aa")
        buf.write("\u01c0\5\62\32\2\u01ab\u01ac\5\"\22\2\u01ac\u01ad\5\b")
        buf.write("\5\2\u01ad\u01c0\3\2\2\2\u01ae\u01b0\5\"\22\2\u01af\u01ae")
        buf.write("\3\2\2\2\u01af\u01b0\3\2\2\2\u01b0\u01b1\3\2\2\2\u01b1")
        buf.write("\u01b2\5\b\5\2\u01b2\u01b3\7\21\2\2\u01b3\u01b4\7\4\2")
        buf.write("\2\u01b4\u01b5\5\6\4\2\u01b5\u01b6\7\20\2\2\u01b6\u01b7")
        buf.write("\5\6\4\2\u01b7\u01b8\7\5\2\2\u01b8\u01b9\7\22\2\2\u01b9")
        buf.write("\u01ba\7\4\2\2\u01ba\u01bb\5\6\4\2\u01bb\u01bc\7\20\2")
        buf.write("\2\u01bc\u01bd\5\6\4\2\u01bd\u01be\7\5\2\2\u01be\u01c0")
        buf.write("\3\2\2\2\u01bf\u01a8\3\2\2\2\u01bf\u01ab\3\2\2\2\u01bf")
        buf.write("\u01af\3\2\2\2\u01c0!\3\2\2\2\u01c1\u01c5\7\23\2\2\u01c2")
        buf.write("\u01c5\7\24\2\2\u01c3\u01c5\7\25\2\2\u01c4\u01c1\3\2\2")
        buf.write("\2\u01c4\u01c2\3\2\2\2\u01c4\u01c3\3\2\2\2\u01c5#\3\2")
        buf.write("\2\2\u01c6\u01c9\5 \21\2\u01c7\u01c9\5\u0118\u008d\2\u01c8")
        buf.write("\u01c6\3\2\2\2\u01c8\u01c7\3\2\2\2\u01c9%\3\2\2\2\u01ca")
        buf.write("\u01cd\5(\25\2\u01cb\u01cd\5\u0118\u008d\2\u01cc\u01ca")
        buf.write("\3\2\2\2\u01cc\u01cb\3\2\2\2\u01cd\'\3\2\2\2\u01ce\u01d7")
        buf.write("\5\6\4\2\u01cf\u01d0\7\21\2\2\u01d0\u01d1\7\4\2\2\u01d1")
        buf.write("\u01d2\5\6\4\2\u01d2\u01d3\7\20\2\2\u01d3\u01d4\5\6\4")
        buf.write("\2\u01d4\u01d5\7\5\2\2\u01d5\u01d7\3\2\2\2\u01d6\u01ce")
        buf.write("\3\2\2\2\u01d6\u01cf\3\2\2\2\u01d7)\3\2\2\2\u01d8\u01da")
        buf.write("\t\3\2\2\u01d9\u01d8\3\2\2\2\u01d9\u01da\3\2\2\2\u01da")
        buf.write("\u01db\3\2\2\2\u01db\u01dc\5,\27\2\u01dc+\3\2\2\2\u01dd")
        buf.write("\u01e0\5.\30\2\u01de\u01e0\5\60\31\2\u01df\u01dd\3\2\2")
        buf.write("\2\u01df\u01de\3\2\2\2\u01e0-\3\2\2\2\u01e1\u01e2\7\u0099")
        buf.write("\2\2\u01e2/\3\2\2\2\u01e3\u01e7\7\u009a\2\2\u01e4\u01e7")
        buf.write("\7\26\2\2\u01e5\u01e7\7\27\2\2\u01e6\u01e3\3\2\2\2\u01e6")
        buf.write("\u01e4\3\2\2\2\u01e6\u01e5\3\2\2\2\u01e7\61\3\2\2\2\u01e8")
        buf.write("\u01e9\7\4\2\2\u01e9\u01ea\5\6\4\2\u01ea\u01eb\7\20\2")
        buf.write("\2\u01eb\u01ef\5\6\4\2\u01ec\u01ed\7\20\2\2\u01ed\u01ee")
        buf.write("\t\3\2\2\u01ee\u01f0\5\6\4\2\u01ef\u01ec\3\2\2\2\u01ef")
        buf.write("\u01f0\3\2\2\2\u01f0\u01f1\3\2\2\2\u01f1\u01f2\7\5\2\2")
        buf.write("\u01f2\u0201\3\2\2\2\u01f3\u01f4\5\64\33\2\u01f4\u01f5")
        buf.write("\7\30\2\2\u01f5\u01f6\5\6\4\2\u01f6\u0201\3\2\2\2\u01f7")
        buf.write("\u01f8\5\64\33\2\u01f8\u01f9\7\30\2\2\u01f9\u01fa\7\21")
        buf.write("\2\2\u01fa\u01fb\7\4\2\2\u01fb\u01fc\5\6\4\2\u01fc\u01fd")
        buf.write("\7\20\2\2\u01fd\u01fe\5\6\4\2\u01fe\u01ff\7\5\2\2\u01ff")
        buf.write("\u0201\3\2\2\2\u0200\u01e8\3\2\2\2\u0200\u01f3\3\2\2\2")
        buf.write("\u0200\u01f7\3\2\2\2\u0201\63\3\2\2\2\u0202\u0205\5\u0118")
        buf.write("\u008d\2\u0203\u0205\5\66\34\2\u0204\u0202\3\2\2\2\u0204")
        buf.write("\u0203\3\2\2\2\u0205\65\3\2\2\2\u0206\u0207\5\4\3\2\u0207")
        buf.write("\67\3\2\2\2\u0208\u020b\5\u0118\u008d\2\u0209\u020b\5")
        buf.write(":\36\2\u020a\u0208\3\2\2\2\u020a\u0209\3\2\2\2\u020b9")
        buf.write("\3\2\2\2\u020c\u020d\5\6\4\2\u020d\u0210\5<\37\2\u020e")
        buf.write("\u020f\7\31\2\2\u020f\u0211\5> \2\u0210\u020e\3\2\2\2")
        buf.write("\u0210\u0211\3\2\2\2\u0211\u0238\3\2\2\2\u0212\u0213\5")
        buf.write("\6\4\2\u0213\u0214\7\32\2\2\u0214\u0217\5<\37\2\u0215")
        buf.write("\u0216\7\31\2\2\u0216\u0218\5> \2\u0217\u0215\3\2\2\2")
        buf.write("\u0217\u0218\3\2\2\2\u0218\u0238\3\2\2\2\u0219\u021a\7")
        buf.write("\32\2\2\u021a\u021d\5<\37\2\u021b\u021c\7\31\2\2\u021c")
        buf.write("\u021e\5> \2\u021d\u021b\3\2\2\2\u021d\u021e\3\2\2\2\u021e")
        buf.write("\u0238\3\2\2\2\u021f\u0220\7\21\2\2\u0220\u0221\7\4\2")
        buf.write("\2\u0221\u0222\5\6\4\2\u0222\u0223\7\20\2\2\u0223\u0224")
        buf.write("\5\6\4\2\u0224\u0225\7\5\2\2\u0225\u0228\5<\37\2\u0226")
        buf.write("\u0227\7\31\2\2\u0227\u0229\5> \2\u0228\u0226\3\2\2\2")
        buf.write("\u0228\u0229\3\2\2\2\u0229\u0238\3\2\2\2\u022a\u022b\7")
        buf.write("\21\2\2\u022b\u022c\7\4\2\2\u022c\u022d\5\6\4\2\u022d")
        buf.write("\u022e\7\32\2\2\u022e\u022f\7\20\2\2\u022f\u0230\5\6\4")
        buf.write("\2\u0230\u0231\7\32\2\2\u0231\u0232\7\5\2\2\u0232\u0235")
        buf.write("\5<\37\2\u0233\u0234\7\31\2\2\u0234\u0236\5> \2\u0235")
        buf.write("\u0233\3\2\2\2\u0235\u0236\3\2\2\2\u0236\u0238\3\2\2\2")
        buf.write("\u0237\u020c\3\2\2\2\u0237\u0212\3\2\2\2\u0237\u0219\3")
        buf.write("\2\2\2\u0237\u021f\3\2\2\2\u0237\u022a\3\2\2\2\u0238;")
        buf.write("\3\2\2\2\u0239\u023c\7\33\2\2\u023a\u023c\7\34\2\2\u023b")
        buf.write("\u0239\3\2\2\2\u023b\u023a\3\2\2\2\u023c=\3\2\2\2\u023d")
        buf.write("\u023e\5@!\2\u023e?\3\2\2\2\u023f\u0240\5\64\33\2\u0240")
        buf.write("\u0241\7\30\2\2\u0241\u0242\5\6\4\2\u0242\u0246\3\2\2")
        buf.write("\2\u0243\u0246\7\35\2\2\u0244\u0246\5\u0118\u008d\2\u0245")
        buf.write("\u023f\3\2\2\2\u0245\u0243\3\2\2\2\u0245\u0244\3\2\2\2")
        buf.write("\u0246A\3\2\2\2\u0247\u024a\5\u0118\u008d\2\u0248\u024a")
        buf.write("\5D#\2\u0249\u0247\3\2\2\2\u0249\u0248\3\2\2\2\u024aC")
        buf.write("\3\2\2\2\u024b\u024c\7\4\2\2\u024c\u024d\5F$\2\u024d\u024e")
        buf.write("\7\5\2\2\u024e\u0258\3\2\2\2\u024f\u0250\7\4\2\2\u0250")
        buf.write("\u0251\5F$\2\u0251\u0253\7\20\2\2\u0252\u0254\5N(\2\u0253")
        buf.write("\u0252\3\2\2\2\u0253\u0254\3\2\2\2\u0254\u0255\3\2\2\2")
        buf.write("\u0255\u0256\7\5\2\2\u0256\u0258\3\2\2\2\u0257\u024b\3")
        buf.write("\2\2\2\u0257\u024f\3\2\2\2\u0258E\3\2\2\2\u0259\u025c")
        buf.write("\5\u0118\u008d\2\u025a\u025c\5H%\2\u025b\u0259\3\2\2\2")
        buf.write("\u025b\u025a\3\2\2\2\u025cG\3\2\2\2\u025d\u0260\5J&\2")
        buf.write("\u025e\u0260\5L\'\2\u025f\u025d\3\2\2\2\u025f\u025e\3")
        buf.write("\2\2\2\u0260I\3\2\2\2\u0261\u0262\5\4\3\2\u0262K\3\2\2")
        buf.write("\2\u0263\u026b\7\36\2\2\u0264\u026b\7\37\2\2\u0265\u026b")
        buf.write("\7 \2\2\u0266\u026b\7!\2\2\u0267\u026b\7\"\2\2\u0268\u026b")
        buf.write("\7#\2\2\u0269\u026b\7$\2\2\u026a\u0263\3\2\2\2\u026a\u0264")
        buf.write("\3\2\2\2\u026a\u0265\3\2\2\2\u026a\u0266\3\2\2\2\u026a")
        buf.write("\u0267\3\2\2\2\u026a\u0268\3\2\2\2\u026a\u0269\3\2\2\2")
        buf.write("\u026bM\3\2\2\2\u026c\u026f\5\u0118\u008d\2\u026d\u026f")
        buf.write("\5P)\2\u026e\u026c\3\2\2\2\u026e\u026d\3\2\2\2\u026fO")
        buf.write("\3\2\2\2\u0270\u0273\5R*\2\u0271\u0273\5T+\2\u0272\u0270")
        buf.write("\3\2\2\2\u0272\u0271\3\2\2\2\u0273Q\3\2\2\2\u0274\u027a")
        buf.write("\7%\2\2\u0275\u027a\7&\2\2\u0276\u027a\7\'\2\2\u0277\u027a")
        buf.write("\7(\2\2\u0278\u027a\7)\2\2\u0279\u0274\3\2\2\2\u0279\u0275")
        buf.write("\3\2\2\2\u0279\u0276\3\2\2\2\u0279\u0277\3\2\2\2\u0279")
        buf.write("\u0278\3\2\2\2\u027aS\3\2\2\2\u027b\u027c\7\u0098\2\2")
        buf.write("\u027cU\3\2\2\2\u027d\u027e\7\13\2\2\u027e\u027f\5X-\2")
        buf.write("\u027f\u0280\7\r\2\2\u0280W\3\2\2\2\u0281\u0282\b-\1\2")
        buf.write("\u0282\u0283\5\\/\2\u0283\u0289\3\2\2\2\u0284\u0285\f")
        buf.write("\3\2\2\u0285\u0286\7\20\2\2\u0286\u0288\5\\/\2\u0287\u0284")
        buf.write("\3\2\2\2\u0288\u028b\3\2\2\2\u0289\u0287\3\2\2\2\u0289")
        buf.write("\u028a\3\2\2\2\u028aY\3\2\2\2\u028b\u0289\3\2\2\2\u028c")
        buf.write("\u028d\7*\2\2\u028d\u028e\7\4\2\2\u028e\u028f\5^\60\2")
        buf.write("\u028f\u0290\7\5\2\2\u0290[\3\2\2\2\u0291\u0294\5Z.\2")
        buf.write("\u0292\u0294\5\u0118\u008d\2\u0293\u0291\3\2\2\2\u0293")
        buf.write("\u0292\3\2\2\2\u0294]\3\2\2\2\u0295\u02a8\5\34\17\2\u0296")
        buf.write("\u0297\5\34\17\2\u0297\u0298\7\20\2\2\u0298\u0299\5`\61")
        buf.write("\2\u0299\u02a8\3\2\2\2\u029a\u029b\5\34\17\2\u029b\u029d")
        buf.write("\7\20\2\2\u029c\u029e\5`\61\2\u029d\u029c\3\2\2\2\u029d")
        buf.write("\u029e\3\2\2\2\u029e\u029f\3\2\2\2\u029f\u02a1\7\20\2")
        buf.write("\2\u02a0\u02a2\5\34\17\2\u02a1\u02a0\3\2\2\2\u02a1\u02a2")
        buf.write("\3\2\2\2\u02a2\u02a5\3\2\2\2\u02a3\u02a4\7\20\2\2\u02a4")
        buf.write("\u02a6\5B\"\2\u02a5\u02a3\3\2\2\2\u02a5\u02a6\3\2\2\2")
        buf.write("\u02a6\u02a8\3\2\2\2\u02a7\u0295\3\2\2\2\u02a7\u0296\3")
        buf.write("\2\2\2\u02a7\u029a\3\2\2\2\u02a8_\3\2\2\2\u02a9\u02ac")
        buf.write("\5b\62\2\u02aa\u02ac\5\u0118\u008d\2\u02ab\u02a9\3\2\2")
        buf.write("\2\u02ab\u02aa\3\2\2\2\u02aca\3\2\2\2\u02ad\u02b0\5d\63")
        buf.write("\2\u02ae\u02b0\5h\65\2\u02af\u02ad\3\2\2\2\u02af\u02ae")
        buf.write("\3\2\2\2\u02b0c\3\2\2\2\u02b1\u02b2\5f\64\2\u02b2\u02b3")
        buf.write("\7\4\2\2\u02b3\u02b4\5\34\17\2\u02b4\u02b5\7\5\2\2\u02b5")
        buf.write("e\3\2\2\2\u02b6\u02b9\7+\2\2\u02b7\u02b9\7,\2\2\u02b8")
        buf.write("\u02b6\3\2\2\2\u02b8\u02b7\3\2\2\2\u02b9g\3\2\2\2\u02ba")
        buf.write("\u02bb\5p9\2\u02bb\u02bc\7\4\2\2\u02bc\u02bd\5j\66\2\u02bd")
        buf.write("\u02be\7\5\2\2\u02bei\3\2\2\2\u02bf\u02c2\5\u0118\u008d")
        buf.write("\2\u02c0\u02c2\5l\67\2\u02c1\u02bf\3\2\2\2\u02c1\u02c0")
        buf.write("\3\2\2\2\u02c2k\3\2\2\2\u02c3\u02c4\7\4\2\2\u02c4\u02c5")
        buf.write("\5n8\2\u02c5\u02c6\7\5\2\2\u02c6m\3\2\2\2\u02c7\u02c8")
        buf.write("\b8\1\2\u02c8\u02c9\5\34\17\2\u02c9\u02cf\3\2\2\2\u02ca")
        buf.write("\u02cb\f\4\2\2\u02cb\u02cc\7\20\2\2\u02cc\u02ce\5\34\17")
        buf.write("\2\u02cd\u02ca\3\2\2\2\u02ce\u02d1\3\2\2\2\u02cf\u02cd")
        buf.write("\3\2\2\2\u02cf\u02d0\3\2\2\2\u02d0o\3\2\2\2\u02d1\u02cf")
        buf.write("\3\2\2\2\u02d2\u02d9\7-\2\2\u02d3\u02d9\7.\2\2\u02d4\u02d9")
        buf.write("\7/\2\2\u02d5\u02d9\7\60\2\2\u02d6\u02d9\7\61\2\2\u02d7")
        buf.write("\u02d9\7\62\2\2\u02d8\u02d2\3\2\2\2\u02d8\u02d3\3\2\2")
        buf.write("\2\u02d8\u02d4\3\2\2\2\u02d8\u02d5\3\2\2\2\u02d8\u02d6")
        buf.write("\3\2\2\2\u02d8\u02d7\3\2\2\2\u02d9q\3\2\2\2\u02da\u02db")
        buf.write("\7\13\2\2\u02db\u02dc\5t;\2\u02dc\u02dd\7\r\2\2\u02dd")
        buf.write("s\3\2\2\2\u02de\u02df\b;\1\2\u02df\u02e0\5v<\2\u02e0\u02e6")
        buf.write("\3\2\2\2\u02e1\u02e2\f\3\2\2\u02e2\u02e3\7\20\2\2\u02e3")
        buf.write("\u02e5\5v<\2\u02e4\u02e1\3\2\2\2\u02e5\u02e8\3\2\2\2\u02e6")
        buf.write("\u02e4\3\2\2\2\u02e6\u02e7\3\2\2\2\u02e7u\3\2\2\2\u02e8")
        buf.write("\u02e6\3\2\2\2\u02e9\u02ec\5x=\2\u02ea\u02ec\5\u0118\u008d")
        buf.write("\2\u02eb\u02e9\3\2\2\2\u02eb\u02ea\3\2\2\2\u02ecw\3\2")
        buf.write("\2\2\u02ed\u02ee\7\63\2\2\u02ee\u02ef\7\4\2\2\u02ef\u02f0")
        buf.write("\5z>\2\u02f0\u02f1\7\5\2\2\u02f1y\3\2\2\2\u02f2\u0305")
        buf.write("\5\34\17\2\u02f3\u02f4\5\34\17\2\u02f4\u02f5\7\20\2\2")
        buf.write("\u02f5\u02f6\5|?\2\u02f6\u0305\3\2\2\2\u02f7\u02f8\5\34")
        buf.write("\17\2\u02f8\u02fa\7\20\2\2\u02f9\u02fb\5|?\2\u02fa\u02f9")
        buf.write("\3\2\2\2\u02fa\u02fb\3\2\2\2\u02fb\u02fc\3\2\2\2\u02fc")
        buf.write("\u02fe\7\20\2\2\u02fd\u02ff\5\34\17\2\u02fe\u02fd\3\2")
        buf.write("\2\2\u02fe\u02ff\3\2\2\2\u02ff\u0302\3\2\2\2\u0300\u0301")
        buf.write("\7\20\2\2\u0301\u0303\5\u0080A\2\u0302\u0300\3\2\2\2\u0302")
        buf.write("\u0303\3\2\2\2\u0303\u0305\3\2\2\2\u0304\u02f2\3\2\2\2")
        buf.write("\u0304\u02f3\3\2\2\2\u0304\u02f7\3\2\2\2\u0305{\3\2\2")
        buf.write("\2\u0306\u0309\5~@\2\u0307\u0309\5\u0118\u008d\2\u0308")
        buf.write("\u0306\3\2\2\2\u0308\u0307\3\2\2\2\u0309}\3\2\2\2\u030a")
        buf.write("\u030d\5d\63\2\u030b\u030d\5h\65\2\u030c\u030a\3\2\2\2")
        buf.write("\u030c\u030b\3\2\2\2\u030d\177\3\2\2\2\u030e\u0312\5\u0082")
        buf.write("B\2\u030f\u0312\5\u0118\u008d\2\u0310\u0312\7\u0095\2")
        buf.write("\2\u0311\u030e\3\2\2\2\u0311\u030f\3\2\2\2\u0311\u0310")
        buf.write("\3\2\2\2\u0312\u0081\3\2\2\2\u0313\u0314\7\4\2\2\u0314")
        buf.write("\u0315\5\u0084C\2\u0315\u0316\7\20\2\2\u0316\u0317\5N")
        buf.write("(\2\u0317\u0318\7\5\2\2\u0318\u0083\3\2\2\2\u0319\u031c")
        buf.write("\5\u0118\u008d\2\u031a\u031c\5\u0086D\2\u031b\u0319\3")
        buf.write("\2\2\2\u031b\u031a\3\2\2\2\u031c\u0085\3\2\2\2\u031d\u031e")
        buf.write("\5\6\4\2\u031e\u0087\3\2\2\2\u031f\u0320\7\13\2\2\u0320")
        buf.write("\u0321\5\u008aF\2\u0321\u0322\7\r\2\2\u0322\u0089\3\2")
        buf.write("\2\2\u0323\u0324\bF\1\2\u0324\u0325\5\u008cG\2\u0325\u032b")
        buf.write("\3\2\2\2\u0326\u0327\f\3\2\2\u0327\u0328\7\20\2\2\u0328")
        buf.write("\u032a\5\u008cG\2\u0329\u0326\3\2\2\2\u032a\u032d\3\2")
        buf.write("\2\2\u032b\u0329\3\2\2\2\u032b\u032c\3\2\2\2\u032c\u008b")
        buf.write("\3\2\2\2\u032d\u032b\3\2\2\2\u032e\u0331\5\u008eH\2\u032f")
        buf.write("\u0331\5\u0118\u008d\2\u0330\u032e\3\2\2\2\u0330\u032f")
        buf.write("\3\2\2\2\u0331\u008d\3\2\2\2\u0332\u0333\7\64\2\2\u0333")
        buf.write("\u0334\7\4\2\2\u0334\u0335\5\u0090I\2\u0335\u0336\7\5")
        buf.write("\2\2\u0336\u008f\3\2\2\2\u0337\u033a\5$\23\2\u0338\u0339")
        buf.write("\7\20\2\2\u0339\u033b\5\u0092J\2\u033a\u0338\3\2\2\2\u033a")
        buf.write("\u033b\3\2\2\2\u033b\u0091\3\2\2\2\u033c\u033f\5\u0118")
        buf.write("\u008d\2\u033d\u033f\5\u0094K\2\u033e\u033c\3\2\2\2\u033e")
        buf.write("\u033d\3\2\2\2\u033f\u0093\3\2\2\2\u0340\u0345\5\u0096")
        buf.write("L\2\u0341\u0345\5\u0098M\2\u0342\u0345\5\u009aN\2\u0343")
        buf.write("\u0345\5\u009cO\2\u0344\u0340\3\2\2\2\u0344\u0341\3\2")
        buf.write("\2\2\u0344\u0342\3\2\2\2\u0344\u0343\3\2\2\2\u0345\u0095")
        buf.write("\3\2\2\2\u0346\u0347\7\4\2\2\u0347\u0348\7\65\2\2\u0348")
        buf.write("\u0349\7\20\2\2\u0349\u034a\5\6\4\2\u034a\u034b\7\5\2")
        buf.write("\2\u034b\u0097\3\2\2\2\u034c\u034d\7\4\2\2\u034d\u034e")
        buf.write("\7\66\2\2\u034e\u034f\7\20\2\2\u034f\u0350\5\6\4\2\u0350")
        buf.write("\u0351\7\20\2\2\u0351\u0352\5\6\4\2\u0352\u0353\7\20\2")
        buf.write("\2\u0353\u0354\5\6\4\2\u0354\u0355\7\5\2\2\u0355\u0099")
        buf.write("\3\2\2\2\u0356\u0357\7\4\2\2\u0357\u0358\7\67\2\2\u0358")
        buf.write("\u0359\7\20\2\2\u0359\u035a\5\6\4\2\u035a\u035b\7\20\2")
        buf.write("\2\u035b\u035c\5\6\4\2\u035c\u035d\7\20\2\2\u035d\u035e")
        buf.write("\5\6\4\2\u035e\u035f\7\5\2\2\u035f\u009b\3\2\2\2\u0360")
        buf.write("\u0361\7\4\2\2\u0361\u0362\78\2\2\u0362\u0363\7\20\2\2")
        buf.write("\u0363\u0364\5\6\4\2\u0364\u0365\7\20\2\2\u0365\u0366")
        buf.write("\5\6\4\2\u0366\u0367\7\20\2\2\u0367\u0368\5\6\4\2\u0368")
        buf.write("\u0369\7\5\2\2\u0369\u009d\3\2\2\2\u036a\u036f\5\u0118")
        buf.write("\u008d\2\u036b\u036f\5\u00a0Q\2\u036c\u036d\7\13\2\2\u036d")
        buf.write("\u036f\7\r\2\2\u036e\u036a\3\2\2\2\u036e\u036b\3\2\2\2")
        buf.write("\u036e\u036c\3\2\2\2\u036f\u009f\3\2\2\2\u0370\u0371\7")
        buf.write("9\2\2\u0371\u0372\7\4\2\2\u0372\u0373\5\u00a2R\2\u0373")
        buf.write("\u0374\7\5\2\2\u0374\u00a1\3\2\2\2\u0375\u0376\5\u00a6")
        buf.write("T\2\u0376\u0377\7\20\2\2\u0377\u0378\5\u00a4S\2\u0378")
        buf.write("\u00a3\3\2\2\2\u0379\u037c\5\u0118\u008d\2\u037a\u037c")
        buf.write("\5\u00aaV\2\u037b\u0379\3\2\2\2\u037b\u037a\3\2\2\2\u037c")
        buf.write("\u00a5\3\2\2\2\u037d\u0380\5\u00a8U\2\u037e\u0380\5\u0118")
        buf.write("\u008d\2\u037f\u037d\3\2\2\2\u037f\u037e\3\2\2\2\u0380")
        buf.write("\u00a7\3\2\2\2\u0381\u0382\7\u0097\2\2\u0382\u00a9\3\2")
        buf.write("\2\2\u0383\u0384\7\13\2\2\u0384\u0385\5\u00acW\2\u0385")
        buf.write("\u0386\7\r\2\2\u0386\u00ab\3\2\2\2\u0387\u0388\bW\1\2")
        buf.write("\u0388\u0389\5\u00aeX\2\u0389\u038f\3\2\2\2\u038a\u038b")
        buf.write("\f\3\2\2\u038b\u038c\7\20\2\2\u038c\u038e\5\u00aeX\2\u038d")
        buf.write("\u038a\3\2\2\2\u038e\u0391\3\2\2\2\u038f\u038d\3\2\2\2")
        buf.write("\u038f\u0390\3\2\2\2\u0390\u00ad\3\2\2\2\u0391\u038f\3")
        buf.write("\2\2\2\u0392\u0395\5\u0118\u008d\2\u0393\u0395\5\u00b0")
        buf.write("Y\2\u0394\u0392\3\2\2\2\u0394\u0393\3\2\2\2\u0395\u00af")
        buf.write("\3\2\2\2\u0396\u0397\5\u00b2Z\2\u0397\u0398\7:\2\2\u0398")
        buf.write("\u0399\5\u00b4[\2\u0399\u039f\3\2\2\2\u039a\u039b\5\u00b2")
        buf.write("Z\2\u039b\u039c\7:\2\2\u039c\u039d\5\u00b6\\\2\u039d\u039f")
        buf.write("\3\2\2\2\u039e\u0396\3\2\2\2\u039e\u039a\3\2\2\2\u039f")
        buf.write("\u00b1\3\2\2\2\u03a0\u03a6\7;\2\2\u03a1\u03a6\7<\2\2\u03a2")
        buf.write("\u03a6\7=\2\2\u03a3\u03a6\7>\2\2\u03a4\u03a6\7?\2\2\u03a5")
        buf.write("\u03a0\3\2\2\2\u03a5\u03a1\3\2\2\2\u03a5\u03a2\3\2\2\2")
        buf.write("\u03a5\u03a3\3\2\2\2\u03a5\u03a4\3\2\2\2\u03a6\u00b3\3")
        buf.write("\2\2\2\u03a7\u03aa\5.\30\2\u03a8\u03aa\5\u0118\u008d\2")
        buf.write("\u03a9\u03a7\3\2\2\2\u03a9\u03a8\3\2\2\2\u03aa\u00b5\3")
        buf.write("\2\2\2\u03ab\u03ae\5\u00b8]\2\u03ac\u03ae\5\u0118\u008d")
        buf.write("\2\u03ad\u03ab\3\2\2\2\u03ad\u03ac\3\2\2\2\u03ae\u00b7")
        buf.write("\3\2\2\2\u03af\u03b3\7@\2\2\u03b0\u03b3\7A\2\2\u03b1\u03b3")
        buf.write("\7B\2\2\u03b2\u03af\3\2\2\2\u03b2\u03b0\3\2\2\2\u03b2")
        buf.write("\u03b1\3\2\2\2\u03b3\u00b9\3\2\2\2\u03b4\u03b5\7\13\2")
        buf.write("\2\u03b5\u03b6\5\u00bc_\2\u03b6\u03b7\7\r\2\2\u03b7\u00bb")
        buf.write("\3\2\2\2\u03b8\u03b9\5\u00be`\2\u03b9\u03ba\7\20\2\2\u03ba")
        buf.write("\u03bb\5\u00c8e\2\u03bb\u00bd\3\2\2\2\u03bc\u03c1\5\u00c0")
        buf.write("a\2\u03bd\u03be\7\20\2\2\u03be\u03c0\5\u00c0a\2\u03bf")
        buf.write("\u03bd\3\2\2\2\u03c0\u03c3\3\2\2\2\u03c1\u03bf\3\2\2\2")
        buf.write("\u03c1\u03c2\3\2\2\2\u03c2\u00bf\3\2\2\2\u03c3\u03c1\3")
        buf.write("\2\2\2\u03c4\u03c7\5\u0118\u008d\2\u03c5\u03c7\5\u00c2")
        buf.write("b\2\u03c6\u03c4\3\2\2\2\u03c6\u03c5\3\2\2\2\u03c7\u00c1")
        buf.write("\3\2\2\2\u03c8\u03c9\7C\2\2\u03c9\u03ca\7\4\2\2\u03ca")
        buf.write("\u03cb\5\u00c4c\2\u03cb\u03cc\7\20\2\2\u03cc\u03cd\t\4")
        buf.write("\2\2\u03cd\u03ce\7\20\2\2\u03ce\u03cf\t\4\2\2\u03cf\u03d0")
        buf.write("\7\20\2\2\u03d0\u03d1\t\4\2\2\u03d1\u03d2\7\5\2\2\u03d2")
        buf.write("\u00c3\3\2\2\2\u03d3\u03d6\5\u00c6d\2\u03d4\u03d6\5\u0118")
        buf.write("\u008d\2\u03d5\u03d3\3\2\2\2\u03d5\u03d4\3\2\2\2\u03d6")
        buf.write("\u00c5\3\2\2\2\u03d7\u03d9\t\3\2\2\u03d8\u03d7\3\2\2\2")
        buf.write("\u03d8\u03d9\3\2\2\2\u03d9\u03da\3\2\2\2\u03da\u03db\5")
        buf.write("\60\31\2\u03db\u00c7\3\2\2\2\u03dc\u03dd\be\1\2\u03dd")
        buf.write("\u03de\5\u00caf\2\u03de\u03e4\3\2\2\2\u03df\u03e0\f\3")
        buf.write("\2\2\u03e0\u03e1\7\20\2\2\u03e1\u03e3\5\u00caf\2\u03e2")
        buf.write("\u03df\3\2\2\2\u03e3\u03e6\3\2\2\2\u03e4\u03e2\3\2\2\2")
        buf.write("\u03e4\u03e5\3\2\2\2\u03e5\u00c9\3\2\2\2\u03e6\u03e4\3")
        buf.write("\2\2\2\u03e7\u03ea\5\u00ccg\2\u03e8\u03ea\5\u0118\u008d")
        buf.write("\2\u03e9\u03e7\3\2\2\2\u03e9\u03e8\3\2\2\2\u03ea\u00cb")
        buf.write("\3\2\2\2\u03eb\u03ec\7D\2\2\u03ec\u03ed\7\4\2\2\u03ed")
        buf.write("\u03ee\5\64\33\2\u03ee\u03ef\7\20\2\2\u03ef\u03f0\5\u00ce")
        buf.write("h\2\u03f0\u03f1\7\5\2\2\u03f1\u00cd\3\2\2\2\u03f2\u03f5")
        buf.write("\5\u0118\u008d\2\u03f3\u03f5\5\u00d0i\2\u03f4\u03f2\3")
        buf.write("\2\2\2\u03f4\u03f3\3\2\2\2\u03f5\u00cf\3\2\2\2\u03f6\u03f7")
        buf.write("\7\4\2\2\u03f7\u03f8\5\6\4\2\u03f8\u03f9\7\20\2\2\u03f9")
        buf.write("\u03fa\5\6\4\2\u03fa\u03fb\7\5\2\2\u03fb\u00d1\3\2\2\2")
        buf.write("\u03fc\u03fd\7E\2\2\u03fd\u03fe\5\u0118\u008d\2\u03fe")
        buf.write("\u03ff\7F\2\2\u03ff\u0400\7G\2\2\u0400\u0401\7\4\2\2\u0401")
        buf.write("\u0402\5\u0118\u008d\2\u0402\u0403\7\5\2\2\u0403\u00d3")
        buf.write("\3\2\2\2\u0404\u0405\5\u0118\u008d\2\u0405\u00d5\3\2\2")
        buf.write("\2\u0406\u0407\t\5\2\2\u0407\u00d7\3\2\2\2\u0408\u0421")
        buf.write("\7N\2\2\u0409\u0421\7O\2\2\u040a\u0421\7P\2\2\u040b\u040c")
        buf.write("\7N\2\2\u040c\u040d\7Q\2\2\u040d\u040e\5\u00dco\2\u040e")
        buf.write("\u040f\7\20\2\2\u040f\u0410\5\u00dep\2\u0410\u0411\7R")
        buf.write("\2\2\u0411\u0421\3\2\2\2\u0412\u0413\7O\2\2\u0413\u0414")
        buf.write("\7Q\2\2\u0414\u0415\5\u00dco\2\u0415\u0416\7\20\2\2\u0416")
        buf.write("\u0417\5\u00dep\2\u0417\u0418\7R\2\2\u0418\u0421\3\2\2")
        buf.write("\2\u0419\u041a\7P\2\2\u041a\u041b\7Q\2\2\u041b\u041c\5")
        buf.write("\u00dco\2\u041c\u041d\7\20\2\2\u041d\u041e\5\u00dep\2")
        buf.write("\u041e\u041f\7R\2\2\u041f\u0421\3\2\2\2\u0420\u0408\3")
        buf.write("\2\2\2\u0420\u0409\3\2\2\2\u0420\u040a\3\2\2\2\u0420\u040b")
        buf.write("\3\2\2\2\u0420\u0412\3\2\2\2\u0420\u0419\3\2\2\2\u0421")
        buf.write("\u00d9\3\2\2\2\u0422\u042b\7S\2\2\u0423\u0424\7S\2\2\u0424")
        buf.write("\u0425\7Q\2\2\u0425\u0426\5\u00dco\2\u0426\u0427\7\20")
        buf.write("\2\2\u0427\u0428\5\u00dep\2\u0428\u0429\7R\2\2\u0429\u042b")
        buf.write("\3\2\2\2\u042a\u0422\3\2\2\2\u042a\u0423\3\2\2\2\u042b")
        buf.write("\u00db\3\2\2\2\u042c\u042d\5*\26\2\u042d\u00dd\3\2\2\2")
        buf.write("\u042e\u042f\5*\26\2\u042f\u00df\3\2\2\2\u0430\u0431\b")
        buf.write("q\1\2\u0431\u0438\5\u00e2r\2\u0432\u0433\7\4\2\2\u0433")
        buf.write("\u0434\5\u00e0q\2\u0434\u0435\7\5\2\2\u0435\u0438\3\2")
        buf.write("\2\2\u0436\u0438\5\u0118\u008d\2\u0437\u0430\3\2\2\2\u0437")
        buf.write("\u0432\3\2\2\2\u0437\u0436\3\2\2\2\u0438\u043f\3\2\2\2")
        buf.write("\u0439\u043a\f\4\2\2\u043a\u043b\5\u011a\u008e\2\u043b")
        buf.write("\u043c\5\u00e0q\5\u043c\u043e\3\2\2\2\u043d\u0439\3\2")
        buf.write("\2\2\u043e\u0441\3\2\2\2\u043f\u043d\3\2\2\2\u043f\u0440")
        buf.write("\3\2\2\2\u0440\u00e1\3\2\2\2\u0441\u043f\3\2\2\2\u0442")
        buf.write("\u044a\5\u00e8u\2\u0443\u044a\5\u00f8}\2\u0444\u044a\5")
        buf.write("\u00fa~\2\u0445\u044a\5\u0102\u0082\2\u0446\u044a\5\u0106")
        buf.write("\u0084\2\u0447\u044a\5*\26\2\u0448\u044a\5\u00e6t\2\u0449")
        buf.write("\u0442\3\2\2\2\u0449\u0443\3\2\2\2\u0449\u0444\3\2\2\2")
        buf.write("\u0449\u0445\3\2\2\2\u0449\u0446\3\2\2\2\u0449\u0447\3")
        buf.write("\2\2\2\u0449\u0448\3\2\2\2\u044a\u00e3\3\2\2\2\u044b\u0489")
        buf.write("\7T\2\2\u044c\u0489\7U\2\2\u044d\u0489\7V\2\2\u044e\u0489")
        buf.write("\7W\2\2\u044f\u0489\7X\2\2\u0450\u0489\7Y\2\2\u0451\u0489")
        buf.write("\7Z\2\2\u0452\u0489\7[\2\2\u0453\u0489\7\\\2\2\u0454\u0489")
        buf.write("\7]\2\2\u0455\u0489\7^\2\2\u0456\u0457\7_\2\2\u0457\u0458")
        buf.write("\7\4\2\2\u0458\u0459\5\6\4\2\u0459\u045a\7\5\2\2\u045a")
        buf.write("\u0489\3\2\2\2\u045b\u045c\7`\2\2\u045c\u045d\7\4\2\2")
        buf.write("\u045d\u045e\5\6\4\2\u045e\u045f\7\5\2\2\u045f\u0489\3")
        buf.write("\2\2\2\u0460\u0461\7a\2\2\u0461\u0462\7\4\2\2\u0462\u0463")
        buf.write("\5\6\4\2\u0463\u0464\7\5\2\2\u0464\u0489\3\2\2\2\u0465")
        buf.write("\u0466\7b\2\2\u0466\u0467\7\4\2\2\u0467\u0468\5\6\4\2")
        buf.write("\u0468\u0469\7\5\2\2\u0469\u0489\3\2\2\2\u046a\u0489\7")
        buf.write("c\2\2\u046b\u046c\7d\2\2\u046c\u046d\7\4\2\2\u046d\u046e")
        buf.write("\5\6\4\2\u046e\u046f\7\5\2\2\u046f\u0489\3\2\2\2\u0470")
        buf.write("\u0489\7e\2\2\u0471\u0489\7f\2\2\u0472\u0489\7g\2\2\u0473")
        buf.write("\u0489\7h\2\2\u0474\u0475\7i\2\2\u0475\u0476\7\4\2\2\u0476")
        buf.write("\u0477\5\6\4\2\u0477\u0478\7\5\2\2\u0478\u0489\3\2\2\2")
        buf.write("\u0479\u047a\7j\2\2\u047a\u047b\7\4\2\2\u047b\u047c\5")
        buf.write("\6\4\2\u047c\u047d\7\5\2\2\u047d\u0489\3\2\2\2\u047e\u047f")
        buf.write("\7k\2\2\u047f\u0480\7\4\2\2\u0480\u0481\5\6\4\2\u0481")
        buf.write("\u0482\7\5\2\2\u0482\u0489\3\2\2\2\u0483\u0489\7l\2\2")
        buf.write("\u0484\u0485\7m\2\2\u0485\u0486\5\u00d6l\2\u0486\u0487")
        buf.write("\5\u00a6T\2\u0487\u0489\3\2\2\2\u0488\u044b\3\2\2\2\u0488")
        buf.write("\u044c\3\2\2\2\u0488\u044d\3\2\2\2\u0488\u044e\3\2\2\2")
        buf.write("\u0488\u044f\3\2\2\2\u0488\u0450\3\2\2\2\u0488\u0451\3")
        buf.write("\2\2\2\u0488\u0452\3\2\2\2\u0488\u0453\3\2\2\2\u0488\u0454")
        buf.write("\3\2\2\2\u0488\u0455\3\2\2\2\u0488\u0456\3\2\2\2\u0488")
        buf.write("\u045b\3\2\2\2\u0488\u0460\3\2\2\2\u0488\u0465\3\2\2\2")
        buf.write("\u0488\u046a\3\2\2\2\u0488\u046b\3\2\2\2\u0488\u0470\3")
        buf.write("\2\2\2\u0488\u0471\3\2\2\2\u0488\u0472\3\2\2\2\u0488\u0473")
        buf.write("\3\2\2\2\u0488\u0474\3\2\2\2\u0488\u0479\3\2\2\2\u0488")
        buf.write("\u047e\3\2\2\2\u0488\u0483\3\2\2\2\u0488\u0484\3\2\2\2")
        buf.write("\u0489\u00e5\3\2\2\2\u048a\u04a7\7n\2\2\u048b\u04a7\7")
        buf.write("o\2\2\u048c\u04a7\7p\2\2\u048d\u04a7\7q\2\2\u048e\u04a7")
        buf.write("\7r\2\2\u048f\u04a7\7s\2\2\u0490\u04a7\7t\2\2\u0491\u04a7")
        buf.write("\7u\2\2\u0492\u04a7\7v\2\2\u0493\u04a7\7w\2\2\u0494\u04a7")
        buf.write("\7x\2\2\u0495\u04a7\7y\2\2\u0496\u04a7\7z\2\2\u0497\u04a7")
        buf.write("\7{\2\2\u0498\u04a7\7|\2\2\u0499\u04a7\7}\2\2\u049a\u04a7")
        buf.write("\7~\2\2\u049b\u04a7\7&\2\2\u049c\u04a7\7%\2\2\u049d\u04a7")
        buf.write("\7\177\2\2\u049e\u04a7\7\u0080\2\2\u049f\u04a7\7\u0081")
        buf.write("\2\2\u04a0\u04a7\7\u0082\2\2\u04a1\u04a7\7\u0083\2\2\u04a2")
        buf.write("\u04a7\7>\2\2\u04a3\u04a7\7<\2\2\u04a4\u04a7\7=\2\2\u04a5")
        buf.write("\u04a7\7\u0084\2\2\u04a6\u048a\3\2\2\2\u04a6\u048b\3\2")
        buf.write("\2\2\u04a6\u048c\3\2\2\2\u04a6\u048d\3\2\2\2\u04a6\u048e")
        buf.write("\3\2\2\2\u04a6\u048f\3\2\2\2\u04a6\u0490\3\2\2\2\u04a6")
        buf.write("\u0491\3\2\2\2\u04a6\u0492\3\2\2\2\u04a6\u0493\3\2\2\2")
        buf.write("\u04a6\u0494\3\2\2\2\u04a6\u0495\3\2\2\2\u04a6\u0496\3")
        buf.write("\2\2\2\u04a6\u0497\3\2\2\2\u04a6\u0498\3\2\2\2\u04a6\u0499")
        buf.write("\3\2\2\2\u04a6\u049a\3\2\2\2\u04a6\u049b\3\2\2\2\u04a6")
        buf.write("\u049c\3\2\2\2\u04a6\u049d\3\2\2\2\u04a6\u049e\3\2\2\2")
        buf.write("\u04a6\u049f\3\2\2\2\u04a6\u04a0\3\2\2\2\u04a6\u04a1\3")
        buf.write("\2\2\2\u04a6\u04a2\3\2\2\2\u04a6\u04a3\3\2\2\2\u04a6\u04a4")
        buf.write("\3\2\2\2\u04a6\u04a5\3\2\2\2\u04a7\u00e7\3\2\2\2\u04a8")
        buf.write("\u04a9\7\u0085\2\2\u04a9\u04aa\7\4\2\2\u04aa\u04ab\5\u00ea")
        buf.write("v\2\u04ab\u04ac\7\20\2\2\u04ac\u04ad\5\u00eav\2\u04ad")
        buf.write("\u04ae\7\5\2\2\u04ae\u00e9\3\2\2\2\u04af\u04b5\5\u00ee")
        buf.write("x\2\u04b0\u04b5\5\u00f2z\2\u04b1\u04b5\5\u00f6|\2\u04b2")
        buf.write("\u04b5\5 \21\2\u04b3\u04b5\5\u0118\u008d\2\u04b4\u04af")
        buf.write("\3\2\2\2\u04b4\u04b0\3\2\2\2\u04b4\u04b1\3\2\2\2\u04b4")
        buf.write("\u04b2\3\2\2\2\u04b4\u04b3\3\2\2\2\u04b5\u00eb\3\2\2\2")
        buf.write("\u04b6\u04b9\5\u0118\u008d\2\u04b7\u04b9\5\u00eex\2\u04b8")
        buf.write("\u04b6\3\2\2\2\u04b8\u04b7\3\2\2\2\u04b9\u00ed\3\2\2\2")
        buf.write("\u04ba\u04bb\5\u00d4k\2\u04bb\u04bc\7Q\2\2\u04bc\u04bd")
        buf.write("\7\u0086\2\2\u04bd\u04be\7R\2\2\u04be\u00ef\3\2\2\2\u04bf")
        buf.write("\u04c2\5\u0118\u008d\2\u04c0\u04c2\5\u00f2z\2\u04c1\u04bf")
        buf.write("\3\2\2\2\u04c1\u04c0\3\2\2\2\u04c2\u00f1\3\2\2\2\u04c3")
        buf.write("\u04c4\5\u00d4k\2\u04c4\u04c5\7Q\2\2\u04c5\u04c6\7\u0087")
        buf.write("\2\2\u04c6\u04c7\7R\2\2\u04c7\u04c8\7Q\2\2\u04c8\u04c9")
        buf.write("\5\u0118\u008d\2\u04c9\u04ca\7R\2\2\u04ca\u00f3\3\2\2")
        buf.write("\2\u04cb\u04ce\5\u0118\u008d\2\u04cc\u04ce\5\u00f6|\2")
        buf.write("\u04cd\u04cb\3\2\2\2\u04cd\u04cc\3\2\2\2\u04ce\u00f5\3")
        buf.write("\2\2\2\u04cf\u04d0\5\u00d4k\2\u04d0\u04d1\7Q\2\2\u04d1")
        buf.write("\u04d2\7\u0088\2\2\u04d2\u04d3\7R\2\2\u04d3\u04d4\7Q\2")
        buf.write("\2\u04d4\u04d5\5\u0118\u008d\2\u04d5\u04d6\7R\2\2\u04d6")
        buf.write("\u00f7\3\2\2\2\u04d7\u04d8\7\u0089\2\2\u04d8\u04d9\7\4")
        buf.write("\2\2\u04d9\u04da\5\u00f0y\2\u04da\u04db\7\20\2\2\u04db")
        buf.write("\u04dc\5\u00f4{\2\u04dc\u04dd\7\5\2\2\u04dd\u00f9\3\2")
        buf.write("\2\2\u04de\u04df\7\u008a\2\2\u04df\u04e0\7\4\2\2\u04e0")
        buf.write("\u04e1\5\u00fc\177\2\u04e1\u04e2\7\20\2\2\u04e2\u04e3")
        buf.write("\5\u00fc\177\2\u04e3\u04e4\7\5\2\2\u04e4\u00fb\3\2\2\2")
        buf.write("\u04e5\u04eb\5\u0118\u008d\2\u04e6\u04eb\5\u00eex\2\u04e7")
        buf.write("\u04eb\5\u00f2z\2\u04e8\u04eb\5\u00f6|\2\u04e9\u04eb\5")
        buf.write("\u0100\u0081\2\u04ea\u04e5\3\2\2\2\u04ea\u04e6\3\2\2\2")
        buf.write("\u04ea\u04e7\3\2\2\2\u04ea\u04e8\3\2\2\2\u04ea\u04e9\3")
        buf.write("\2\2\2\u04eb\u00fd\3\2\2\2\u04ec\u04ef\5\u0118\u008d\2")
        buf.write("\u04ed\u04ef\5\u0100\u0081\2\u04ee\u04ec\3\2\2\2\u04ee")
        buf.write("\u04ed\3\2\2\2\u04ef\u00ff\3\2\2\2\u04f0\u04f1\5\b\5\2")
        buf.write("\u04f1\u0101\3\2\2\2\u04f2\u04f3\7\u008b\2\2\u04f3\u04f4")
        buf.write("\7\4\2\2\u04f4\u04f5\5\u0104\u0083\2\u04f5\u04f6\7\20")
        buf.write("\2\2\u04f6\u04f7\5\u0104\u0083\2\u04f7\u04f8\7\5\2\2\u04f8")
        buf.write("\u0103\3\2\2\2\u04f9\u04ff\5\u0118\u008d\2\u04fa\u04ff")
        buf.write("\5\u00eex\2\u04fb\u04ff\5\u00f2z\2\u04fc\u04ff\5\u00f6")
        buf.write("|\2\u04fd\u04ff\5(\25\2\u04fe\u04f9\3\2\2\2\u04fe\u04fa")
        buf.write("\3\2\2\2\u04fe\u04fb\3\2\2\2\u04fe\u04fc\3\2\2\2\u04fe")
        buf.write("\u04fd\3\2\2\2\u04ff\u0105\3\2\2\2\u0500\u0501\7r\2\2")
        buf.write("\u0501\u0502\7\4\2\2\u0502\u0503\5\u0108\u0085\2\u0503")
        buf.write("\u0504\7\20\2\2\u0504\u0505\5\u0108\u0085\2\u0505\u0506")
        buf.write("\7\5\2\2\u0506\u0107\3\2\2\2\u0507\u050d\5\u0118\u008d")
        buf.write("\2\u0508\u050d\5\u00eex\2\u0509\u050d\5\u00f2z\2\u050a")
        buf.write("\u050d\5\u00f6|\2\u050b\u050d\5\u010a\u0086\2\u050c\u0507")
        buf.write("\3\2\2\2\u050c\u0508\3\2\2\2\u050c\u0509\3\2\2\2\u050c")
        buf.write("\u050a\3\2\2\2\u050c\u050b\3\2\2\2\u050d\u0109\3\2\2\2")
        buf.write("\u050e\u050f\5\b\5\2\u050f\u010b\3\2\2\2\u0510\u0511\5")
        buf.write("\u00e0q\2\u0511\u010d\3\2\2\2\u0512\u0513\5\u010c\u0087")
        buf.write("\2\u0513\u0514\5\u00d6l\2\u0514\u0515\5\u010c\u0087\2")
        buf.write("\u0515\u010f\3\2\2\2\u0516\u0517\b\u0089\1\2\u0517\u0524")
        buf.write("\5\u00e4s\2\u0518\u0524\5\u010e\u0088\2\u0519\u051a\7")
        buf.write("\4\2\2\u051a\u051b\5\u0110\u0089\2\u051b\u051c\7\5\2\2")
        buf.write("\u051c\u0524\3\2\2\2\u051d\u051e\7\u008c\2\2\u051e\u0524")
        buf.write("\5\u0110\u0089\t\u051f\u0520\5\u00d8m\2\u0520\u0521\5")
        buf.write("\u0110\u0089\b\u0521\u0524\3\2\2\2\u0522\u0524\5\u0118")
        buf.write("\u008d\2\u0523\u0516\3\2\2\2\u0523\u0518\3\2\2\2\u0523")
        buf.write("\u0519\3\2\2\2\u0523\u051d\3\2\2\2\u0523\u051f\3\2\2\2")
        buf.write("\u0523\u0522\3\2\2\2\u0524\u0534\3\2\2\2\u0525\u0526\f")
        buf.write("\7\2\2\u0526\u0527\5\u00dan\2\u0527\u0528\5\u0110\u0089")
        buf.write("\b\u0528\u0533\3\2\2\2\u0529\u052a\f\6\2\2\u052a\u052b")
        buf.write("\7\22\2\2\u052b\u0533\5\u0110\u0089\7\u052c\u052d\f\5")
        buf.write("\2\2\u052d\u052e\7\u008d\2\2\u052e\u0533\5\u0110\u0089")
        buf.write("\6\u052f\u0530\f\4\2\2\u0530\u0531\7\30\2\2\u0531\u0533")
        buf.write("\5\u0110\u0089\5\u0532\u0525\3\2\2\2\u0532\u0529\3\2\2")
        buf.write("\2\u0532\u052c\3\2\2\2\u0532\u052f\3\2\2\2\u0533\u0536")
        buf.write("\3\2\2\2\u0534\u0532\3\2\2\2\u0534\u0535\3\2\2\2\u0535")
        buf.write("\u0111\3\2\2\2\u0536\u0534\3\2\2\2\u0537\u053c\5\4\3\2")
        buf.write("\u0538\u053c\5\6\4\2\u0539\u053c\5\b\5\2\u053a\u053c\5")
        buf.write("\u00e0q\2\u053b\u0537\3\2\2\2\u053b\u0538\3\2\2\2\u053b")
        buf.write("\u0539\3\2\2\2\u053b\u053a\3\2\2\2\u053c\u0113\3\2\2\2")
        buf.write("\u053d\u053e\5\u0116\u008c\2\u053e\u053f\7\f\2\2\u053f")
        buf.write("\u0541\3\2\2\2\u0540\u053d\3\2\2\2\u0541\u0544\3\2\2\2")
        buf.write("\u0542\u0540\3\2\2\2\u0542\u0543\3\2\2\2\u0543\u0115\3")
        buf.write("\2\2\2\u0544\u0542\3\2\2\2\u0545\u0546\5\u0118\u008d\2")
        buf.write("\u0546\u0547\7F\2\2\u0547\u0548\5\n\6\2\u0548\u063d\3")
        buf.write("\2\2\2\u0549\u054a\5\u0118\u008d\2\u054a\u054b\7F\2\2")
        buf.write("\u054b\u054c\5\30\r\2\u054c\u063d\3\2\2\2\u054d\u054e")
        buf.write("\5\u0118\u008d\2\u054e\u054f\7F\2\2\u054f\u0550\7\4\2")
        buf.write("\2\u0550\u0551\5\u0118\u008d\2\u0551\u0552\7\5\2\2\u0552")
        buf.write("\u063d\3\2\2\2\u0553\u0554\5\u0118\u008d\2\u0554\u0555")
        buf.write("\7F\2\2\u0555\u0556\7\4\2\2\u0556\u0557\5\u0118\u008d")
        buf.write("\2\u0557\u0558\7\20\2\2\u0558\u0559\5\u0118\u008d\2\u0559")
        buf.write("\u055a\7\5\2\2\u055a\u063d\3\2\2\2\u055b\u055c\5\u0118")
        buf.write("\u008d\2\u055c\u055d\7F\2\2\u055d\u055e\7\4\2\2\u055e")
        buf.write("\u055f\5\u0118\u008d\2\u055f\u0560\7\20\2\2\u0560\u0561")
        buf.write("\5\u0118\u008d\2\u0561\u0562\7\20\2\2\u0562\u0563\5\u0118")
        buf.write("\u008d\2\u0563\u0564\7\5\2\2\u0564\u063d\3\2\2\2\u0565")
        buf.write("\u0566\5\u0118\u008d\2\u0566\u0567\7F\2\2\u0567\u0568")
        buf.write("\5\36\20\2\u0568\u063d\3\2\2\2\u0569\u056a\5\u0118\u008d")
        buf.write("\2\u056a\u056b\7F\2\2\u056b\u056c\5D#\2\u056c\u063d\3")
        buf.write("\2\2\2\u056d\u056e\5\u0118\u008d\2\u056e\u056f\7F\2\2")
        buf.write("\u056f\u0570\5l\67\2\u0570\u063d\3\2\2\2\u0571\u0572\5")
        buf.write("\u0118\u008d\2\u0572\u0573\7F\2\2\u0573\u0574\5\u0082")
        buf.write("B\2\u0574\u063d\3\2\2\2\u0575\u0576\5\u0118\u008d\2\u0576")
        buf.write("\u0577\7F\2\2\u0577\u0578\5\"\22\2\u0578\u0579\5\b\5\2")
        buf.write("\u0579\u063d\3\2\2\2\u057a\u057b\5\u0118\u008d\2\u057b")
        buf.write("\u057d\7F\2\2\u057c\u057e\5\"\22\2\u057d\u057c\3\2\2\2")
        buf.write("\u057d\u057e\3\2\2\2\u057e\u057f\3\2\2\2\u057f\u0580\7")
        buf.write("\4\2\2\u0580\u0581\5\6\4\2\u0581\u0582\7\20\2\2\u0582")
        buf.write("\u0586\5\6\4\2\u0583\u0584\7\20\2\2\u0584\u0585\t\3\2")
        buf.write("\2\u0585\u0587\5\6\4\2\u0586\u0583\3\2\2\2\u0586\u0587")
        buf.write("\3\2\2\2\u0587\u0588\3\2\2\2\u0588\u0589\7\5\2\2\u0589")
        buf.write("\u063d\3\2\2\2\u058a\u058b\5\u0118\u008d\2\u058b\u058d")
        buf.write("\7F\2\2\u058c\u058e\5\"\22\2\u058d\u058c\3\2\2\2\u058d")
        buf.write("\u058e\3\2\2\2\u058e\u058f\3\2\2\2\u058f\u0590\5\64\33")
        buf.write("\2\u0590\u0591\7\30\2\2\u0591\u0592\5\6\4\2\u0592\u063d")
        buf.write("\3\2\2\2\u0593\u0594\5\u0118\u008d\2\u0594\u0596\7F\2")
        buf.write("\2\u0595\u0597\5\"\22\2\u0596\u0595\3\2\2\2\u0596\u0597")
        buf.write("\3\2\2\2\u0597\u0598\3\2\2\2\u0598\u0599\5\64\33\2\u0599")
        buf.write("\u059a\7\30\2\2\u059a\u059b\7\21\2\2\u059b\u059c\7\4\2")
        buf.write("\2\u059c\u059d\5\6\4\2\u059d\u059e\7\20\2\2\u059e\u059f")
        buf.write("\5\6\4\2\u059f\u05a0\7\5\2\2\u05a0\u063d\3\2\2\2\u05a1")
        buf.write("\u05a2\5\u0118\u008d\2\u05a2\u05a3\7F\2\2\u05a3\u05a4")
        buf.write("\5\"\22\2\u05a4\u05a5\5\u0118\u008d\2\u05a5\u063d\3\2")
        buf.write("\2\2\u05a6\u05a7\5\u0118\u008d\2\u05a7\u05a8\7F\2\2\u05a8")
        buf.write("\u05a9\5:\36\2\u05a9\u063d\3\2\2\2\u05aa\u05ab\5\u0118")
        buf.write("\u008d\2\u05ab\u05ac\7F\2\2\u05ac\u05ad\5L\'\2\u05ad\u063d")
        buf.write("\3\2\2\2\u05ae\u05af\5\u0118\u008d\2\u05af\u05b0\7F\2")
        buf.write("\2\u05b0\u05b1\5P)\2\u05b1\u063d\3\2\2\2\u05b2\u05b3\5")
        buf.write("\u0118\u008d\2\u05b3\u05b4\7F\2\2\u05b4\u05b5\5Z.\2\u05b5")
        buf.write("\u063d\3\2\2\2\u05b6\u05b7\5\u0118\u008d\2\u05b7\u05b8")
        buf.write("\7F\2\2\u05b8\u05b9\5d\63\2\u05b9\u063d\3\2\2\2\u05ba")
        buf.write("\u05bb\5\u0118\u008d\2\u05bb\u05bc\7F\2\2\u05bc\u05bd")
        buf.write("\5h\65\2\u05bd\u063d\3\2\2\2\u05be\u05bf\5\u0118\u008d")
        buf.write("\2\u05bf\u05c0\7F\2\2\u05c0\u05c1\5l\67\2\u05c1\u063d")
        buf.write("\3\2\2\2\u05c2\u05c3\5\u0118\u008d\2\u05c3\u05c4\7F\2")
        buf.write("\2\u05c4\u05c5\7\13\2\2\u05c5\u05ca\5\u0118\u008d\2\u05c6")
        buf.write("\u05c7\7\20\2\2\u05c7\u05c9\5\u0118\u008d\2\u05c8\u05c6")
        buf.write("\3\2\2\2\u05c9\u05cc\3\2\2\2\u05ca\u05c8\3\2\2\2\u05ca")
        buf.write("\u05cb\3\2\2\2\u05cb\u05cd\3\2\2\2\u05cc\u05ca\3\2\2\2")
        buf.write("\u05cd\u05ce\7\r\2\2\u05ce\u063d\3\2\2\2\u05cf\u05d0\5")
        buf.write("\u0118\u008d\2\u05d0\u05d1\7F\2\2\u05d1\u05d2\5r:\2\u05d2")
        buf.write("\u063d\3\2\2\2\u05d3\u05d4\5\u0118\u008d\2\u05d4\u05d5")
        buf.write("\7F\2\2\u05d5\u05d6\5V,\2\u05d6\u063d\3\2\2\2\u05d7\u05d8")
        buf.write("\5\u0118\u008d\2\u05d8\u05d9\7F\2\2\u05d9\u05da\5\u0088")
        buf.write("E\2\u05da\u063d\3\2\2\2\u05db\u05dc\5\u0118\u008d\2\u05dc")
        buf.write("\u05dd\7F\2\2\u05dd\u05de\5\u00aaV\2\u05de\u063d\3\2\2")
        buf.write("\2\u05df\u05e0\5\u0118\u008d\2\u05e0\u05e1\7F\2\2\u05e1")
        buf.write("\u05e2\5\u00ba^\2\u05e2\u063d\3\2\2\2\u05e3\u05e4\5\u0118")
        buf.write("\u008d\2\u05e4\u05e5\7F\2\2\u05e5\u05e6\5x=\2\u05e6\u063d")
        buf.write("\3\2\2\2\u05e7\u05e8\5\u0118\u008d\2\u05e8\u05e9\7F\2")
        buf.write("\2\u05e9\u05ea\5\u008eH\2\u05ea\u063d\3\2\2\2\u05eb\u05ec")
        buf.write("\5\u0118\u008d\2\u05ec\u05ed\7F\2\2\u05ed\u05ee\5\u0094")
        buf.write("K\2\u05ee\u063d\3\2\2\2\u05ef\u05f0\5\u0118\u008d\2\u05f0")
        buf.write("\u05f1\7F\2\2\u05f1\u05f2\5\u00a0Q\2\u05f2\u063d\3\2\2")
        buf.write("\2\u05f3\u05f4\5\u0118\u008d\2\u05f4\u05f5\7F\2\2\u05f5")
        buf.write("\u05f6\5\u00a8U\2\u05f6\u063d\3\2\2\2\u05f7\u05f8\5\u0118")
        buf.write("\u008d\2\u05f8\u05f9\7F\2\2\u05f9\u05fa\5\u00b0Y\2\u05fa")
        buf.write("\u063d\3\2\2\2\u05fb\u05fc\5\u0118\u008d\2\u05fc\u05fd")
        buf.write("\7F\2\2\u05fd\u05fe\5\u00b8]\2\u05fe\u063d\3\2\2\2\u05ff")
        buf.write("\u0600\5\u0118\u008d\2\u0600\u0601\7F\2\2\u0601\u0602")
        buf.write("\5\u00c2b\2\u0602\u063d\3\2\2\2\u0603\u0604\5\u0118\u008d")
        buf.write("\2\u0604\u0605\7F\2\2\u0605\u0606\5\u00ccg\2\u0606\u063d")
        buf.write("\3\2\2\2\u0607\u063d\5\u00d2j\2\u0608\u0609\5\u0118\u008d")
        buf.write("\2\u0609\u060a\7F\2\2\u060a\u060b\5\u00e8u\2\u060b\u063d")
        buf.write("\3\2\2\2\u060c\u060d\5\u0118\u008d\2\u060d\u060e\7F\2")
        buf.write("\2\u060e\u060f\5\u00f8}\2\u060f\u063d\3\2\2\2\u0610\u0611")
        buf.write("\5\u0118\u008d\2\u0611\u0612\7F\2\2\u0612\u0613\5\u00fa")
        buf.write("~\2\u0613\u063d\3\2\2\2\u0614\u0615\5\u0118\u008d\2\u0615")
        buf.write("\u0616\7F\2\2\u0616\u0617\5\u0102\u0082\2\u0617\u063d")
        buf.write("\3\2\2\2\u0618\u0619\5\u0118\u008d\2\u0619\u061a\7F\2")
        buf.write("\2\u061a\u061b\5\u0106\u0084\2\u061b\u063d\3\2\2\2\u061c")
        buf.write("\u061d\5\u0118\u008d\2\u061d\u061e\7F\2\2\u061e\u061f")
        buf.write("\5\u0112\u008a\2\u061f\u063d\3\2\2\2\u0620\u0621\5\u0118")
        buf.write("\u008d\2\u0621\u0622\7F\2\2\u0622\u0623\5\u0110\u0089")
        buf.write("\2\u0623\u063d\3\2\2\2\u0624\u0625\5\u00d4k\2\u0625\u0626")
        buf.write("\7\u008e\2\2\u0626\u0627\5\u0110\u0089\2\u0627\u063d\3")
        buf.write("\2\2\2\u0628\u0629\5\u0118\u008d\2\u0629\u062a\7F\2\2")
        buf.write("\u062a\u062b\5\u00f6|\2\u062b\u063d\3\2\2\2\u062c\u062d")
        buf.write("\5\u0118\u008d\2\u062d\u062e\7F\2\2\u062e\u062f\5\u00ee")
        buf.write("x\2\u062f\u063d\3\2\2\2\u0630\u0631\5\u0118\u008d\2\u0631")
        buf.write("\u0632\7F\2\2\u0632\u0633\5\u00f2z\2\u0633\u063d\3\2\2")
        buf.write("\2\u0634\u0635\5\u0118\u008d\2\u0635\u0636\7F\2\2\u0636")
        buf.write("\u0637\5(\25\2\u0637\u063d\3\2\2\2\u0638\u0639\5\u0118")
        buf.write("\u008d\2\u0639\u063a\7F\2\2\u063a\u063b\5 \21\2\u063b")
        buf.write("\u063d\3\2\2\2\u063c\u0545\3\2\2\2\u063c\u0549\3\2\2\2")
        buf.write("\u063c\u054d\3\2\2\2\u063c\u0553\3\2\2\2\u063c\u055b\3")
        buf.write("\2\2\2\u063c\u0565\3\2\2\2\u063c\u0569\3\2\2\2\u063c\u056d")
        buf.write("\3\2\2\2\u063c\u0571\3\2\2\2\u063c\u0575\3\2\2\2\u063c")
        buf.write("\u057a\3\2\2\2\u063c\u058a\3\2\2\2\u063c\u0593\3\2\2\2")
        buf.write("\u063c\u05a1\3\2\2\2\u063c\u05a6\3\2\2\2\u063c\u05aa\3")
        buf.write("\2\2\2\u063c\u05ae\3\2\2\2\u063c\u05b2\3\2\2\2\u063c\u05b6")
        buf.write("\3\2\2\2\u063c\u05ba\3\2\2\2\u063c\u05be\3\2\2\2\u063c")
        buf.write("\u05c2\3\2\2\2\u063c\u05cf\3\2\2\2\u063c\u05d3\3\2\2\2")
        buf.write("\u063c\u05d7\3\2\2\2\u063c\u05db\3\2\2\2\u063c\u05df\3")
        buf.write("\2\2\2\u063c\u05e3\3\2\2\2\u063c\u05e7\3\2\2\2\u063c\u05eb")
        buf.write("\3\2\2\2\u063c\u05ef\3\2\2\2\u063c\u05f3\3\2\2\2\u063c")
        buf.write("\u05f7\3\2\2\2\u063c\u05fb\3\2\2\2\u063c\u05ff\3\2\2\2")
        buf.write("\u063c\u0603\3\2\2\2\u063c\u0607\3\2\2\2\u063c\u0608\3")
        buf.write("\2\2\2\u063c\u060c\3\2\2\2\u063c\u0610\3\2\2\2\u063c\u0614")
        buf.write("\3\2\2\2\u063c\u0618\3\2\2\2\u063c\u061c\3\2\2\2\u063c")
        buf.write("\u0620\3\2\2\2\u063c\u0624\3\2\2\2\u063c\u0628\3\2\2\2")
        buf.write("\u063c\u062c\3\2\2\2\u063c\u0630\3\2\2\2\u063c\u0634\3")
        buf.write("\2\2\2\u063c\u0638\3\2\2\2\u063d\u0117\3\2\2\2\u063e\u063f")
        buf.write("\t\6\2\2\u063f\u0119\3\2\2\2\u0640\u0641\t\7\2\2\u0641")
        buf.write("\u011b\3\2\2\2y\u011e\u0123\u012a\u0134\u013f\u0141\u014b")
        buf.write("\u0153\u0155\u016c\u0172\u0178\u0183\u018f\u0193\u019d")
        buf.write("\u01a1\u01a5\u01a8\u01af\u01bf\u01c4\u01c8\u01cc\u01d6")
        buf.write("\u01d9\u01df\u01e6\u01ef\u0200\u0204\u020a\u0210\u0217")
        buf.write("\u021d\u0228\u0235\u0237\u023b\u0245\u0249\u0253\u0257")
        buf.write("\u025b\u025f\u026a\u026e\u0272\u0279\u0289\u0293\u029d")
        buf.write("\u02a1\u02a5\u02a7\u02ab\u02af\u02b8\u02c1\u02cf\u02d8")
        buf.write("\u02e6\u02eb\u02fa\u02fe\u0302\u0304\u0308\u030c\u0311")
        buf.write("\u031b\u032b\u0330\u033a\u033e\u0344\u036e\u037b\u037f")
        buf.write("\u038f\u0394\u039e\u03a5\u03a9\u03ad\u03b2\u03c1\u03c6")
        buf.write("\u03d5\u03d8\u03e4\u03e9\u03f4\u0420\u042a\u0437\u043f")
        buf.write("\u0449\u0488\u04a6\u04b4\u04b8\u04c1\u04cd\u04ea\u04ee")
        buf.write("\u04fe\u050c\u0523\u0532\u0534\u053b\u0542\u057d\u0586")
        buf.write("\u058d\u0596\u05ca\u063c")
        return buf.getvalue()


class AVScenariosParser ( Parser ):

    grammarFileName = "AVScenarios.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'+'", "'('", "')'", "'^'", "'*'", "'/'", 
                     "'-'", "'CreateScenario'", "'{'", "';'", "'}'", "'load'", 
                     "'AV'", "','", "'range'", "'&'", "'IMU'", "'ENU'", 
                     "'WGS84'", "'0'", "'1'", "'->'", "'related to'", "'pi'", 
                     "'deg'", "'rad'", "'EGO'", "'car'", "'bus'", "'Van'", 
                     "'truck'", "'bicycle'", "'motorbicycle'", "'tricycle'", 
                     "'red'", "'green'", "'blue'", "'black'", "'white'", 
                     "'Vehicle'", "'uniform'", "'Uniform'", "'Waypoint'", 
                     "'W'", "'WP'", "'waypoint'", "'w'", "'wp'", "'Pedestrian'", 
                     "'Obstacle'", "'sphere'", "'box'", "'cone'", "'cylinder'", 
                     "'Environment'", "':'", "'sunny'", "'rain'", "'snow'", 
                     "'fog'", "'wetness'", "'light'", "'middle'", "'heavy'", 
                     "'Intersection'", "'SpeedLimit'", "'Trace'", "'='", 
                     "'EXE'", "'=='", "'<'", "'<='", "'>'", "'>='", "'!='", 
                     "'G'", "'F'", "'X'", "'['", "']'", "'U'", "'highBeamOn'", 
                     "'lowBeamOn'", "'fogLightOn'", "'hornOn'", "'warningFlashOn'", 
                     "'engineOn'", "'isLaneChanging'", "'isOverTaking'", 
                     "'isTurningAround'", "'manualIntervention'", "'honkingAllowed'", 
                     "'crosswalkAhead'", "'junctionAhead'", "'stopSignAhead'", 
                     "'stoplineAhead'", "'streetLightOn'", "'specialLocationAhead'", 
                     "'trafficLightAhead.isBlinking'", "'PriorityNPCAhead'", 
                     "'PriorityPedsAhead'", "'isTrafficJam'", "'NPCAhead'", 
                     "'NearestNPC'", "'NPCOpposite'", "'trafficLightAhead.direction.isBlinking'", 
                     "'Time'", "'turnSignal'", "'gear'", "'direction'", 
                     "'speed'", "'acc'", "'brake'", "'currentLane.number'", 
                     "'currentLane.direction'", "'speedLimit.upperLimit'", 
                     "'speedLimit.lowerLimit'", "'specialLocationAhead.type'", 
                     "'trafficLightAhead.color'", "'signalAhead'", "'NPCAhead.speed'", 
                     "'NearestNPC.speed'", "'NPCOpposite.speed'", "'trafficLightAhead.direction.color'", 
                     "'yellow'", "'off'", "'forward'", "'left'", "'right'", 
                     "'visibility'", "'dis'", "'ego'", "'perception'", "'truth'", 
                     "'diff'", "'vel'", "'spd'", "'~'", "'|'", "'|='", "'traffic'", 
                     "'norm'", "'.*'", "'./'", "'.+'", "'.-'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "String", "Variable_name", 
                      "Time", "Rgb_color", "Non_negative_value", "Non_negative_number", 
                      "WS", "LINE_COMMENT", "BLOCK_COMMENT" ]

    RULE_scenarios = 0
    RULE_string_expression = 1
    RULE_real_value_expression = 2
    RULE_coordinate_expression = 3
    RULE_scenario = 4
    RULE_npc_vehicles_parameter = 5
    RULE_pedestrians_parameter = 6
    RULE_obstacles_parameter = 7
    RULE_map_parameter = 8
    RULE_map_name = 9
    RULE_ego_parameter = 10
    RULE_ego_vehicle = 11
    RULE_parameter_list_ego = 12
    RULE_state_parameter = 13
    RULE_state_ = 14
    RULE_position = 15
    RULE_coordinate_frame = 16
    RULE_position_parameter = 17
    RULE_speed_parameter = 18
    RULE_speed = 19
    RULE_real_value = 20
    RULE_non_negative_real_value = 21
    RULE_float_value = 22
    RULE_number_value = 23
    RULE_coordinate = 24
    RULE_laneID_parameter = 25
    RULE_laneID = 26
    RULE_heading_parameter = 27
    RULE_heading = 28
    RULE_unit = 29
    RULE_direction = 30
    RULE_predefined_direction = 31
    RULE_vehicle_type_parameter = 32
    RULE_vehicle_type = 33
    RULE_type_parameter = 34
    RULE_type_ = 35
    RULE_specific_type = 36
    RULE_general_type = 37
    RULE_color_parameter = 38
    RULE_color = 39
    RULE_color_list = 40
    RULE_rgb_color = 41
    RULE_npc_vehicles = 42
    RULE_multi_npc_vehicles = 43
    RULE_npc_vehicle = 44
    RULE_npc_vehicle_parameter = 45
    RULE_parameter_list_npc = 46
    RULE_vehicle_motion_parameter = 47
    RULE_vehicle_motion = 48
    RULE_uniform_motion = 49
    RULE_uniform_index = 50
    RULE_waypoint_motion = 51
    RULE_state_list_parameter = 52
    RULE_state_list = 53
    RULE_multi_states = 54
    RULE_waypoint_index = 55
    RULE_pedestrians = 56
    RULE_multiple_pedestrians = 57
    RULE_pedestrian_parameter = 58
    RULE_pedestrian = 59
    RULE_parameter_list_ped = 60
    RULE_pedestrian_motion_parameter = 61
    RULE_pedestrian_motion = 62
    RULE_pedestrian_type_parameter = 63
    RULE_pedestrian_type = 64
    RULE_height_parameter = 65
    RULE_height = 66
    RULE_obstacles = 67
    RULE_multiple_obstacles = 68
    RULE_obstacle_parameter = 69
    RULE_obstacle = 70
    RULE_parameter_list_obs = 71
    RULE_shape_parameter = 72
    RULE_shape = 73
    RULE_sphere = 74
    RULE_box = 75
    RULE_cone = 76
    RULE_cylinder = 77
    RULE_env_parameter = 78
    RULE_env = 79
    RULE_parameter_list_env = 80
    RULE_weather_parameter = 81
    RULE_time_parameter = 82
    RULE_time = 83
    RULE_weather = 84
    RULE_multi_weathers = 85
    RULE_weather_statement_parameter = 86
    RULE_weather_statement = 87
    RULE_kind = 88
    RULE_weather_continuous_index_parameter = 89
    RULE_weather_discrete_level_parameter = 90
    RULE_weather_discrete_level = 91
    RULE_traffic = 92
    RULE_traffic_statement = 93
    RULE_intersection_traffic = 94
    RULE_meta_intersection_traffic_parameter = 95
    RULE_meta_intersection_traffic = 96
    RULE_intersection_ID_parameter = 97
    RULE_intersection_ID = 98
    RULE_lane_traffic = 99
    RULE_speed_limitation_parameter = 100
    RULE_speed_limitation = 101
    RULE_speed_range_parameter = 102
    RULE_speed_range = 103
    RULE_trace_assignment = 104
    RULE_trace_identifier = 105
    RULE_compare_operator = 106
    RULE_temporal_operator = 107
    RULE_temporal_operator1 = 108
    RULE_a = 109
    RULE_b = 110
    RULE_atom_statement_overall = 111
    RULE_atom_statement = 112
    RULE_boolean_related_APIs = 113
    RULE_value_related_APIs = 114
    RULE_distance_statement = 115
    RULE_position_element = 116
    RULE_ego_state_parameter = 117
    RULE_ego_state = 118
    RULE_agent_state_parameter = 119
    RULE_agent_state = 120
    RULE_agent_ground_truth_parameter = 121
    RULE_agent_ground_truth = 122
    RULE_perception_difference_statement = 123
    RULE_velocity_statement = 124
    RULE_velocity_parameter_for_statement = 125
    RULE_velocity_parameter = 126
    RULE_velocity = 127
    RULE_speed_statement = 128
    RULE_speed_parameter_for_statement = 129
    RULE_acceleration_statement = 130
    RULE_acceleration_parameter_for_statement = 131
    RULE_acceleration = 132
    RULE_atom_statement_parameter = 133
    RULE_atom_predicate = 134
    RULE_general_assertion = 135
    RULE_operator_related_assignments = 136
    RULE_assignment_statements = 137
    RULE_assignment_statement = 138
    RULE_identifier = 139
    RULE_arithmetic_operator = 140

    ruleNames =  [ "scenarios", "string_expression", "real_value_expression", 
                   "coordinate_expression", "scenario", "npc_vehicles_parameter", 
                   "pedestrians_parameter", "obstacles_parameter", "map_parameter", 
                   "map_name", "ego_parameter", "ego_vehicle", "parameter_list_ego", 
                   "state_parameter", "state_", "position", "coordinate_frame", 
                   "position_parameter", "speed_parameter", "speed", "real_value", 
                   "non_negative_real_value", "float_value", "number_value", 
                   "coordinate", "laneID_parameter", "laneID", "heading_parameter", 
                   "heading", "unit", "direction", "predefined_direction", 
                   "vehicle_type_parameter", "vehicle_type", "type_parameter", 
                   "type_", "specific_type", "general_type", "color_parameter", 
                   "color", "color_list", "rgb_color", "npc_vehicles", "multi_npc_vehicles", 
                   "npc_vehicle", "npc_vehicle_parameter", "parameter_list_npc", 
                   "vehicle_motion_parameter", "vehicle_motion", "uniform_motion", 
                   "uniform_index", "waypoint_motion", "state_list_parameter", 
                   "state_list", "multi_states", "waypoint_index", "pedestrians", 
                   "multiple_pedestrians", "pedestrian_parameter", "pedestrian", 
                   "parameter_list_ped", "pedestrian_motion_parameter", 
                   "pedestrian_motion", "pedestrian_type_parameter", "pedestrian_type", 
                   "height_parameter", "height", "obstacles", "multiple_obstacles", 
                   "obstacle_parameter", "obstacle", "parameter_list_obs", 
                   "shape_parameter", "shape", "sphere", "box", "cone", 
                   "cylinder", "env_parameter", "env", "parameter_list_env", 
                   "weather_parameter", "time_parameter", "time", "weather", 
                   "multi_weathers", "weather_statement_parameter", "weather_statement", 
                   "kind", "weather_continuous_index_parameter", "weather_discrete_level_parameter", 
                   "weather_discrete_level", "traffic", "traffic_statement", 
                   "intersection_traffic", "meta_intersection_traffic_parameter", 
                   "meta_intersection_traffic", "intersection_ID_parameter", 
                   "intersection_ID", "lane_traffic", "speed_limitation_parameter", 
                   "speed_limitation", "speed_range_parameter", "speed_range", 
                   "trace_assignment", "trace_identifier", "compare_operator", 
                   "temporal_operator", "temporal_operator1", "a", "b", 
                   "atom_statement_overall", "atom_statement", "boolean_related_APIs", 
                   "value_related_APIs", "distance_statement", "position_element", 
                   "ego_state_parameter", "ego_state", "agent_state_parameter", 
                   "agent_state", "agent_ground_truth_parameter", "agent_ground_truth", 
                   "perception_difference_statement", "velocity_statement", 
                   "velocity_parameter_for_statement", "velocity_parameter", 
                   "velocity", "speed_statement", "speed_parameter_for_statement", 
                   "acceleration_statement", "acceleration_parameter_for_statement", 
                   "acceleration", "atom_statement_parameter", "atom_predicate", 
                   "general_assertion", "operator_related_assignments", 
                   "assignment_statements", "assignment_statement", "identifier", 
                   "arithmetic_operator" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    T__59=60
    T__60=61
    T__61=62
    T__62=63
    T__63=64
    T__64=65
    T__65=66
    T__66=67
    T__67=68
    T__68=69
    T__69=70
    T__70=71
    T__71=72
    T__72=73
    T__73=74
    T__74=75
    T__75=76
    T__76=77
    T__77=78
    T__78=79
    T__79=80
    T__80=81
    T__81=82
    T__82=83
    T__83=84
    T__84=85
    T__85=86
    T__86=87
    T__87=88
    T__88=89
    T__89=90
    T__90=91
    T__91=92
    T__92=93
    T__93=94
    T__94=95
    T__95=96
    T__96=97
    T__97=98
    T__98=99
    T__99=100
    T__100=101
    T__101=102
    T__102=103
    T__103=104
    T__104=105
    T__105=106
    T__106=107
    T__107=108
    T__108=109
    T__109=110
    T__110=111
    T__111=112
    T__112=113
    T__113=114
    T__114=115
    T__115=116
    T__116=117
    T__117=118
    T__118=119
    T__119=120
    T__120=121
    T__121=122
    T__122=123
    T__123=124
    T__124=125
    T__125=126
    T__126=127
    T__127=128
    T__128=129
    T__129=130
    T__130=131
    T__131=132
    T__132=133
    T__133=134
    T__134=135
    T__135=136
    T__136=137
    T__137=138
    T__138=139
    T__139=140
    T__140=141
    T__141=142
    T__142=143
    T__143=144
    T__144=145
    T__145=146
    String=147
    Variable_name=148
    Time=149
    Rgb_color=150
    Non_negative_value=151
    Non_negative_number=152
    WS=153
    LINE_COMMENT=154
    BLOCK_COMMENT=155

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.7.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None



    class ScenariosContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_scenarios

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class EntryContext(ScenariosContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ScenariosContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def assignment_statements(self):
            return self.getTypedRuleContext(AVScenariosParser.Assignment_statementsContext,0)

        def EOF(self):
            return self.getToken(AVScenariosParser.EOF, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEntry" ):
                listener.enterEntry(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEntry" ):
                listener.exitEntry(self)



    def scenarios(self):

        localctx = AVScenariosParser.ScenariosContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_scenarios)
        try:
            localctx = AVScenariosParser.EntryContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 282
            self.assignment_statements()
            self.state = 284
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,0,self._ctx)
            if la_ == 1:
                self.state = 283
                self.match(AVScenariosParser.EOF)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class String_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_string_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class String_expression_for_string_expressionContext(String_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.String_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.String_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_expression_for_string_expression" ):
                listener.enterString_expression_for_string_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_expression_for_string_expression" ):
                listener.exitString_expression_for_string_expression(self)


    class String_idContext(String_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.String_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_id" ):
                listener.enterString_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_id" ):
                listener.exitString_id(self)


    class String_for_string_expressionContext(String_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.String_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def String(self):
            return self.getToken(AVScenariosParser.String, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_for_string_expression" ):
                listener.enterString_for_string_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_for_string_expression" ):
                listener.exitString_for_string_expression(self)



    def string_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.String_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 2
        self.enterRecursionRule(localctx, 2, self.RULE_string_expression, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 289
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.String]:
                localctx = AVScenariosParser.String_for_string_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 287
                self.match(AVScenariosParser.String)
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.String_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 288
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 296
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,2,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.String_expression_for_string_expressionContext(self, AVScenariosParser.String_expressionContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_string_expression)
                    self.state = 291
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 292
                    self.match(AVScenariosParser.T__0)
                    self.state = 293
                    self.string_expression(3) 
                self.state = 298
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,2,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Real_value_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_real_value_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Real_value_expression_idContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReal_value_expression_id" ):
                listener.enterReal_value_expression_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReal_value_expression_id" ):
                listener.exitReal_value_expression_id(self)


    class Cifang_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCifang_of_real_value_expression" ):
                listener.enterCifang_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCifang_of_real_value_expression" ):
                listener.exitCifang_of_real_value_expression(self)


    class Real_value_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReal_value_of_real_value_expression" ):
                listener.enterReal_value_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReal_value_of_real_value_expression" ):
                listener.exitReal_value_of_real_value_expression(self)


    class Plus_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlus_of_real_value_expression" ):
                listener.enterPlus_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlus_of_real_value_expression" ):
                listener.exitPlus_of_real_value_expression(self)


    class Kuohao_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKuohao_of_real_value_expression" ):
                listener.enterKuohao_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKuohao_of_real_value_expression" ):
                listener.exitKuohao_of_real_value_expression(self)


    class Multi_of_real_value_expressionContext(Real_value_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_value_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_of_real_value_expression" ):
                listener.enterMulti_of_real_value_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_of_real_value_expression" ):
                listener.exitMulti_of_real_value_expression(self)



    def real_value_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Real_value_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 4
        self.enterRecursionRule(localctx, 4, self.RULE_real_value_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 306
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__0, AVScenariosParser.T__6, AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.Non_negative_value, AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Real_value_of_real_value_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 300
                self.real_value()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Kuohao_of_real_value_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 301
                self.match(AVScenariosParser.T__1)
                self.state = 302
                self.real_value_expression(0)
                self.state = 303
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Real_value_expression_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 305
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 319
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,5,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 317
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,4,self._ctx)
                    if la_ == 1:
                        localctx = AVScenariosParser.Cifang_of_real_value_expressionContext(self, AVScenariosParser.Real_value_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_value_expression)
                        self.state = 308
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 309
                        self.match(AVScenariosParser.T__3)
                        self.state = 310
                        self.real_value_expression(5)
                        pass

                    elif la_ == 2:
                        localctx = AVScenariosParser.Multi_of_real_value_expressionContext(self, AVScenariosParser.Real_value_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_value_expression)
                        self.state = 311
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 312
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==AVScenariosParser.T__4 or _la==AVScenariosParser.T__5):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 313
                        self.real_value_expression(4)
                        pass

                    elif la_ == 3:
                        localctx = AVScenariosParser.Plus_of_real_value_expressionContext(self, AVScenariosParser.Real_value_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_real_value_expression)
                        self.state = 314
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 315
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 316
                        self.real_value_expression(3)
                        pass

             
                self.state = 321
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,5,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Coordinate_expressionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_coordinate_expression

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Plus_of_coordinate_expressionContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def coordinate_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Coordinate_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlus_of_coordinate_expression" ):
                listener.enterPlus_of_coordinate_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlus_of_coordinate_expression" ):
                listener.exitPlus_of_coordinate_expression(self)


    class Coordinate_expression_idContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoordinate_expression_id" ):
                listener.enterCoordinate_expression_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoordinate_expression_id" ):
                listener.exitCoordinate_expression_id(self)


    class Coordinate_of_coordinate_expressionContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate(self):
            return self.getTypedRuleContext(AVScenariosParser.CoordinateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoordinate_of_coordinate_expression" ):
                listener.enterCoordinate_of_coordinate_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoordinate_of_coordinate_expression" ):
                listener.exitCoordinate_of_coordinate_expression(self)


    class Kuohao_of_coordinate_expressionContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKuohao_of_coordinate_expression" ):
                listener.enterKuohao_of_coordinate_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKuohao_of_coordinate_expression" ):
                listener.exitKuohao_of_coordinate_expression(self)


    class Muti_of_coordinate_expressionContext(Coordinate_expressionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_expressionContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def coordinate_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Coordinate_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMuti_of_coordinate_expression" ):
                listener.enterMuti_of_coordinate_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMuti_of_coordinate_expression" ):
                listener.exitMuti_of_coordinate_expression(self)



    def coordinate_expression(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Coordinate_expressionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 6
        self.enterRecursionRule(localctx, 6, self.RULE_coordinate_expression, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 329
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,6,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Coordinate_of_coordinate_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 323
                self.coordinate()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Kuohao_of_coordinate_expressionContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 324
                self.match(AVScenariosParser.T__1)
                self.state = 325
                self.coordinate_expression(0)
                self.state = 326
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Coordinate_expression_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 328
                self.identifier()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 339
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,8,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 337
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,7,self._ctx)
                    if la_ == 1:
                        localctx = AVScenariosParser.Muti_of_coordinate_expressionContext(self, AVScenariosParser.Coordinate_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_coordinate_expression)
                        self.state = 331
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 332
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==AVScenariosParser.T__4 or _la==AVScenariosParser.T__5):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 333
                        self.coordinate_expression(4)
                        pass

                    elif la_ == 2:
                        localctx = AVScenariosParser.Plus_of_coordinate_expressionContext(self, AVScenariosParser.Coordinate_expressionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_coordinate_expression)
                        self.state = 334
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 335
                        localctx.op = self._input.LT(1)
                        _la = self._input.LA(1)
                        if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                            localctx.op = self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 336
                        self.coordinate_expression(3)
                        pass

             
                self.state = 341
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,8,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class ScenarioContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_scenario

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Create_scenarioContext(ScenarioContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ScenarioContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def map_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Map_parameterContext,0)

        def ego_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_parameterContext,0)

        def npc_vehicles_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicles_parameterContext,0)

        def pedestrians_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrians_parameterContext,0)

        def obstacles_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Obstacles_parameterContext,0)

        def env_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Env_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_scenario" ):
                listener.enterCreate_scenario(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_scenario" ):
                listener.exitCreate_scenario(self)



    def scenario(self):

        localctx = AVScenariosParser.ScenarioContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_scenario)
        try:
            localctx = AVScenariosParser.Create_scenarioContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 342
            self.match(AVScenariosParser.T__7)
            self.state = 343
            self.match(AVScenariosParser.T__8)
            self.state = 344
            self.map_parameter()
            self.state = 345
            self.match(AVScenariosParser.T__9)
            self.state = 346
            self.ego_parameter()
            self.state = 347
            self.match(AVScenariosParser.T__9)
            self.state = 348
            self.npc_vehicles_parameter()
            self.state = 349
            self.match(AVScenariosParser.T__9)
            self.state = 350
            self.pedestrians_parameter()
            self.state = 351
            self.match(AVScenariosParser.T__9)
            self.state = 352
            self.obstacles_parameter()
            self.state = 353
            self.match(AVScenariosParser.T__9)
            self.state = 354
            self.env_parameter()
            self.state = 355
            self.match(AVScenariosParser.T__9)
            self.state = 356
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Npc_vehicles_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_npc_vehicles_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Npc_varContext(Npc_vehicles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_var" ):
                listener.enterNpc_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_var" ):
                listener.exitNpc_var(self)


    class Npc_emptyContext(Npc_vehicles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_empty" ):
                listener.enterNpc_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_empty" ):
                listener.exitNpc_empty(self)


    class Npc_npcContext(Npc_vehicles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def npc_vehicles(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehiclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_npc" ):
                listener.enterNpc_npc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_npc" ):
                listener.exitNpc_npc(self)



    def npc_vehicles_parameter(self):

        localctx = AVScenariosParser.Npc_vehicles_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_npc_vehicles_parameter)
        try:
            self.state = 362
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,9,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Npc_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 358
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Npc_npcContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 359
                self.npc_vehicles()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Npc_emptyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 360
                self.match(AVScenariosParser.T__8)
                self.state = 361
                self.match(AVScenariosParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrians_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrians_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrians_emptyContext(Pedestrians_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrians_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrians_empty" ):
                listener.enterPedestrians_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrians_empty" ):
                listener.exitPedestrians_empty(self)


    class Pedestrians_pedContext(Pedestrians_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrians_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrians(self):
            return self.getTypedRuleContext(AVScenariosParser.PedestriansContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrians_ped" ):
                listener.enterPedestrians_ped(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrians_ped" ):
                listener.exitPedestrians_ped(self)


    class Pedestrians_varContext(Pedestrians_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrians_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrians_var" ):
                listener.enterPedestrians_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrians_var" ):
                listener.exitPedestrians_var(self)



    def pedestrians_parameter(self):

        localctx = AVScenariosParser.Pedestrians_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_pedestrians_parameter)
        try:
            self.state = 368
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,10,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pedestrians_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 364
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pedestrians_pedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 365
                self.pedestrians()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Pedestrians_emptyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 366
                self.match(AVScenariosParser.T__8)
                self.state = 367
                self.match(AVScenariosParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Obstacles_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_obstacles_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Obstacles_emptyContext(Obstacles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_empty" ):
                listener.enterObstacles_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_empty" ):
                listener.exitObstacles_empty(self)


    class Obstacles_obsContext(Obstacles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def obstacles(self):
            return self.getTypedRuleContext(AVScenariosParser.ObstaclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_obs" ):
                listener.enterObstacles_obs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_obs" ):
                listener.exitObstacles_obs(self)


    class Obstacles_varContext(Obstacles_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacles_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_var" ):
                listener.enterObstacles_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_var" ):
                listener.exitObstacles_var(self)



    def obstacles_parameter(self):

        localctx = AVScenariosParser.Obstacles_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_obstacles_parameter)
        try:
            self.state = 374
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,11,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Obstacles_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 370
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Obstacles_obsContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 371
                self.obstacles()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Obstacles_emptyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 372
                self.match(AVScenariosParser.T__8)
                self.state = 373
                self.match(AVScenariosParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Map_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_map_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Map_load_nameContext(Map_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Map_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def map_name(self):
            return self.getTypedRuleContext(AVScenariosParser.Map_nameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMap_load_name" ):
                listener.enterMap_load_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMap_load_name" ):
                listener.exitMap_load_name(self)



    def map_parameter(self):

        localctx = AVScenariosParser.Map_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_map_parameter)
        try:
            localctx = AVScenariosParser.Map_load_nameContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 376
            self.match(AVScenariosParser.T__11)
            self.state = 377
            self.match(AVScenariosParser.T__1)
            self.state = 378
            self.map_name()
            self.state = 379
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Map_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_map_name

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Map_name_strContext(Map_nameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Map_nameContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMap_name_str" ):
                listener.enterMap_name_str(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMap_name_str" ):
                listener.exitMap_name_str(self)



    def map_name(self):

        localctx = AVScenariosParser.Map_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_map_name)
        try:
            localctx = AVScenariosParser.Map_name_strContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 381
            self.string_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ego_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_ego_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Ego_ego_vehicleContext(Ego_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_vehicle(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_vehicleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_ego_vehicle" ):
                listener.enterEgo_ego_vehicle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_ego_vehicle" ):
                listener.exitEgo_ego_vehicle(self)


    class Ego_ego_varContext(Ego_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_ego_var" ):
                listener.enterEgo_ego_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_ego_var" ):
                listener.exitEgo_ego_var(self)



    def ego_parameter(self):

        localctx = AVScenariosParser.Ego_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_ego_parameter)
        try:
            self.state = 385
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Ego_ego_vehicleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 383
                self.ego_vehicle()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Ego_ego_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 384
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ego_vehicleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_ego_vehicle

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Ego_avContext(Ego_vehicleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_vehicleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_ego(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_egoContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_av" ):
                listener.enterEgo_av(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_av" ):
                listener.exitEgo_av(self)



    def ego_vehicle(self):

        localctx = AVScenariosParser.Ego_vehicleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_ego_vehicle)
        try:
            localctx = AVScenariosParser.Ego_avContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 387
            self.match(AVScenariosParser.T__12)
            self.state = 388
            self.match(AVScenariosParser.T__1)
            self.state = 389
            self.parameter_list_ego()
            self.state = 390
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_egoContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_ego

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_list_ego_Context(Parameter_list_egoContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_egoContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.State_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,i)

        def vehicle_type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_type_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_list_ego_" ):
                listener.enterPar_list_ego_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_list_ego_" ):
                listener.exitPar_list_ego_(self)



    def parameter_list_ego(self):

        localctx = AVScenariosParser.Parameter_list_egoContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_parameter_list_ego)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.Par_list_ego_Context(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 392
            self.state_parameter()
            self.state = 393
            self.match(AVScenariosParser.T__13)
            self.state = 394
            self.state_parameter()
            self.state = 397
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AVScenariosParser.T__13:
                self.state = 395
                self.match(AVScenariosParser.T__13)
                self.state = 396
                self.vehicle_type_parameter()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_state_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class State_stateContext(State_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_(self):
            return self.getTypedRuleContext(AVScenariosParser.State_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_state" ):
                listener.enterState_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_state" ):
                listener.exitState_state(self)


    class State_state_varContext(State_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_state_var" ):
                listener.enterState_state_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_state_var" ):
                listener.exitState_state_var(self)



    def state_parameter(self):

        localctx = AVScenariosParser.State_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_state_parameter)
        try:
            self.state = 401
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.State_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 399
                self.state_()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.State_state_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 400
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_state_

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class State_positionContext(State_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def position_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Position_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_position" ):
                listener.enterState_position(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_position" ):
                listener.exitState_position(self)


    class State_position_heading_speedContext(State_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def position_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Position_parameterContext,0)

        def heading_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Heading_parameterContext,0)

        def speed_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_position_heading_speed" ):
                listener.enterState_position_heading_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_position_heading_speed" ):
                listener.exitState_position_heading_speed(self)



    def state_(self):

        localctx = AVScenariosParser.State_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_state_)
        self._la = 0 # Token type
        try:
            self.state = 419
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,17,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.State_positionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 403
                self.match(AVScenariosParser.T__1)
                self.state = 404
                self.position_parameter()
                self.state = 405
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.State_position_heading_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 407
                self.match(AVScenariosParser.T__1)
                self.state = 408
                self.position_parameter()
                self.state = 409
                self.match(AVScenariosParser.T__13)
                self.state = 411
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__0) | (1 << AVScenariosParser.T__1) | (1 << AVScenariosParser.T__6) | (1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__14) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__19) | (1 << AVScenariosParser.T__20) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (AVScenariosParser.T__130 - 131)) | (1 << (AVScenariosParser.T__132 - 131)) | (1 << (AVScenariosParser.T__133 - 131)) | (1 << (AVScenariosParser.T__134 - 131)) | (1 << (AVScenariosParser.T__140 - 131)) | (1 << (AVScenariosParser.T__141 - 131)) | (1 << (AVScenariosParser.Variable_name - 131)) | (1 << (AVScenariosParser.Non_negative_value - 131)) | (1 << (AVScenariosParser.Non_negative_number - 131)))) != 0):
                    self.state = 410
                    self.heading_parameter()


                self.state = 415
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 413
                    self.match(AVScenariosParser.T__13)
                    self.state = 414
                    self.speed_parameter()


                self.state = 417
                self.match(AVScenariosParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PositionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_position

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pos_coor_coorContext(PositionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PositionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate(self):
            return self.getTypedRuleContext(AVScenariosParser.CoordinateContext,0)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_coor_coor" ):
                listener.enterPos_coor_coor(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_coor_coor" ):
                listener.exitPos_coor_coor(self)


    class Pos_coor_range1Context(PositionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PositionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_coor_range1" ):
                listener.enterPos_coor_range1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_coor_range1" ):
                listener.exitPos_coor_range1(self)


    class Pos_coor_coor2Context(PositionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PositionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_coor_coor2" ):
                listener.enterPos_coor_coor2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_coor_coor2" ):
                listener.exitPos_coor_coor2(self)



    def position(self):

        localctx = AVScenariosParser.PositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_position)
        try:
            self.state = 445
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,20,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pos_coor_coorContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 422
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,18,self._ctx)
                if la_ == 1:
                    self.state = 421
                    self.coordinate_frame()


                self.state = 424
                self.coordinate()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pos_coor_coor2Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 425
                self.coordinate_frame()
                self.state = 426
                self.coordinate_expression(0)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Pos_coor_range1Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 429
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,19,self._ctx)
                if la_ == 1:
                    self.state = 428
                    self.coordinate_frame()


                self.state = 431
                self.coordinate_expression(0)
                self.state = 432
                self.match(AVScenariosParser.T__14)
                self.state = 433
                self.match(AVScenariosParser.T__1)
                self.state = 434
                self.real_value_expression(0)
                self.state = 435
                self.match(AVScenariosParser.T__13)
                self.state = 436
                self.real_value_expression(0)
                self.state = 437
                self.match(AVScenariosParser.T__2)
                self.state = 438
                self.match(AVScenariosParser.T__15)
                self.state = 439
                self.match(AVScenariosParser.T__1)
                self.state = 440
                self.real_value_expression(0)
                self.state = 441
                self.match(AVScenariosParser.T__13)
                self.state = 442
                self.real_value_expression(0)
                self.state = 443
                self.match(AVScenariosParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Coordinate_frameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_coordinate_frame

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Coor_imuContext(Coordinate_frameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_frameContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_imu" ):
                listener.enterCoor_imu(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_imu" ):
                listener.exitCoor_imu(self)


    class Coor_enuContext(Coordinate_frameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_frameContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_enu" ):
                listener.enterCoor_enu(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_enu" ):
                listener.exitCoor_enu(self)


    class Coor_wgs84Context(Coordinate_frameContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Coordinate_frameContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_wgs84" ):
                listener.enterCoor_wgs84(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_wgs84" ):
                listener.exitCoor_wgs84(self)



    def coordinate_frame(self):

        localctx = AVScenariosParser.Coordinate_frameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_coordinate_frame)
        try:
            self.state = 450
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__16]:
                localctx = AVScenariosParser.Coor_imuContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 447
                self.match(AVScenariosParser.T__16)
                pass
            elif token in [AVScenariosParser.T__17]:
                localctx = AVScenariosParser.Coor_enuContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 448
                self.match(AVScenariosParser.T__17)
                pass
            elif token in [AVScenariosParser.T__18]:
                localctx = AVScenariosParser.Coor_wgs84Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 449
                self.match(AVScenariosParser.T__18)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Position_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_position_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pos_pos_varContext(Position_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_pos_var" ):
                listener.enterPos_pos_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_pos_var" ):
                listener.exitPos_pos_var(self)


    class Pos_posContext(Position_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def position(self):
            return self.getTypedRuleContext(AVScenariosParser.PositionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPos_pos" ):
                listener.enterPos_pos(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPos_pos" ):
                listener.exitPos_pos(self)



    def position_parameter(self):

        localctx = AVScenariosParser.Position_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_position_parameter)
        try:
            self.state = 454
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pos_posContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 452
                self.position()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pos_pos_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 453
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_speed_varContext(Speed_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_speed_var" ):
                listener.enterSpeed_speed_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_speed_var" ):
                listener.exitSpeed_speed_var(self)


    class Speed_speedContext(Speed_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed(self):
            return self.getTypedRuleContext(AVScenariosParser.SpeedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_speed" ):
                listener.enterSpeed_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_speed" ):
                listener.exitSpeed_speed(self)



    def speed_parameter(self):

        localctx = AVScenariosParser.Speed_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_speed_parameter)
        try:
            self.state = 458
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,23,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Speed_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 456
                self.speed()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Speed_speed_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 457
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SpeedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_rvContext(SpeedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.SpeedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_rv" ):
                listener.enterSpeed_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_rv" ):
                listener.exitSpeed_rv(self)


    class Speed_range_for_stateContext(SpeedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.SpeedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_range_for_state" ):
                listener.enterSpeed_range_for_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_range_for_state" ):
                listener.exitSpeed_range_for_state(self)



    def speed(self):

        localctx = AVScenariosParser.SpeedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_speed)
        try:
            self.state = 468
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__0, AVScenariosParser.T__1, AVScenariosParser.T__6, AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name, AVScenariosParser.Non_negative_value, AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Speed_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 460
                self.real_value_expression(0)
                pass
            elif token in [AVScenariosParser.T__14]:
                localctx = AVScenariosParser.Speed_range_for_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 461
                self.match(AVScenariosParser.T__14)
                self.state = 462
                self.match(AVScenariosParser.T__1)
                self.state = 463
                self.real_value_expression(0)
                self.state = 464
                self.match(AVScenariosParser.T__13)
                self.state = 465
                self.real_value_expression(0)
                self.state = 466
                self.match(AVScenariosParser.T__2)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Real_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_real_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class RvContext(Real_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Real_valueContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def non_negative_real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Non_negative_real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRv" ):
                listener.enterRv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRv" ):
                listener.exitRv(self)



    def real_value(self):

        localctx = AVScenariosParser.Real_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_real_value)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.RvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 471
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6:
                self.state = 470
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 473
            self.non_negative_real_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Non_negative_real_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_non_negative_real_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Non_negative_rvContext(Non_negative_real_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Non_negative_real_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def float_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Float_valueContext,0)

        def number_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Number_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_rv" ):
                listener.enterNon_negative_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_rv" ):
                listener.exitNon_negative_rv(self)



    def non_negative_real_value(self):

        localctx = AVScenariosParser.Non_negative_real_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_non_negative_real_value)
        try:
            localctx = AVScenariosParser.Non_negative_rvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 477
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.Non_negative_value]:
                self.state = 475
                self.float_value()
                pass
            elif token in [AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.Non_negative_number]:
                self.state = 476
                self.number_value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Float_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_float_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Non_negative_floatContext(Float_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Float_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Non_negative_value(self):
            return self.getToken(AVScenariosParser.Non_negative_value, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_float" ):
                listener.enterNon_negative_float(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_float" ):
                listener.exitNon_negative_float(self)



    def float_value(self):

        localctx = AVScenariosParser.Float_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_float_value)
        try:
            localctx = AVScenariosParser.Non_negative_floatContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 479
            self.match(AVScenariosParser.Non_negative_value)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Number_valueContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_number_value

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Non_negative_numberContext(Number_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Number_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Non_negative_number(self):
            return self.getToken(AVScenariosParser.Non_negative_number, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_number" ):
                listener.enterNon_negative_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_number" ):
                listener.exitNon_negative_number(self)


    class Non_negative_conflict_1Context(Number_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Number_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_conflict_1" ):
                listener.enterNon_negative_conflict_1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_conflict_1" ):
                listener.exitNon_negative_conflict_1(self)


    class Non_negative_conflict_0Context(Number_valueContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Number_valueContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNon_negative_conflict_0" ):
                listener.enterNon_negative_conflict_0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNon_negative_conflict_0" ):
                listener.exitNon_negative_conflict_0(self)



    def number_value(self):

        localctx = AVScenariosParser.Number_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_number_value)
        try:
            self.state = 484
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Non_negative_numberContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 481
                self.match(AVScenariosParser.Non_negative_number)
                pass
            elif token in [AVScenariosParser.T__19]:
                localctx = AVScenariosParser.Non_negative_conflict_0Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 482
                self.match(AVScenariosParser.T__19)
                pass
            elif token in [AVScenariosParser.T__20]:
                localctx = AVScenariosParser.Non_negative_conflict_1Context(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 483
                self.match(AVScenariosParser.T__20)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CoordinateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_coordinate

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Coor_laneID_rangeContext(CoordinateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.CoordinateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_laneID_range" ):
                listener.enterCoor_laneID_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_laneID_range" ):
                listener.exitCoor_laneID_range(self)


    class Coor_rv_rvContext(CoordinateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.CoordinateContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_rv_rv" ):
                listener.enterCoor_rv_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_rv_rv" ):
                listener.exitCoor_rv_rv(self)


    class Coor_laneID_rvContext(CoordinateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.CoordinateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCoor_laneID_rv" ):
                listener.enterCoor_laneID_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCoor_laneID_rv" ):
                listener.exitCoor_laneID_rv(self)



    def coordinate(self):

        localctx = AVScenariosParser.CoordinateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_coordinate)
        self._la = 0 # Token type
        try:
            self.state = 510
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Coor_rv_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 486
                self.match(AVScenariosParser.T__1)
                self.state = 487
                self.real_value_expression(0)
                self.state = 488
                self.match(AVScenariosParser.T__13)
                self.state = 489
                self.real_value_expression(0)
                self.state = 493
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 490
                    self.match(AVScenariosParser.T__13)
                    self.state = 491
                    localctx.op = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                        localctx.op = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 492
                    self.real_value_expression(0)


                self.state = 495
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Coor_laneID_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 497
                self.laneID_parameter()
                self.state = 498
                self.match(AVScenariosParser.T__21)
                self.state = 499
                self.real_value_expression(0)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Coor_laneID_rangeContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 501
                self.laneID_parameter()
                self.state = 502
                self.match(AVScenariosParser.T__21)
                self.state = 503
                self.match(AVScenariosParser.T__14)
                self.state = 504
                self.match(AVScenariosParser.T__1)
                self.state = 505
                self.real_value_expression(0)
                self.state = 506
                self.match(AVScenariosParser.T__13)
                self.state = 507
                self.real_value_expression(0)
                self.state = 508
                self.match(AVScenariosParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LaneID_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_laneID_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LaneID_laneIDContext(LaneID_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.LaneID_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneIDContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaneID_laneID" ):
                listener.enterLaneID_laneID(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaneID_laneID" ):
                listener.exitLaneID_laneID(self)


    class LaneID_laneID_varContext(LaneID_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.LaneID_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaneID_laneID_var" ):
                listener.enterLaneID_laneID_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaneID_laneID_var" ):
                listener.exitLaneID_laneID_var(self)



    def laneID_parameter(self):

        localctx = AVScenariosParser.LaneID_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_laneID_parameter)
        try:
            self.state = 514
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.LaneID_laneID_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 512
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.LaneID_laneIDContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 513
                self.laneID()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class LaneIDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_laneID

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class LaneID_strContext(LaneIDContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.LaneIDContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLaneID_str" ):
                listener.enterLaneID_str(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLaneID_str" ):
                listener.exitLaneID_str(self)



    def laneID(self):

        localctx = AVScenariosParser.LaneIDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_laneID)
        try:
            localctx = AVScenariosParser.LaneID_strContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 516
            self.string_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Heading_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_heading_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Head_varContext(Heading_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Heading_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_var" ):
                listener.enterHead_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_var" ):
                listener.exitHead_var(self)


    class Head_headingContext(Heading_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Heading_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def heading(self):
            return self.getTypedRuleContext(AVScenariosParser.HeadingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_heading" ):
                listener.enterHead_heading(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_heading" ):
                listener.exitHead_heading(self)



    def heading_parameter(self):

        localctx = AVScenariosParser.Heading_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_heading_parameter)
        try:
            self.state = 520
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,31,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Head_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 518
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Head_headingContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 519
                self.heading()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HeadingContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_heading

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Head_pi_value_rangeContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_pi_value_range" ):
                listener.enterHead_pi_value_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_pi_value_range" ):
                listener.exitHead_pi_value_range(self)


    class Head_pi_valueContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_pi_value" ):
                listener.enterHead_pi_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_pi_value" ):
                listener.exitHead_pi_value(self)


    class Head_value_rangeContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_value_range" ):
                listener.enterHead_value_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_value_range" ):
                listener.exitHead_value_range(self)


    class Head_only_pi_valueContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_only_pi_value" ):
                listener.enterHead_only_pi_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_only_pi_value" ):
                listener.exitHead_only_pi_value(self)


    class Head_valueContext(HeadingContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeadingContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)

        def unit(self):
            return self.getTypedRuleContext(AVScenariosParser.UnitContext,0)

        def direction(self):
            return self.getTypedRuleContext(AVScenariosParser.DirectionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHead_value" ):
                listener.enterHead_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHead_value" ):
                listener.exitHead_value(self)



    def heading(self):

        localctx = AVScenariosParser.HeadingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_heading)
        self._la = 0 # Token type
        try:
            self.state = 565
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Head_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 522
                self.real_value_expression(0)
                self.state = 523
                self.unit()
                self.state = 526
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 524
                    self.match(AVScenariosParser.T__22)
                    self.state = 525
                    self.direction()


                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Head_pi_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 528
                self.real_value_expression(0)
                self.state = 529
                self.match(AVScenariosParser.T__23)
                self.state = 530
                self.unit()
                self.state = 533
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 531
                    self.match(AVScenariosParser.T__22)
                    self.state = 532
                    self.direction()


                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Head_only_pi_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 535
                self.match(AVScenariosParser.T__23)
                self.state = 536
                self.unit()
                self.state = 539
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 537
                    self.match(AVScenariosParser.T__22)
                    self.state = 538
                    self.direction()


                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Head_value_rangeContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 541
                self.match(AVScenariosParser.T__14)
                self.state = 542
                self.match(AVScenariosParser.T__1)
                self.state = 543
                self.real_value_expression(0)
                self.state = 544
                self.match(AVScenariosParser.T__13)
                self.state = 545
                self.real_value_expression(0)
                self.state = 546
                self.match(AVScenariosParser.T__2)
                self.state = 547
                self.unit()
                self.state = 550
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 548
                    self.match(AVScenariosParser.T__22)
                    self.state = 549
                    self.direction()


                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Head_pi_value_rangeContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 552
                self.match(AVScenariosParser.T__14)
                self.state = 553
                self.match(AVScenariosParser.T__1)
                self.state = 554
                self.real_value_expression(0)
                self.state = 555
                self.match(AVScenariosParser.T__23)
                self.state = 556
                self.match(AVScenariosParser.T__13)
                self.state = 557
                self.real_value_expression(0)
                self.state = 558
                self.match(AVScenariosParser.T__23)
                self.state = 559
                self.match(AVScenariosParser.T__2)
                self.state = 560
                self.unit()
                self.state = 563
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__22:
                    self.state = 561
                    self.match(AVScenariosParser.T__22)
                    self.state = 562
                    self.direction()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class UnitContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_unit

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Unit_degContext(UnitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.UnitContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_deg" ):
                listener.enterUnit_deg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_deg" ):
                listener.exitUnit_deg(self)


    class Unit_radContext(UnitContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.UnitContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnit_rad" ):
                listener.enterUnit_rad(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnit_rad" ):
                listener.exitUnit_rad(self)



    def unit(self):

        localctx = AVScenariosParser.UnitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_unit)
        try:
            self.state = 569
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__24]:
                localctx = AVScenariosParser.Unit_degContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 567
                self.match(AVScenariosParser.T__24)
                pass
            elif token in [AVScenariosParser.T__25]:
                localctx = AVScenariosParser.Unit_radContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 568
                self.match(AVScenariosParser.T__25)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class DirectionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_direction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Direction_preContext(DirectionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.DirectionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def predefined_direction(self):
            return self.getTypedRuleContext(AVScenariosParser.Predefined_directionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDirection_pre" ):
                listener.enterDirection_pre(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDirection_pre" ):
                listener.exitDirection_pre(self)



    def direction(self):

        localctx = AVScenariosParser.DirectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_direction)
        try:
            localctx = AVScenariosParser.Direction_preContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 571
            self.predefined_direction()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Predefined_directionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_predefined_direction

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pre_idContext(Predefined_directionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Predefined_directionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPre_id" ):
                listener.enterPre_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPre_id" ):
                listener.exitPre_id(self)


    class Pre_laneContext(Predefined_directionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Predefined_directionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPre_lane" ):
                listener.enterPre_lane(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPre_lane" ):
                listener.exitPre_lane(self)


    class Pre_egoContext(Predefined_directionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Predefined_directionContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPre_ego" ):
                listener.enterPre_ego(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPre_ego" ):
                listener.exitPre_ego(self)



    def predefined_direction(self):

        localctx = AVScenariosParser.Predefined_directionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_predefined_direction)
        try:
            self.state = 579
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,39,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pre_laneContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 573
                self.laneID_parameter()
                self.state = 574
                self.match(AVScenariosParser.T__21)
                self.state = 575
                self.real_value_expression(0)
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pre_egoContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 577
                self.match(AVScenariosParser.T__26)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Pre_idContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 578
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vehicle_type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_vehicle_type_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Vehicle_vehicle_type_varContext(Vehicle_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_vehicle_type_var" ):
                listener.enterVehicle_vehicle_type_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_vehicle_type_var" ):
                listener.exitVehicle_vehicle_type_var(self)


    class Vehicle_vehicle_typeContext(Vehicle_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def vehicle_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_vehicle_type" ):
                listener.enterVehicle_vehicle_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_vehicle_type" ):
                listener.exitVehicle_vehicle_type(self)



    def vehicle_type_parameter(self):

        localctx = AVScenariosParser.Vehicle_type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_vehicle_type_parameter)
        try:
            self.state = 583
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Vehicle_vehicle_type_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 581
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Vehicle_vehicle_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 582
                self.vehicle_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vehicle_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_vehicle_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Vehicle_type_colorContext(Vehicle_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Type_parameterContext,0)

        def color_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Color_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_type_color" ):
                listener.enterVehicle_type_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_type_color" ):
                listener.exitVehicle_type_color(self)


    class Vehicle_type_Context(Vehicle_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Type_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_type_" ):
                listener.enterVehicle_type_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_type_" ):
                listener.exitVehicle_type_(self)



    def vehicle_type(self):

        localctx = AVScenariosParser.Vehicle_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_vehicle_type)
        self._la = 0 # Token type
        try:
            self.state = 597
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,42,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Vehicle_type_Context(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 585
                self.match(AVScenariosParser.T__1)
                self.state = 586
                self.type_parameter()
                self.state = 587
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Vehicle_type_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 589
                self.match(AVScenariosParser.T__1)
                self.state = 590
                self.type_parameter()
                self.state = 591
                self.match(AVScenariosParser.T__13)
                self.state = 593
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 8)) & ~0x3f) == 0 and ((1 << (_la - 8)) & ((1 << (AVScenariosParser.T__7 - 8)) | (1 << (AVScenariosParser.T__11 - 8)) | (1 << (AVScenariosParser.T__12 - 8)) | (1 << (AVScenariosParser.T__16 - 8)) | (1 << (AVScenariosParser.T__17 - 8)) | (1 << (AVScenariosParser.T__18 - 8)) | (1 << (AVScenariosParser.T__23 - 8)) | (1 << (AVScenariosParser.T__24 - 8)) | (1 << (AVScenariosParser.T__25 - 8)) | (1 << (AVScenariosParser.T__26 - 8)) | (1 << (AVScenariosParser.T__27 - 8)) | (1 << (AVScenariosParser.T__28 - 8)) | (1 << (AVScenariosParser.T__29 - 8)) | (1 << (AVScenariosParser.T__30 - 8)) | (1 << (AVScenariosParser.T__31 - 8)) | (1 << (AVScenariosParser.T__32 - 8)) | (1 << (AVScenariosParser.T__33 - 8)) | (1 << (AVScenariosParser.T__34 - 8)) | (1 << (AVScenariosParser.T__35 - 8)) | (1 << (AVScenariosParser.T__36 - 8)) | (1 << (AVScenariosParser.T__37 - 8)) | (1 << (AVScenariosParser.T__38 - 8)) | (1 << (AVScenariosParser.T__39 - 8)) | (1 << (AVScenariosParser.T__40 - 8)) | (1 << (AVScenariosParser.T__41 - 8)) | (1 << (AVScenariosParser.T__42 - 8)) | (1 << (AVScenariosParser.T__43 - 8)) | (1 << (AVScenariosParser.T__44 - 8)) | (1 << (AVScenariosParser.T__45 - 8)) | (1 << (AVScenariosParser.T__46 - 8)) | (1 << (AVScenariosParser.T__47 - 8)) | (1 << (AVScenariosParser.T__48 - 8)) | (1 << (AVScenariosParser.T__49 - 8)) | (1 << (AVScenariosParser.T__54 - 8)) | (1 << (AVScenariosParser.T__64 - 8)) | (1 << (AVScenariosParser.T__65 - 8)) | (1 << (AVScenariosParser.T__68 - 8)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (AVScenariosParser.T__130 - 131)) | (1 << (AVScenariosParser.T__132 - 131)) | (1 << (AVScenariosParser.T__133 - 131)) | (1 << (AVScenariosParser.T__134 - 131)) | (1 << (AVScenariosParser.T__140 - 131)) | (1 << (AVScenariosParser.T__141 - 131)) | (1 << (AVScenariosParser.Variable_name - 131)) | (1 << (AVScenariosParser.Rgb_color - 131)))) != 0):
                    self.state = 592
                    self.color_parameter()


                self.state = 595
                self.match(AVScenariosParser.T__2)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_type_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Type_type_Context(Type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def type_(self):
            return self.getTypedRuleContext(AVScenariosParser.Type_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_type_" ):
                listener.enterType_type_(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_type_" ):
                listener.exitType_type_(self)


    class Type_varContext(Type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_var" ):
                listener.enterType_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_var" ):
                listener.exitType_var(self)



    def type_parameter(self):

        localctx = AVScenariosParser.Type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_type_parameter)
        try:
            self.state = 601
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,43,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Type_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 599
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Type_type_Context(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 600
                self.type_()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Type_Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_type_

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Type_generalContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_type(self):
            return self.getTypedRuleContext(AVScenariosParser.General_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_general" ):
                listener.enterType_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_general" ):
                listener.exitType_general(self)


    class Type_specificContext(Type_Context):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Type_Context
            super().__init__(parser)
            self.copyFrom(ctx)

        def specific_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Specific_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_specific" ):
                listener.enterType_specific(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_specific" ):
                listener.exitType_specific(self)



    def type_(self):

        localctx = AVScenariosParser.Type_Context(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_type_)
        try:
            self.state = 605
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,44,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Type_specificContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 603
                self.specific_type()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Type_generalContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 604
                self.general_type()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Specific_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_specific_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Specific_strContext(Specific_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Specific_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def string_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpecific_str" ):
                listener.enterSpecific_str(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpecific_str" ):
                listener.exitSpecific_str(self)



    def specific_type(self):

        localctx = AVScenariosParser.Specific_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_specific_type)
        try:
            localctx = AVScenariosParser.Specific_strContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 607
            self.string_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class General_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_general_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class General_motorbicycleContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_motorbicycle" ):
                listener.enterGeneral_motorbicycle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_motorbicycle" ):
                listener.exitGeneral_motorbicycle(self)


    class General_truckContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_truck" ):
                listener.enterGeneral_truck(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_truck" ):
                listener.exitGeneral_truck(self)


    class General_bicycleContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_bicycle" ):
                listener.enterGeneral_bicycle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_bicycle" ):
                listener.exitGeneral_bicycle(self)


    class General_tricycleContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_tricycle" ):
                listener.enterGeneral_tricycle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_tricycle" ):
                listener.exitGeneral_tricycle(self)


    class General_carContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_car" ):
                listener.enterGeneral_car(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_car" ):
                listener.exitGeneral_car(self)


    class General_vanContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_van" ):
                listener.enterGeneral_van(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_van" ):
                listener.exitGeneral_van(self)


    class General_busContext(General_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_bus" ):
                listener.enterGeneral_bus(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_bus" ):
                listener.exitGeneral_bus(self)



    def general_type(self):

        localctx = AVScenariosParser.General_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_general_type)
        try:
            self.state = 616
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__27]:
                localctx = AVScenariosParser.General_carContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 609
                self.match(AVScenariosParser.T__27)
                pass
            elif token in [AVScenariosParser.T__28]:
                localctx = AVScenariosParser.General_busContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 610
                self.match(AVScenariosParser.T__28)
                pass
            elif token in [AVScenariosParser.T__29]:
                localctx = AVScenariosParser.General_vanContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 611
                self.match(AVScenariosParser.T__29)
                pass
            elif token in [AVScenariosParser.T__30]:
                localctx = AVScenariosParser.General_truckContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 612
                self.match(AVScenariosParser.T__30)
                pass
            elif token in [AVScenariosParser.T__31]:
                localctx = AVScenariosParser.General_bicycleContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 613
                self.match(AVScenariosParser.T__31)
                pass
            elif token in [AVScenariosParser.T__32]:
                localctx = AVScenariosParser.General_motorbicycleContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 614
                self.match(AVScenariosParser.T__32)
                pass
            elif token in [AVScenariosParser.T__33]:
                localctx = AVScenariosParser.General_tricycleContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 615
                self.match(AVScenariosParser.T__33)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Color_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_color_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Color_colorContext(Color_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def color(self):
            return self.getTypedRuleContext(AVScenariosParser.ColorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_color" ):
                listener.enterColor_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_color" ):
                listener.exitColor_color(self)


    class Color_varContext(Color_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_var" ):
                listener.enterColor_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_var" ):
                listener.exitColor_var(self)



    def color_parameter(self):

        localctx = AVScenariosParser.Color_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_color_parameter)
        try:
            self.state = 620
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Color_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 618
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__34, AVScenariosParser.T__35, AVScenariosParser.T__36, AVScenariosParser.T__37, AVScenariosParser.T__38, AVScenariosParser.Rgb_color]:
                localctx = AVScenariosParser.Color_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 619
                self.color()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ColorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_color

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Color_color_listContext(ColorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ColorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def color_list(self):
            return self.getTypedRuleContext(AVScenariosParser.Color_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_color_list" ):
                listener.enterColor_color_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_color_list" ):
                listener.exitColor_color_list(self)


    class Color_rgb_colorContext(ColorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ColorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def rgb_color(self):
            return self.getTypedRuleContext(AVScenariosParser.Rgb_colorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_rgb_color" ):
                listener.enterColor_rgb_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_rgb_color" ):
                listener.exitColor_rgb_color(self)



    def color(self):

        localctx = AVScenariosParser.ColorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_color)
        try:
            self.state = 624
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__34, AVScenariosParser.T__35, AVScenariosParser.T__36, AVScenariosParser.T__37, AVScenariosParser.T__38]:
                localctx = AVScenariosParser.Color_color_listContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 622
                self.color_list()
                pass
            elif token in [AVScenariosParser.Rgb_color]:
                localctx = AVScenariosParser.Color_rgb_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 623
                self.rgb_color()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Color_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_color_list

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Color_blueContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_blue" ):
                listener.enterColor_blue(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_blue" ):
                listener.exitColor_blue(self)


    class Color_redContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_red" ):
                listener.enterColor_red(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_red" ):
                listener.exitColor_red(self)


    class Color_whiteContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_white" ):
                listener.enterColor_white(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_white" ):
                listener.exitColor_white(self)


    class Color_blackContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_black" ):
                listener.enterColor_black(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_black" ):
                listener.exitColor_black(self)


    class Color_greenContext(Color_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Color_listContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColor_green" ):
                listener.enterColor_green(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColor_green" ):
                listener.exitColor_green(self)



    def color_list(self):

        localctx = AVScenariosParser.Color_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_color_list)
        try:
            self.state = 631
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__34]:
                localctx = AVScenariosParser.Color_redContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 626
                self.match(AVScenariosParser.T__34)
                pass
            elif token in [AVScenariosParser.T__35]:
                localctx = AVScenariosParser.Color_greenContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 627
                self.match(AVScenariosParser.T__35)
                pass
            elif token in [AVScenariosParser.T__36]:
                localctx = AVScenariosParser.Color_blueContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 628
                self.match(AVScenariosParser.T__36)
                pass
            elif token in [AVScenariosParser.T__37]:
                localctx = AVScenariosParser.Color_blackContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 629
                self.match(AVScenariosParser.T__37)
                pass
            elif token in [AVScenariosParser.T__38]:
                localctx = AVScenariosParser.Color_whiteContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 630
                self.match(AVScenariosParser.T__38)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Rgb_colorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_rgb_color

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Rgb_rgbContext(Rgb_colorContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Rgb_colorContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Rgb_color(self):
            return self.getToken(AVScenariosParser.Rgb_color, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRgb_rgb" ):
                listener.enterRgb_rgb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRgb_rgb" ):
                listener.exitRgb_rgb(self)



    def rgb_color(self):

        localctx = AVScenariosParser.Rgb_colorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_rgb_color)
        try:
            localctx = AVScenariosParser.Rgb_rgbContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 633
            self.match(AVScenariosParser.Rgb_color)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Npc_vehiclesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_npc_vehicles

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class NpcContext(Npc_vehiclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehiclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_npc_vehicles(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_npc_vehiclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc" ):
                listener.enterNpc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc" ):
                listener.exitNpc(self)



    def npc_vehicles(self):

        localctx = AVScenariosParser.Npc_vehiclesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_npc_vehicles)
        try:
            localctx = AVScenariosParser.NpcContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 635
            self.match(AVScenariosParser.T__8)
            self.state = 636
            self.multi_npc_vehicles(0)
            self.state = 637
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_npc_vehiclesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multi_npc_vehicles

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Multi_multi_npcContext(Multi_npc_vehiclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_npc_vehiclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_npc_vehicles(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_npc_vehiclesContext,0)

        def npc_vehicle_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicle_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_multi_npc" ):
                listener.enterMulti_multi_npc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_multi_npc" ):
                listener.exitMulti_multi_npc(self)


    class Multi_npcContext(Multi_npc_vehiclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_npc_vehiclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def npc_vehicle_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicle_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_npc" ):
                listener.enterMulti_npc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_npc" ):
                listener.exitMulti_npc(self)



    def multi_npc_vehicles(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multi_npc_vehiclesContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 86
        self.enterRecursionRule(localctx, 86, self.RULE_multi_npc_vehicles, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Multi_npcContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 640
            self.npc_vehicle_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 647
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,49,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Multi_multi_npcContext(self, AVScenariosParser.Multi_npc_vehiclesContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multi_npc_vehicles)
                    self.state = 642
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 643
                    self.match(AVScenariosParser.T__13)
                    self.state = 644
                    self.npc_vehicle_parameter() 
                self.state = 649
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,49,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Npc_vehicleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_npc_vehicle

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Npc_vehicle_parContext(Npc_vehicleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_npc(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_npcContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_vehicle_par" ):
                listener.enterNpc_vehicle_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_vehicle_par" ):
                listener.exitNpc_vehicle_par(self)



    def npc_vehicle(self):

        localctx = AVScenariosParser.Npc_vehicleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_npc_vehicle)
        try:
            localctx = AVScenariosParser.Npc_vehicle_parContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 650
            self.match(AVScenariosParser.T__39)
            self.state = 651
            self.match(AVScenariosParser.T__1)
            self.state = 652
            self.parameter_list_npc()
            self.state = 653
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Npc_vehicle_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_npc_vehicle_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Npc_npc_vehicle_varContext(Npc_vehicle_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicle_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_npc_vehicle_var" ):
                listener.enterNpc_npc_vehicle_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_npc_vehicle_var" ):
                listener.exitNpc_npc_vehicle_var(self)


    class Npc_npc_vehicleContext(Npc_vehicle_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Npc_vehicle_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def npc_vehicle(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNpc_npc_vehicle" ):
                listener.enterNpc_npc_vehicle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNpc_npc_vehicle" ):
                listener.exitNpc_npc_vehicle(self)



    def npc_vehicle_parameter(self):

        localctx = AVScenariosParser.Npc_vehicle_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_npc_vehicle_parameter)
        try:
            self.state = 657
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,50,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Npc_npc_vehicleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 655
                self.npc_vehicle()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Npc_npc_vehicle_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 656
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_npcContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_npc

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_npc_state_vehicleContext(Parameter_list_npcContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_npcContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)

        def vehicle_motion_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_motion_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_npc_state_vehicle" ):
                listener.enterPar_npc_state_vehicle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_npc_state_vehicle" ):
                listener.exitPar_npc_state_vehicle(self)


    class Par_npc_stateContext(Parameter_list_npcContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_npcContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_npc_state" ):
                listener.enterPar_npc_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_npc_state" ):
                listener.exitPar_npc_state(self)


    class Par_npc_state_vehicle_stateContext(Parameter_list_npcContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_npcContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.State_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,i)

        def vehicle_motion_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_motion_parameterContext,0)

        def vehicle_type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_type_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_npc_state_vehicle_state" ):
                listener.enterPar_npc_state_vehicle_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_npc_state_vehicle_state" ):
                listener.exitPar_npc_state_vehicle_state(self)



    def parameter_list_npc(self):

        localctx = AVScenariosParser.Parameter_list_npcContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_parameter_list_npc)
        self._la = 0 # Token type
        try:
            self.state = 677
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,54,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Par_npc_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 659
                self.state_parameter()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Par_npc_state_vehicleContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 660
                self.state_parameter()
                self.state = 661
                self.match(AVScenariosParser.T__13)
                self.state = 662
                self.vehicle_motion_parameter()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Par_npc_state_vehicle_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 664
                self.state_parameter()
                self.state = 665
                self.match(AVScenariosParser.T__13)
                self.state = 667
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 8)) & ~0x3f) == 0 and ((1 << (_la - 8)) & ((1 << (AVScenariosParser.T__7 - 8)) | (1 << (AVScenariosParser.T__11 - 8)) | (1 << (AVScenariosParser.T__12 - 8)) | (1 << (AVScenariosParser.T__16 - 8)) | (1 << (AVScenariosParser.T__17 - 8)) | (1 << (AVScenariosParser.T__18 - 8)) | (1 << (AVScenariosParser.T__23 - 8)) | (1 << (AVScenariosParser.T__24 - 8)) | (1 << (AVScenariosParser.T__25 - 8)) | (1 << (AVScenariosParser.T__26 - 8)) | (1 << (AVScenariosParser.T__27 - 8)) | (1 << (AVScenariosParser.T__28 - 8)) | (1 << (AVScenariosParser.T__29 - 8)) | (1 << (AVScenariosParser.T__30 - 8)) | (1 << (AVScenariosParser.T__31 - 8)) | (1 << (AVScenariosParser.T__32 - 8)) | (1 << (AVScenariosParser.T__33 - 8)) | (1 << (AVScenariosParser.T__39 - 8)) | (1 << (AVScenariosParser.T__40 - 8)) | (1 << (AVScenariosParser.T__41 - 8)) | (1 << (AVScenariosParser.T__42 - 8)) | (1 << (AVScenariosParser.T__43 - 8)) | (1 << (AVScenariosParser.T__44 - 8)) | (1 << (AVScenariosParser.T__45 - 8)) | (1 << (AVScenariosParser.T__46 - 8)) | (1 << (AVScenariosParser.T__47 - 8)) | (1 << (AVScenariosParser.T__48 - 8)) | (1 << (AVScenariosParser.T__49 - 8)) | (1 << (AVScenariosParser.T__54 - 8)) | (1 << (AVScenariosParser.T__64 - 8)) | (1 << (AVScenariosParser.T__65 - 8)) | (1 << (AVScenariosParser.T__68 - 8)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (AVScenariosParser.T__130 - 131)) | (1 << (AVScenariosParser.T__132 - 131)) | (1 << (AVScenariosParser.T__133 - 131)) | (1 << (AVScenariosParser.T__134 - 131)) | (1 << (AVScenariosParser.T__140 - 131)) | (1 << (AVScenariosParser.T__141 - 131)) | (1 << (AVScenariosParser.Variable_name - 131)))) != 0):
                    self.state = 666
                    self.vehicle_motion_parameter()


                self.state = 669
                self.match(AVScenariosParser.T__13)
                self.state = 671
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__1) | (1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (AVScenariosParser.T__130 - 131)) | (1 << (AVScenariosParser.T__132 - 131)) | (1 << (AVScenariosParser.T__133 - 131)) | (1 << (AVScenariosParser.T__134 - 131)) | (1 << (AVScenariosParser.T__140 - 131)) | (1 << (AVScenariosParser.T__141 - 131)) | (1 << (AVScenariosParser.Variable_name - 131)))) != 0):
                    self.state = 670
                    self.state_parameter()


                self.state = 675
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 673
                    self.match(AVScenariosParser.T__13)
                    self.state = 674
                    self.vehicle_type_parameter()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vehicle_motion_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_vehicle_motion_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Vehicle_vehicle_motionContext(Vehicle_motion_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_motion_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def vehicle_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_vehicle_motion" ):
                listener.enterVehicle_vehicle_motion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_vehicle_motion" ):
                listener.exitVehicle_vehicle_motion(self)


    class Vehicle_vehicle_motion_varContext(Vehicle_motion_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_motion_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_vehicle_motion_var" ):
                listener.enterVehicle_vehicle_motion_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_vehicle_motion_var" ):
                listener.exitVehicle_vehicle_motion_var(self)



    def vehicle_motion_parameter(self):

        localctx = AVScenariosParser.Vehicle_motion_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_vehicle_motion_parameter)
        try:
            self.state = 681
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,55,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Vehicle_vehicle_motionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 679
                self.vehicle_motion()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Vehicle_vehicle_motion_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 680
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Vehicle_motionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_vehicle_motion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Vehicle_motion_uniformContext(Vehicle_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def uniform_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Uniform_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_motion_uniform" ):
                listener.enterVehicle_motion_uniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_motion_uniform" ):
                listener.exitVehicle_motion_uniform(self)


    class Vehicle_motion_waypointContext(Vehicle_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Vehicle_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def waypoint_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Waypoint_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVehicle_motion_waypoint" ):
                listener.enterVehicle_motion_waypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVehicle_motion_waypoint" ):
                listener.exitVehicle_motion_waypoint(self)



    def vehicle_motion(self):

        localctx = AVScenariosParser.Vehicle_motionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_vehicle_motion)
        try:
            self.state = 685
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__40, AVScenariosParser.T__41]:
                localctx = AVScenariosParser.Vehicle_motion_uniformContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 683
                self.uniform_motion()
                pass
            elif token in [AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47]:
                localctx = AVScenariosParser.Vehicle_motion_waypointContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 684
                self.waypoint_motion()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Uniform_motionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_uniform_motion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class UniformContext(Uniform_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Uniform_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def uniform_index(self):
            return self.getTypedRuleContext(AVScenariosParser.Uniform_indexContext,0)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniform" ):
                listener.enterUniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniform" ):
                listener.exitUniform(self)



    def uniform_motion(self):

        localctx = AVScenariosParser.Uniform_motionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_uniform_motion)
        try:
            localctx = AVScenariosParser.UniformContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 687
            self.uniform_index()
            self.state = 688
            self.match(AVScenariosParser.T__1)
            self.state = 689
            self.state_parameter()
            self.state = 690
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Uniform_indexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_uniform_index

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Uniform_UniformContext(Uniform_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Uniform_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniform_Uniform" ):
                listener.enterUniform_Uniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniform_Uniform" ):
                listener.exitUniform_Uniform(self)


    class Uniform_uniformContext(Uniform_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Uniform_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUniform_uniform" ):
                listener.enterUniform_uniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUniform_uniform" ):
                listener.exitUniform_uniform(self)



    def uniform_index(self):

        localctx = AVScenariosParser.Uniform_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_uniform_index)
        try:
            self.state = 694
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__40]:
                localctx = AVScenariosParser.Uniform_uniformContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 692
                self.match(AVScenariosParser.T__40)
                pass
            elif token in [AVScenariosParser.T__41]:
                localctx = AVScenariosParser.Uniform_UniformContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 693
                self.match(AVScenariosParser.T__41)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Waypoint_motionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_waypoint_motion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class WaypointContext(Waypoint_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def waypoint_index(self):
            return self.getTypedRuleContext(AVScenariosParser.Waypoint_indexContext,0)

        def state_list_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_list_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint" ):
                listener.enterWaypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint" ):
                listener.exitWaypoint(self)



    def waypoint_motion(self):

        localctx = AVScenariosParser.Waypoint_motionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_waypoint_motion)
        try:
            localctx = AVScenariosParser.WaypointContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 696
            self.waypoint_index()
            self.state = 697
            self.match(AVScenariosParser.T__1)
            self.state = 698
            self.state_list_parameter()
            self.state = 699
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_list_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_state_list_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class State_state_listContext(State_list_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_list_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_list(self):
            return self.getTypedRuleContext(AVScenariosParser.State_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_state_list" ):
                listener.enterState_state_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_state_list" ):
                listener.exitState_state_list(self)


    class State_state_list_varContext(State_list_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_list_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_state_list_var" ):
                listener.enterState_state_list_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_state_list_var" ):
                listener.exitState_state_list_var(self)



    def state_list_parameter(self):

        localctx = AVScenariosParser.State_list_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_state_list_parameter)
        try:
            self.state = 703
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.State_state_list_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 701
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.State_state_listContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 702
                self.state_list()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class State_listContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_state_list

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class State_list_multiContext(State_listContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.State_listContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_states(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_statesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterState_list_multi" ):
                listener.enterState_list_multi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitState_list_multi" ):
                listener.exitState_list_multi(self)



    def state_list(self):

        localctx = AVScenariosParser.State_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_state_list)
        try:
            localctx = AVScenariosParser.State_list_multiContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 705
            self.match(AVScenariosParser.T__1)
            self.state = 706
            self.multi_states(0)
            self.state = 707
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_statesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multi_states

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Multi_states_parContext(Multi_statesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_statesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_states_par" ):
                listener.enterMulti_states_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_states_par" ):
                listener.exitMulti_states_par(self)


    class Multi_states_par_stateContext(Multi_statesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_statesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_states(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_statesContext,0)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_states_par_state" ):
                listener.enterMulti_states_par_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_states_par_state" ):
                listener.exitMulti_states_par_state(self)



    def multi_states(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multi_statesContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 108
        self.enterRecursionRule(localctx, 108, self.RULE_multi_states, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Multi_states_parContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 710
            self.state_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 717
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,59,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Multi_states_par_stateContext(self, AVScenariosParser.Multi_statesContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multi_states)
                    self.state = 712
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 713
                    self.match(AVScenariosParser.T__13)
                    self.state = 714
                    self.state_parameter() 
                self.state = 719
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,59,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Waypoint_indexContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_waypoint_index

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Waypoint_WPContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_WP" ):
                listener.enterWaypoint_WP(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_WP" ):
                listener.exitWaypoint_WP(self)


    class Waypoint_wpContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_wp" ):
                listener.enterWaypoint_wp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_wp" ):
                listener.exitWaypoint_wp(self)


    class Waypoint_WContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_W" ):
                listener.enterWaypoint_W(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_W" ):
                listener.exitWaypoint_W(self)


    class Waypoint_wContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_w" ):
                listener.enterWaypoint_w(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_w" ):
                listener.exitWaypoint_w(self)


    class Waypoint_waypointContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_waypoint" ):
                listener.enterWaypoint_waypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_waypoint" ):
                listener.exitWaypoint_waypoint(self)


    class Waypoint_WaypointContext(Waypoint_indexContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Waypoint_indexContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWaypoint_Waypoint" ):
                listener.enterWaypoint_Waypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWaypoint_Waypoint" ):
                listener.exitWaypoint_Waypoint(self)



    def waypoint_index(self):

        localctx = AVScenariosParser.Waypoint_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_waypoint_index)
        try:
            self.state = 726
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__42]:
                localctx = AVScenariosParser.Waypoint_WaypointContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 720
                self.match(AVScenariosParser.T__42)
                pass
            elif token in [AVScenariosParser.T__43]:
                localctx = AVScenariosParser.Waypoint_WContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 721
                self.match(AVScenariosParser.T__43)
                pass
            elif token in [AVScenariosParser.T__44]:
                localctx = AVScenariosParser.Waypoint_WPContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 722
                self.match(AVScenariosParser.T__44)
                pass
            elif token in [AVScenariosParser.T__45]:
                localctx = AVScenariosParser.Waypoint_waypointContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 723
                self.match(AVScenariosParser.T__45)
                pass
            elif token in [AVScenariosParser.T__46]:
                localctx = AVScenariosParser.Waypoint_wContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 724
                self.match(AVScenariosParser.T__46)
                pass
            elif token in [AVScenariosParser.T__47]:
                localctx = AVScenariosParser.Waypoint_wpContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 725
                self.match(AVScenariosParser.T__47)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PedestriansContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrians

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrians_multiContext(PedestriansContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PedestriansContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiple_pedestrians(self):
            return self.getTypedRuleContext(AVScenariosParser.Multiple_pedestriansContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrians_multi" ):
                listener.enterPedestrians_multi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrians_multi" ):
                listener.exitPedestrians_multi(self)



    def pedestrians(self):

        localctx = AVScenariosParser.PedestriansContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_pedestrians)
        try:
            localctx = AVScenariosParser.Pedestrians_multiContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 728
            self.match(AVScenariosParser.T__8)
            self.state = 729
            self.multiple_pedestrians(0)
            self.state = 730
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multiple_pedestriansContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multiple_pedestrians

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Multi_multi_pedestrianContext(Multiple_pedestriansContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multiple_pedestriansContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiple_pedestrians(self):
            return self.getTypedRuleContext(AVScenariosParser.Multiple_pedestriansContext,0)

        def pedestrian_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_multi_pedestrian" ):
                listener.enterMulti_multi_pedestrian(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_multi_pedestrian" ):
                listener.exitMulti_multi_pedestrian(self)


    class Multi_pedestrianContext(Multiple_pedestriansContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multiple_pedestriansContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrian_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMulti_pedestrian" ):
                listener.enterMulti_pedestrian(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMulti_pedestrian" ):
                listener.exitMulti_pedestrian(self)



    def multiple_pedestrians(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multiple_pedestriansContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 114
        self.enterRecursionRule(localctx, 114, self.RULE_multiple_pedestrians, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Multi_pedestrianContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 733
            self.pedestrian_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 740
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,61,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Multi_multi_pedestrianContext(self, AVScenariosParser.Multiple_pedestriansContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multiple_pedestrians)
                    self.state = 735
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 736
                    self.match(AVScenariosParser.T__13)
                    self.state = 737
                    self.pedestrian_parameter() 
                self.state = 742
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,61,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Pedestrian_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_pedestrian_varContext(Pedestrian_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_pedestrian_var" ):
                listener.enterPedestrian_pedestrian_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_pedestrian_var" ):
                listener.exitPedestrian_pedestrian_var(self)


    class Pedestrian_pedestrianContext(Pedestrian_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrian(self):
            return self.getTypedRuleContext(AVScenariosParser.PedestrianContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_pedestrian" ):
                listener.enterPedestrian_pedestrian(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_pedestrian" ):
                listener.exitPedestrian_pedestrian(self)



    def pedestrian_parameter(self):

        localctx = AVScenariosParser.Pedestrian_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_pedestrian_parameter)
        try:
            self.state = 745
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,62,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pedestrian_pedestrianContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 743
                self.pedestrian()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pedestrian_pedestrian_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 744
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class PedestrianContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_parContext(PedestrianContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.PedestrianContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_ped(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_pedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_par" ):
                listener.enterPedestrian_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_par" ):
                listener.exitPedestrian_par(self)



    def pedestrian(self):

        localctx = AVScenariosParser.PedestrianContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_pedestrian)
        try:
            localctx = AVScenariosParser.Pedestrian_parContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 747
            self.match(AVScenariosParser.T__48)
            self.state = 748
            self.match(AVScenariosParser.T__1)
            self.state = 749
            self.parameter_list_ped()
            self.state = 750
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_pedContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_ped

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_ped_state_ped_stateContext(Parameter_list_pedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_pedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.State_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,i)

        def pedestrian_motion_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_motion_parameterContext,0)

        def pedestrian_type_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_type_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_ped_state_ped_state" ):
                listener.enterPar_ped_state_ped_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_ped_state_ped_state" ):
                listener.exitPar_ped_state_ped_state(self)


    class Par_ped_state_pedContext(Parameter_list_pedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_pedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)

        def pedestrian_motion_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_motion_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_ped_state_ped" ):
                listener.enterPar_ped_state_ped(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_ped_state_ped" ):
                listener.exitPar_ped_state_ped(self)


    class Par_ped_stateContext(Parameter_list_pedContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_pedContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.State_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_ped_state" ):
                listener.enterPar_ped_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_ped_state" ):
                listener.exitPar_ped_state(self)



    def parameter_list_ped(self):

        localctx = AVScenariosParser.Parameter_list_pedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_parameter_list_ped)
        self._la = 0 # Token type
        try:
            self.state = 770
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,66,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Par_ped_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 752
                self.state_parameter()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Par_ped_state_pedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 753
                self.state_parameter()
                self.state = 754
                self.match(AVScenariosParser.T__13)
                self.state = 755
                self.pedestrian_motion_parameter()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Par_ped_state_ped_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 757
                self.state_parameter()
                self.state = 758
                self.match(AVScenariosParser.T__13)
                self.state = 760
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 8)) & ~0x3f) == 0 and ((1 << (_la - 8)) & ((1 << (AVScenariosParser.T__7 - 8)) | (1 << (AVScenariosParser.T__11 - 8)) | (1 << (AVScenariosParser.T__12 - 8)) | (1 << (AVScenariosParser.T__16 - 8)) | (1 << (AVScenariosParser.T__17 - 8)) | (1 << (AVScenariosParser.T__18 - 8)) | (1 << (AVScenariosParser.T__23 - 8)) | (1 << (AVScenariosParser.T__24 - 8)) | (1 << (AVScenariosParser.T__25 - 8)) | (1 << (AVScenariosParser.T__26 - 8)) | (1 << (AVScenariosParser.T__27 - 8)) | (1 << (AVScenariosParser.T__28 - 8)) | (1 << (AVScenariosParser.T__29 - 8)) | (1 << (AVScenariosParser.T__30 - 8)) | (1 << (AVScenariosParser.T__31 - 8)) | (1 << (AVScenariosParser.T__32 - 8)) | (1 << (AVScenariosParser.T__33 - 8)) | (1 << (AVScenariosParser.T__39 - 8)) | (1 << (AVScenariosParser.T__40 - 8)) | (1 << (AVScenariosParser.T__41 - 8)) | (1 << (AVScenariosParser.T__42 - 8)) | (1 << (AVScenariosParser.T__43 - 8)) | (1 << (AVScenariosParser.T__44 - 8)) | (1 << (AVScenariosParser.T__45 - 8)) | (1 << (AVScenariosParser.T__46 - 8)) | (1 << (AVScenariosParser.T__47 - 8)) | (1 << (AVScenariosParser.T__48 - 8)) | (1 << (AVScenariosParser.T__49 - 8)) | (1 << (AVScenariosParser.T__54 - 8)) | (1 << (AVScenariosParser.T__64 - 8)) | (1 << (AVScenariosParser.T__65 - 8)) | (1 << (AVScenariosParser.T__68 - 8)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (AVScenariosParser.T__130 - 131)) | (1 << (AVScenariosParser.T__132 - 131)) | (1 << (AVScenariosParser.T__133 - 131)) | (1 << (AVScenariosParser.T__134 - 131)) | (1 << (AVScenariosParser.T__140 - 131)) | (1 << (AVScenariosParser.T__141 - 131)) | (1 << (AVScenariosParser.Variable_name - 131)))) != 0):
                    self.state = 759
                    self.pedestrian_motion_parameter()


                self.state = 762
                self.match(AVScenariosParser.T__13)
                self.state = 764
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__1) | (1 << AVScenariosParser.T__7) | (1 << AVScenariosParser.T__11) | (1 << AVScenariosParser.T__12) | (1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18) | (1 << AVScenariosParser.T__23) | (1 << AVScenariosParser.T__24) | (1 << AVScenariosParser.T__25) | (1 << AVScenariosParser.T__26) | (1 << AVScenariosParser.T__27) | (1 << AVScenariosParser.T__28) | (1 << AVScenariosParser.T__29) | (1 << AVScenariosParser.T__30) | (1 << AVScenariosParser.T__31) | (1 << AVScenariosParser.T__32) | (1 << AVScenariosParser.T__33) | (1 << AVScenariosParser.T__39) | (1 << AVScenariosParser.T__40) | (1 << AVScenariosParser.T__41) | (1 << AVScenariosParser.T__42) | (1 << AVScenariosParser.T__43) | (1 << AVScenariosParser.T__44) | (1 << AVScenariosParser.T__45) | (1 << AVScenariosParser.T__46) | (1 << AVScenariosParser.T__47) | (1 << AVScenariosParser.T__48) | (1 << AVScenariosParser.T__49) | (1 << AVScenariosParser.T__54))) != 0) or ((((_la - 65)) & ~0x3f) == 0 and ((1 << (_la - 65)) & ((1 << (AVScenariosParser.T__64 - 65)) | (1 << (AVScenariosParser.T__65 - 65)) | (1 << (AVScenariosParser.T__68 - 65)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (AVScenariosParser.T__130 - 131)) | (1 << (AVScenariosParser.T__132 - 131)) | (1 << (AVScenariosParser.T__133 - 131)) | (1 << (AVScenariosParser.T__134 - 131)) | (1 << (AVScenariosParser.T__140 - 131)) | (1 << (AVScenariosParser.T__141 - 131)) | (1 << (AVScenariosParser.Variable_name - 131)))) != 0):
                    self.state = 763
                    self.state_parameter()


                self.state = 768
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 766
                    self.match(AVScenariosParser.T__13)
                    self.state = 767
                    self.pedestrian_type_parameter()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrian_motion_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_motion_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_motion_pedestrian_varContext(Pedestrian_motion_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_motion_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_motion_pedestrian_var" ):
                listener.enterPedestrian_motion_pedestrian_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_motion_pedestrian_var" ):
                listener.exitPedestrian_motion_pedestrian_var(self)


    class Pedestrian_motion_pedestrianContext(Pedestrian_motion_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_motion_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrian_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_motion_pedestrian" ):
                listener.enterPedestrian_motion_pedestrian(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_motion_pedestrian" ):
                listener.exitPedestrian_motion_pedestrian(self)



    def pedestrian_motion_parameter(self):

        localctx = AVScenariosParser.Pedestrian_motion_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_pedestrian_motion_parameter)
        try:
            self.state = 774
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,67,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Pedestrian_motion_pedestrianContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 772
                self.pedestrian_motion()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Pedestrian_motion_pedestrian_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 773
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrian_motionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_motion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_waypointContext(Pedestrian_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def waypoint_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Waypoint_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_waypoint" ):
                listener.enterPedestrian_waypoint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_waypoint" ):
                listener.exitPedestrian_waypoint(self)


    class Pedestrian_uniformContext(Pedestrian_motionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_motionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def uniform_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Uniform_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_uniform" ):
                listener.enterPedestrian_uniform(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_uniform" ):
                listener.exitPedestrian_uniform(self)



    def pedestrian_motion(self):

        localctx = AVScenariosParser.Pedestrian_motionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_pedestrian_motion)
        try:
            self.state = 778
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__40, AVScenariosParser.T__41]:
                localctx = AVScenariosParser.Pedestrian_uniformContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 776
                self.uniform_motion()
                pass
            elif token in [AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47]:
                localctx = AVScenariosParser.Pedestrian_waypointContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 777
                self.waypoint_motion()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrian_type_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_type_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_pedestrian_typeContext(Pedestrian_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def pedestrian_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_pedestrian_type" ):
                listener.enterPedestrian_pedestrian_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_pedestrian_type" ):
                listener.exitPedestrian_pedestrian_type(self)


    class Pedestrian_pedestrian_type_varContext(Pedestrian_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_pedestrian_type_var" ):
                listener.enterPedestrian_pedestrian_type_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_pedestrian_type_var" ):
                listener.exitPedestrian_pedestrian_type_var(self)


    class Pedestrian_type_nameContext(Pedestrian_type_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_type_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def String(self):
            return self.getToken(AVScenariosParser.String, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_type_name" ):
                listener.enterPedestrian_type_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_type_name" ):
                listener.exitPedestrian_type_name(self)



    def pedestrian_type_parameter(self):

        localctx = AVScenariosParser.Pedestrian_type_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_pedestrian_type_parameter)
        try:
            self.state = 783
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Pedestrian_pedestrian_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 780
                self.pedestrian_type()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Pedestrian_pedestrian_type_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 781
                self.identifier()
                pass
            elif token in [AVScenariosParser.String]:
                localctx = AVScenariosParser.Pedestrian_type_nameContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 782
                self.match(AVScenariosParser.String)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Pedestrian_typeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_pedestrian_type

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Pedestrian_type_height_colorContext(Pedestrian_typeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Pedestrian_typeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def height_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Height_parameterContext,0)

        def color_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Color_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPedestrian_type_height_color" ):
                listener.enterPedestrian_type_height_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPedestrian_type_height_color" ):
                listener.exitPedestrian_type_height_color(self)



    def pedestrian_type(self):

        localctx = AVScenariosParser.Pedestrian_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_pedestrian_type)
        try:
            localctx = AVScenariosParser.Pedestrian_type_height_colorContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 785
            self.match(AVScenariosParser.T__1)
            self.state = 786
            self.height_parameter()
            self.state = 787
            self.match(AVScenariosParser.T__13)
            self.state = 788
            self.color_parameter()
            self.state = 789
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Height_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_height_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Height_varContext(Height_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Height_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeight_var" ):
                listener.enterHeight_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeight_var" ):
                listener.exitHeight_var(self)


    class Height_heightContext(Height_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Height_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def height(self):
            return self.getTypedRuleContext(AVScenariosParser.HeightContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeight_height" ):
                listener.enterHeight_height(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeight_height" ):
                listener.exitHeight_height(self)



    def height_parameter(self):

        localctx = AVScenariosParser.Height_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_height_parameter)
        try:
            self.state = 793
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,70,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Height_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 791
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Height_heightContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 792
                self.height()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class HeightContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_height

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Height_rvContext(HeightContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.HeightContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterHeight_rv" ):
                listener.enterHeight_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitHeight_rv" ):
                listener.exitHeight_rv(self)



    def height(self):

        localctx = AVScenariosParser.HeightContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_height)
        try:
            localctx = AVScenariosParser.Height_rvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 795
            self.real_value_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ObstaclesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_obstacles

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Obstacles_multiContext(ObstaclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ObstaclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiple_obstacles(self):
            return self.getTypedRuleContext(AVScenariosParser.Multiple_obstaclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_multi" ):
                listener.enterObstacles_multi(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_multi" ):
                listener.exitObstacles_multi(self)



    def obstacles(self):

        localctx = AVScenariosParser.ObstaclesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_obstacles)
        try:
            localctx = AVScenariosParser.Obstacles_multiContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 797
            self.match(AVScenariosParser.T__8)
            self.state = 798
            self.multiple_obstacles(0)
            self.state = 799
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multiple_obstaclesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multiple_obstacles

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Obstacles_obstacleContext(Multiple_obstaclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multiple_obstaclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def obstacle_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Obstacle_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_obstacle" ):
                listener.enterObstacles_obstacle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_obstacle" ):
                listener.exitObstacles_obstacle(self)


    class Obstacles_multi_obstacleContext(Multiple_obstaclesContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multiple_obstaclesContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multiple_obstacles(self):
            return self.getTypedRuleContext(AVScenariosParser.Multiple_obstaclesContext,0)

        def obstacle_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Obstacle_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacles_multi_obstacle" ):
                listener.enterObstacles_multi_obstacle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacles_multi_obstacle" ):
                listener.exitObstacles_multi_obstacle(self)



    def multiple_obstacles(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multiple_obstaclesContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 136
        self.enterRecursionRule(localctx, 136, self.RULE_multiple_obstacles, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Obstacles_obstacleContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 802
            self.obstacle_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 809
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,71,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Obstacles_multi_obstacleContext(self, AVScenariosParser.Multiple_obstaclesContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multiple_obstacles)
                    self.state = 804
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 805
                    self.match(AVScenariosParser.T__13)
                    self.state = 806
                    self.obstacle_parameter() 
                self.state = 811
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,71,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Obstacle_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_obstacle_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Obstacle_obstacle_varContext(Obstacle_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacle_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacle_obstacle_var" ):
                listener.enterObstacle_obstacle_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacle_obstacle_var" ):
                listener.exitObstacle_obstacle_var(self)


    class Obstacle_obstacleContext(Obstacle_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Obstacle_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def obstacle(self):
            return self.getTypedRuleContext(AVScenariosParser.ObstacleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacle_obstacle" ):
                listener.enterObstacle_obstacle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacle_obstacle" ):
                listener.exitObstacle_obstacle(self)



    def obstacle_parameter(self):

        localctx = AVScenariosParser.Obstacle_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_obstacle_parameter)
        try:
            self.state = 814
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,72,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Obstacle_obstacleContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 812
                self.obstacle()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Obstacle_obstacle_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 813
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ObstacleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_obstacle

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Obstacle_paraContext(ObstacleContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ObstacleContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_obs(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_obsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterObstacle_para" ):
                listener.enterObstacle_para(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitObstacle_para" ):
                listener.exitObstacle_para(self)



    def obstacle(self):

        localctx = AVScenariosParser.ObstacleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_obstacle)
        try:
            localctx = AVScenariosParser.Obstacle_paraContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 816
            self.match(AVScenariosParser.T__49)
            self.state = 817
            self.match(AVScenariosParser.T__1)
            self.state = 818
            self.parameter_list_obs()
            self.state = 819
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_obsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_obs

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_position_shapeContext(Parameter_list_obsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_obsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def position_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Position_parameterContext,0)

        def shape_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Shape_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_position_shape" ):
                listener.enterPar_position_shape(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_position_shape" ):
                listener.exitPar_position_shape(self)



    def parameter_list_obs(self):

        localctx = AVScenariosParser.Parameter_list_obsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_parameter_list_obs)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.Par_position_shapeContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 821
            self.position_parameter()
            self.state = 824
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AVScenariosParser.T__13:
                self.state = 822
                self.match(AVScenariosParser.T__13)
                self.state = 823
                self.shape_parameter()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Shape_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_shape_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Shape_shape_varContext(Shape_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Shape_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_shape_var" ):
                listener.enterShape_shape_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_shape_var" ):
                listener.exitShape_shape_var(self)


    class Shape_shapeContext(Shape_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Shape_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def shape(self):
            return self.getTypedRuleContext(AVScenariosParser.ShapeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_shape" ):
                listener.enterShape_shape(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_shape" ):
                listener.exitShape_shape(self)



    def shape_parameter(self):

        localctx = AVScenariosParser.Shape_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_shape_parameter)
        try:
            self.state = 828
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Shape_shape_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 826
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Shape_shapeContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 827
                self.shape()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ShapeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_shape

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Shape_cylinderContext(ShapeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ShapeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cylinder(self):
            return self.getTypedRuleContext(AVScenariosParser.CylinderContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_cylinder" ):
                listener.enterShape_cylinder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_cylinder" ):
                listener.exitShape_cylinder(self)


    class Shape_sphereContext(ShapeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ShapeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def sphere(self):
            return self.getTypedRuleContext(AVScenariosParser.SphereContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_sphere" ):
                listener.enterShape_sphere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_sphere" ):
                listener.exitShape_sphere(self)


    class Shape_boxContext(ShapeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ShapeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def box(self):
            return self.getTypedRuleContext(AVScenariosParser.BoxContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_box" ):
                listener.enterShape_box(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_box" ):
                listener.exitShape_box(self)


    class Shape_coneContext(ShapeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ShapeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def cone(self):
            return self.getTypedRuleContext(AVScenariosParser.ConeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShape_cone" ):
                listener.enterShape_cone(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShape_cone" ):
                listener.exitShape_cone(self)



    def shape(self):

        localctx = AVScenariosParser.ShapeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_shape)
        try:
            self.state = 834
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Shape_sphereContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 830
                self.sphere()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Shape_boxContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 831
                self.box()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Shape_coneContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 832
                self.cone()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Shape_cylinderContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 833
                self.cylinder()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class SphereContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_sphere

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Sphere_sphereContext(SphereContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.SphereContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSphere_sphere" ):
                listener.enterSphere_sphere(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSphere_sphere" ):
                listener.exitSphere_sphere(self)



    def sphere(self):

        localctx = AVScenariosParser.SphereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_sphere)
        try:
            localctx = AVScenariosParser.Sphere_sphereContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 836
            self.match(AVScenariosParser.T__1)
            self.state = 837
            self.match(AVScenariosParser.T__50)
            self.state = 838
            self.match(AVScenariosParser.T__13)
            self.state = 839
            self.real_value_expression(0)
            self.state = 840
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BoxContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_box

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Box_boxContext(BoxContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.BoxContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBox_box" ):
                listener.enterBox_box(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBox_box" ):
                listener.exitBox_box(self)



    def box(self):

        localctx = AVScenariosParser.BoxContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_box)
        try:
            localctx = AVScenariosParser.Box_boxContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 842
            self.match(AVScenariosParser.T__1)
            self.state = 843
            self.match(AVScenariosParser.T__51)
            self.state = 844
            self.match(AVScenariosParser.T__13)
            self.state = 845
            self.real_value_expression(0)
            self.state = 846
            self.match(AVScenariosParser.T__13)
            self.state = 847
            self.real_value_expression(0)
            self.state = 848
            self.match(AVScenariosParser.T__13)
            self.state = 849
            self.real_value_expression(0)
            self.state = 850
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class ConeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_cone

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Cone_coneContext(ConeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.ConeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCone_cone" ):
                listener.enterCone_cone(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCone_cone" ):
                listener.exitCone_cone(self)



    def cone(self):

        localctx = AVScenariosParser.ConeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_cone)
        try:
            localctx = AVScenariosParser.Cone_coneContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 852
            self.match(AVScenariosParser.T__1)
            self.state = 853
            self.match(AVScenariosParser.T__52)
            self.state = 854
            self.match(AVScenariosParser.T__13)
            self.state = 855
            self.real_value_expression(0)
            self.state = 856
            self.match(AVScenariosParser.T__13)
            self.state = 857
            self.real_value_expression(0)
            self.state = 858
            self.match(AVScenariosParser.T__13)
            self.state = 859
            self.real_value_expression(0)
            self.state = 860
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class CylinderContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_cylinder

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Cylinder_cylinderContext(CylinderContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.CylinderContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCylinder_cylinder" ):
                listener.enterCylinder_cylinder(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCylinder_cylinder" ):
                listener.exitCylinder_cylinder(self)



    def cylinder(self):

        localctx = AVScenariosParser.CylinderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_cylinder)
        try:
            localctx = AVScenariosParser.Cylinder_cylinderContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 862
            self.match(AVScenariosParser.T__1)
            self.state = 863
            self.match(AVScenariosParser.T__53)
            self.state = 864
            self.match(AVScenariosParser.T__13)
            self.state = 865
            self.real_value_expression(0)
            self.state = 866
            self.match(AVScenariosParser.T__13)
            self.state = 867
            self.real_value_expression(0)
            self.state = 868
            self.match(AVScenariosParser.T__13)
            self.state = 869
            self.real_value_expression(0)
            self.state = 870
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Env_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_env_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Env_varContext(Env_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Env_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnv_var" ):
                listener.enterEnv_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnv_var" ):
                listener.exitEnv_var(self)


    class Env_emptyContext(Env_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Env_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnv_empty" ):
                listener.enterEnv_empty(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnv_empty" ):
                listener.exitEnv_empty(self)


    class Env_envContext(Env_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Env_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def env(self):
            return self.getTypedRuleContext(AVScenariosParser.EnvContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnv_env" ):
                listener.enterEnv_env(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnv_env" ):
                listener.exitEnv_env(self)



    def env_parameter(self):

        localctx = AVScenariosParser.Env_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_env_parameter)
        try:
            self.state = 876
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,76,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Env_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 872
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Env_envContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 873
                self.env()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Env_emptyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 874
                self.match(AVScenariosParser.T__8)
                self.state = 875
                self.match(AVScenariosParser.T__10)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class EnvContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_env

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Env_parContext(EnvContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.EnvContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def parameter_list_env(self):
            return self.getTypedRuleContext(AVScenariosParser.Parameter_list_envContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEnv_par" ):
                listener.enterEnv_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEnv_par" ):
                listener.exitEnv_par(self)



    def env(self):

        localctx = AVScenariosParser.EnvContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_env)
        try:
            localctx = AVScenariosParser.Env_parContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 878
            self.match(AVScenariosParser.T__54)
            self.state = 879
            self.match(AVScenariosParser.T__1)
            self.state = 880
            self.parameter_list_env()
            self.state = 881
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Parameter_list_envContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_parameter_list_env

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Par_time_weatherContext(Parameter_list_envContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Parameter_list_envContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def time_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Time_parameterContext,0)

        def weather_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPar_time_weather" ):
                listener.enterPar_time_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPar_time_weather" ):
                listener.exitPar_time_weather(self)



    def parameter_list_env(self):

        localctx = AVScenariosParser.Parameter_list_envContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_parameter_list_env)
        try:
            localctx = AVScenariosParser.Par_time_weatherContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 883
            self.time_parameter()
            self.state = 884
            self.match(AVScenariosParser.T__13)
            self.state = 885
            self.weather_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_varContext(Weather_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_var" ):
                listener.enterWeather_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_var" ):
                listener.exitWeather_var(self)


    class Weather_wtrContext(Weather_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def weather(self):
            return self.getTypedRuleContext(AVScenariosParser.WeatherContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_wtr" ):
                listener.enterWeather_wtr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_wtr" ):
                listener.exitWeather_wtr(self)



    def weather_parameter(self):

        localctx = AVScenariosParser.Weather_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_weather_parameter)
        try:
            self.state = 889
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Weather_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 887
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__8]:
                localctx = AVScenariosParser.Weather_wtrContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 888
                self.weather()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Time_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_time_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Time_timeContext(Time_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Time_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def time(self):
            return self.getTypedRuleContext(AVScenariosParser.TimeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_time" ):
                listener.enterTime_time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_time" ):
                listener.exitTime_time(self)


    class Time_time_varContext(Time_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Time_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_time_var" ):
                listener.enterTime_time_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_time_var" ):
                listener.exitTime_time_var(self)



    def time_parameter(self):

        localctx = AVScenariosParser.Time_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_time_parameter)
        try:
            self.state = 893
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.Time]:
                localctx = AVScenariosParser.Time_timeContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 891
                self.time()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Time_time_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 892
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TimeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_time

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Time_TimeContext(TimeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.TimeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def Time(self):
            return self.getToken(AVScenariosParser.Time, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTime_Time" ):
                listener.enterTime_Time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTime_Time" ):
                listener.exitTime_Time(self)



    def time(self):

        localctx = AVScenariosParser.TimeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_time)
        try:
            localctx = AVScenariosParser.Time_TimeContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 895
            self.match(AVScenariosParser.Time)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class WeatherContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class WeathersContext(WeatherContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.WeatherContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_weathers(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_weathersContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeathers" ):
                listener.enterWeathers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeathers" ):
                listener.exitWeathers(self)



    def weather(self):

        localctx = AVScenariosParser.WeatherContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_weather)
        try:
            localctx = AVScenariosParser.WeathersContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 897
            self.match(AVScenariosParser.T__8)
            self.state = 898
            self.multi_weathers(0)
            self.state = 899
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Multi_weathersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_multi_weathers

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Weathers_multi_weatherContext(Multi_weathersContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_weathersContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def multi_weathers(self):
            return self.getTypedRuleContext(AVScenariosParser.Multi_weathersContext,0)

        def weather_statement_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_statement_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeathers_multi_weather" ):
                listener.enterWeathers_multi_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeathers_multi_weather" ):
                listener.exitWeathers_multi_weather(self)


    class Weathers_weatherContext(Multi_weathersContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Multi_weathersContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def weather_statement_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_statement_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeathers_weather" ):
                listener.enterWeathers_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeathers_weather" ):
                listener.exitWeathers_weather(self)



    def multi_weathers(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Multi_weathersContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 170
        self.enterRecursionRule(localctx, 170, self.RULE_multi_weathers, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Weathers_weatherContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 902
            self.weather_statement_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 909
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,79,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Weathers_multi_weatherContext(self, AVScenariosParser.Multi_weathersContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_multi_weathers)
                    self.state = 904
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 905
                    self.match(AVScenariosParser.T__13)
                    self.state = 906
                    self.weather_statement_parameter() 
                self.state = 911
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,79,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Weather_statement_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_statement_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_weatherContext(Weather_statement_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_statement_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def weather_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_weather" ):
                listener.enterWeather_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_weather" ):
                listener.exitWeather_weather(self)


    class Weather_weather_varContext(Weather_statement_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_statement_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_weather_var" ):
                listener.enterWeather_weather_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_weather_var" ):
                listener.exitWeather_weather_var(self)



    def weather_statement_parameter(self):

        localctx = AVScenariosParser.Weather_statement_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_weather_statement_parameter)
        try:
            self.state = 914
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Weather_weather_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 912
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__56, AVScenariosParser.T__57, AVScenariosParser.T__58, AVScenariosParser.T__59, AVScenariosParser.T__60]:
                localctx = AVScenariosParser.Weather_weatherContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 913
                self.weather_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_discreteContext(Weather_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def kind(self):
            return self.getTypedRuleContext(AVScenariosParser.KindContext,0)

        def weather_discrete_level_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_discrete_level_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete" ):
                listener.enterWeather_discrete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete" ):
                listener.exitWeather_discrete(self)


    class Weather_continuousContext(Weather_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def kind(self):
            return self.getTypedRuleContext(AVScenariosParser.KindContext,0)

        def weather_continuous_index_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_continuous_index_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_continuous" ):
                listener.enterWeather_continuous(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_continuous" ):
                listener.exitWeather_continuous(self)



    def weather_statement(self):

        localctx = AVScenariosParser.Weather_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_weather_statement)
        try:
            self.state = 924
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,81,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Weather_continuousContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 916
                self.kind()
                self.state = 917
                self.match(AVScenariosParser.T__55)
                self.state = 918
                self.weather_continuous_index_parameter()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Weather_discreteContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 920
                self.kind()
                self.state = 921
                self.match(AVScenariosParser.T__55)
                self.state = 922
                self.weather_discrete_level_parameter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class KindContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_kind

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Kind_sunnyContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_sunny" ):
                listener.enterKind_sunny(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_sunny" ):
                listener.exitKind_sunny(self)


    class Kind_snowContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_snow" ):
                listener.enterKind_snow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_snow" ):
                listener.exitKind_snow(self)


    class Kind_rainContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_rain" ):
                listener.enterKind_rain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_rain" ):
                listener.exitKind_rain(self)


    class Kind_fogContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_fog" ):
                listener.enterKind_fog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_fog" ):
                listener.exitKind_fog(self)


    class Kind_wetnessContext(KindContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.KindContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterKind_wetness" ):
                listener.enterKind_wetness(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitKind_wetness" ):
                listener.exitKind_wetness(self)



    def kind(self):

        localctx = AVScenariosParser.KindContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_kind)
        try:
            self.state = 931
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__56]:
                localctx = AVScenariosParser.Kind_sunnyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 926
                self.match(AVScenariosParser.T__56)
                pass
            elif token in [AVScenariosParser.T__57]:
                localctx = AVScenariosParser.Kind_rainContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 927
                self.match(AVScenariosParser.T__57)
                pass
            elif token in [AVScenariosParser.T__58]:
                localctx = AVScenariosParser.Kind_snowContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 928
                self.match(AVScenariosParser.T__58)
                pass
            elif token in [AVScenariosParser.T__59]:
                localctx = AVScenariosParser.Kind_fogContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 929
                self.match(AVScenariosParser.T__59)
                pass
            elif token in [AVScenariosParser.T__60]:
                localctx = AVScenariosParser.Kind_wetnessContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 930
                self.match(AVScenariosParser.T__60)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_continuous_index_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_continuous_index_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_continuous_varContext(Weather_continuous_index_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_continuous_index_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_continuous_var" ):
                listener.enterWeather_continuous_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_continuous_var" ):
                listener.exitWeather_continuous_var(self)


    class Weather_continuous_valueContext(Weather_continuous_index_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_continuous_index_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def float_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Float_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_continuous_value" ):
                listener.enterWeather_continuous_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_continuous_value" ):
                listener.exitWeather_continuous_value(self)



    def weather_continuous_index_parameter(self):

        localctx = AVScenariosParser.Weather_continuous_index_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_weather_continuous_index_parameter)
        try:
            self.state = 935
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.Non_negative_value]:
                localctx = AVScenariosParser.Weather_continuous_valueContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 933
                self.float_value()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Weather_continuous_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 934
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_discrete_level_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_discrete_level_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_discrete_varContext(Weather_discrete_level_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_level_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_var" ):
                listener.enterWeather_discrete_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_var" ):
                listener.exitWeather_discrete_var(self)


    class Weather_discrete_level_parContext(Weather_discrete_level_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_level_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def weather_discrete_level(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_discrete_levelContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_level_par" ):
                listener.enterWeather_discrete_level_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_level_par" ):
                listener.exitWeather_discrete_level_par(self)



    def weather_discrete_level_parameter(self):

        localctx = AVScenariosParser.Weather_discrete_level_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_weather_discrete_level_parameter)
        try:
            self.state = 939
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__61, AVScenariosParser.T__62, AVScenariosParser.T__63]:
                localctx = AVScenariosParser.Weather_discrete_level_parContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 937
                self.weather_discrete_level()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Weather_discrete_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 938
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Weather_discrete_levelContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_weather_discrete_level

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Weather_discrete_middleContext(Weather_discrete_levelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_levelContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_middle" ):
                listener.enterWeather_discrete_middle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_middle" ):
                listener.exitWeather_discrete_middle(self)


    class Weather_discrete_heavyContext(Weather_discrete_levelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_levelContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_heavy" ):
                listener.enterWeather_discrete_heavy(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_heavy" ):
                listener.exitWeather_discrete_heavy(self)


    class Weather_discrete_lightContext(Weather_discrete_levelContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Weather_discrete_levelContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWeather_discrete_light" ):
                listener.enterWeather_discrete_light(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWeather_discrete_light" ):
                listener.exitWeather_discrete_light(self)



    def weather_discrete_level(self):

        localctx = AVScenariosParser.Weather_discrete_levelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_weather_discrete_level)
        try:
            self.state = 944
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__61]:
                localctx = AVScenariosParser.Weather_discrete_lightContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 941
                self.match(AVScenariosParser.T__61)
                pass
            elif token in [AVScenariosParser.T__62]:
                localctx = AVScenariosParser.Weather_discrete_middleContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 942
                self.match(AVScenariosParser.T__62)
                pass
            elif token in [AVScenariosParser.T__63]:
                localctx = AVScenariosParser.Weather_discrete_heavyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 943
                self.match(AVScenariosParser.T__63)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class TrafficContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_traffic

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Traffic_trafficContext(TrafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.TrafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def traffic_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Traffic_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_traffic" ):
                listener.enterTraffic_traffic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_traffic" ):
                listener.exitTraffic_traffic(self)



    def traffic(self):

        localctx = AVScenariosParser.TrafficContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_traffic)
        try:
            localctx = AVScenariosParser.Traffic_trafficContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 946
            self.match(AVScenariosParser.T__8)
            self.state = 947
            self.traffic_statement()
            self.state = 948
            self.match(AVScenariosParser.T__10)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Traffic_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_traffic_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Traffic_stmtContext(Traffic_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Traffic_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def intersection_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Intersection_trafficContext,0)

        def lane_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Lane_trafficContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_stmt" ):
                listener.enterTraffic_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_stmt" ):
                listener.exitTraffic_stmt(self)



    def traffic_statement(self):

        localctx = AVScenariosParser.Traffic_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_traffic_statement)
        try:
            localctx = AVScenariosParser.Traffic_stmtContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 950
            self.intersection_traffic()
            self.state = 951
            self.match(AVScenariosParser.T__13)
            self.state = 952
            self.lane_traffic(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Intersection_trafficContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_intersection_traffic

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class IntersectionContext(Intersection_trafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Intersection_trafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def meta_intersection_traffic_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Meta_intersection_traffic_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Meta_intersection_traffic_parameterContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection" ):
                listener.enterIntersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection" ):
                listener.exitIntersection(self)



    def intersection_traffic(self):

        localctx = AVScenariosParser.Intersection_trafficContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_intersection_traffic)
        try:
            localctx = AVScenariosParser.IntersectionContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 954
            self.meta_intersection_traffic_parameter()
            self.state = 959
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,86,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 955
                    self.match(AVScenariosParser.T__13)
                    self.state = 956
                    self.meta_intersection_traffic_parameter() 
                self.state = 961
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,86,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Meta_intersection_traffic_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_meta_intersection_traffic_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Meta_intersection_metaContext(Meta_intersection_traffic_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Meta_intersection_traffic_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def meta_intersection_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Meta_intersection_trafficContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeta_intersection_meta" ):
                listener.enterMeta_intersection_meta(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeta_intersection_meta" ):
                listener.exitMeta_intersection_meta(self)


    class Meta_intersection_meta_varContext(Meta_intersection_traffic_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Meta_intersection_traffic_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeta_intersection_meta_var" ):
                listener.enterMeta_intersection_meta_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeta_intersection_meta_var" ):
                listener.exitMeta_intersection_meta_var(self)



    def meta_intersection_traffic_parameter(self):

        localctx = AVScenariosParser.Meta_intersection_traffic_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_meta_intersection_traffic_parameter)
        try:
            self.state = 964
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,87,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Meta_intersection_meta_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 962
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Meta_intersection_metaContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 963
                self.meta_intersection_traffic()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Meta_intersection_trafficContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_meta_intersection_traffic

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Meta_intersection_intersectionContext(Meta_intersection_trafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Meta_intersection_trafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def intersection_ID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Intersection_ID_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMeta_intersection_intersection" ):
                listener.enterMeta_intersection_intersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMeta_intersection_intersection" ):
                listener.exitMeta_intersection_intersection(self)



    def meta_intersection_traffic(self):

        localctx = AVScenariosParser.Meta_intersection_trafficContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_meta_intersection_traffic)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.Meta_intersection_intersectionContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 966
            self.match(AVScenariosParser.T__64)
            self.state = 967
            self.match(AVScenariosParser.T__1)
            self.state = 968
            self.intersection_ID_parameter()
            self.state = 969
            self.match(AVScenariosParser.T__13)
            self.state = 970
            _la = self._input.LA(1)
            if not(_la==AVScenariosParser.T__19 or _la==AVScenariosParser.T__20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 971
            self.match(AVScenariosParser.T__13)
            self.state = 972
            _la = self._input.LA(1)
            if not(_la==AVScenariosParser.T__19 or _la==AVScenariosParser.T__20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 973
            self.match(AVScenariosParser.T__13)
            self.state = 974
            _la = self._input.LA(1)
            if not(_la==AVScenariosParser.T__19 or _la==AVScenariosParser.T__20):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 975
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Intersection_ID_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_intersection_ID_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Intersection_intersection_varContext(Intersection_ID_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Intersection_ID_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection_intersection_var" ):
                listener.enterIntersection_intersection_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection_intersection_var" ):
                listener.exitIntersection_intersection_var(self)


    class Intersection_intersectionContext(Intersection_ID_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Intersection_ID_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def intersection_ID(self):
            return self.getTypedRuleContext(AVScenariosParser.Intersection_IDContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection_intersection" ):
                listener.enterIntersection_intersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection_intersection" ):
                listener.exitIntersection_intersection(self)



    def intersection_ID_parameter(self):

        localctx = AVScenariosParser.Intersection_ID_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_intersection_ID_parameter)
        try:
            self.state = 979
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__0, AVScenariosParser.T__6, AVScenariosParser.T__19, AVScenariosParser.T__20, AVScenariosParser.Non_negative_number]:
                localctx = AVScenariosParser.Intersection_intersectionContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 977
                self.intersection_ID()
                pass
            elif token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Intersection_intersection_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 978
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Intersection_IDContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_intersection_ID

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Intersection_signalContext(Intersection_IDContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Intersection_IDContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def number_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Number_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIntersection_signal" ):
                listener.enterIntersection_signal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIntersection_signal" ):
                listener.exitIntersection_signal(self)



    def intersection_ID(self):

        localctx = AVScenariosParser.Intersection_IDContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_intersection_ID)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.Intersection_signalContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 982
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6:
                self.state = 981
                localctx.op = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                    localctx.op = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 984
            self.number_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Lane_trafficContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_lane_traffic

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Lane_lane_speed_limitContext(Lane_trafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Lane_trafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def lane_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Lane_trafficContext,0)

        def speed_limitation_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_limitation_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLane_lane_speed_limit" ):
                listener.enterLane_lane_speed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLane_lane_speed_limit" ):
                listener.exitLane_lane_speed_limit(self)


    class Lane_speed_limitContext(Lane_trafficContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Lane_trafficContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed_limitation_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_limitation_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLane_speed_limit" ):
                listener.enterLane_speed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLane_speed_limit" ):
                listener.exitLane_speed_limit(self)



    def lane_traffic(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Lane_trafficContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 198
        self.enterRecursionRule(localctx, 198, self.RULE_lane_traffic, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            localctx = AVScenariosParser.Lane_speed_limitContext(self, localctx)
            self._ctx = localctx
            _prevctx = localctx

            self.state = 987
            self.speed_limitation_parameter()
            self._ctx.stop = self._input.LT(-1)
            self.state = 994
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,90,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Lane_lane_speed_limitContext(self, AVScenariosParser.Lane_trafficContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_lane_traffic)
                    self.state = 989
                    if not self.precpred(self._ctx, 1):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 1)")
                    self.state = 990
                    self.match(AVScenariosParser.T__13)
                    self.state = 991
                    self.speed_limitation_parameter() 
                self.state = 996
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,90,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Speed_limitation_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_limitation_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_limitContext(Speed_limitation_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_limitation_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed_limitation(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_limitationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_limit" ):
                listener.enterSpeed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_limit" ):
                listener.exitSpeed_limit(self)


    class Speed_limit_varContext(Speed_limitation_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_limitation_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_limit_var" ):
                listener.enterSpeed_limit_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_limit_var" ):
                listener.exitSpeed_limit_var(self)



    def speed_limitation_parameter(self):

        localctx = AVScenariosParser.Speed_limitation_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_speed_limitation_parameter)
        try:
            self.state = 999
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,91,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Speed_limitContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 997
                self.speed_limitation()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Speed_limit_varContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 998
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_limitationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_limitation

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_limit_speed_limitContext(Speed_limitationContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_limitationContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def speed_range_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_range_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_limit_speed_limit" ):
                listener.enterSpeed_limit_speed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_limit_speed_limit" ):
                listener.exitSpeed_limit_speed_limit(self)



    def speed_limitation(self):

        localctx = AVScenariosParser.Speed_limitationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_speed_limitation)
        try:
            localctx = AVScenariosParser.Speed_limit_speed_limitContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1001
            self.match(AVScenariosParser.T__65)
            self.state = 1002
            self.match(AVScenariosParser.T__1)
            self.state = 1003
            self.laneID_parameter()
            self.state = 1004
            self.match(AVScenariosParser.T__13)
            self.state = 1005
            self.speed_range_parameter()
            self.state = 1006
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_range_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_range_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_range_varContext(Speed_range_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_range_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_range_var" ):
                listener.enterSpeed_range_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_range_var" ):
                listener.exitSpeed_range_var(self)


    class Speed_range_speedContext(Speed_range_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_range_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed_range(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_rangeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_range_speed" ):
                listener.enterSpeed_range_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_range_speed" ):
                listener.exitSpeed_range_speed(self)



    def speed_range_parameter(self):

        localctx = AVScenariosParser.Speed_range_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_speed_range_parameter)
        try:
            self.state = 1010
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__7, AVScenariosParser.T__11, AVScenariosParser.T__12, AVScenariosParser.T__16, AVScenariosParser.T__17, AVScenariosParser.T__18, AVScenariosParser.T__23, AVScenariosParser.T__24, AVScenariosParser.T__25, AVScenariosParser.T__26, AVScenariosParser.T__27, AVScenariosParser.T__28, AVScenariosParser.T__29, AVScenariosParser.T__30, AVScenariosParser.T__31, AVScenariosParser.T__32, AVScenariosParser.T__33, AVScenariosParser.T__39, AVScenariosParser.T__40, AVScenariosParser.T__41, AVScenariosParser.T__42, AVScenariosParser.T__43, AVScenariosParser.T__44, AVScenariosParser.T__45, AVScenariosParser.T__46, AVScenariosParser.T__47, AVScenariosParser.T__48, AVScenariosParser.T__49, AVScenariosParser.T__54, AVScenariosParser.T__64, AVScenariosParser.T__65, AVScenariosParser.T__68, AVScenariosParser.T__130, AVScenariosParser.T__132, AVScenariosParser.T__133, AVScenariosParser.T__134, AVScenariosParser.T__140, AVScenariosParser.T__141, AVScenariosParser.Variable_name]:
                localctx = AVScenariosParser.Speed_range_varContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1008
                self.identifier()
                pass
            elif token in [AVScenariosParser.T__1]:
                localctx = AVScenariosParser.Speed_range_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1009
                self.speed_range()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_rangeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_range

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_range_valueContext(Speed_rangeContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_rangeContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_range_value" ):
                listener.enterSpeed_range_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_range_value" ):
                listener.exitSpeed_range_value(self)



    def speed_range(self):

        localctx = AVScenariosParser.Speed_rangeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_speed_range)
        try:
            localctx = AVScenariosParser.Speed_range_valueContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1012
            self.match(AVScenariosParser.T__1)
            self.state = 1013
            self.real_value_expression(0)
            self.state = 1014
            self.match(AVScenariosParser.T__13)
            self.state = 1015
            self.real_value_expression(0)
            self.state = 1016
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Trace_assignmentContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_trace_assignment

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Trace_scenarioContext(Trace_assignmentContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Trace_assignmentContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrace_scenario" ):
                listener.enterTrace_scenario(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrace_scenario" ):
                listener.exitTrace_scenario(self)



    def trace_assignment(self):

        localctx = AVScenariosParser.Trace_assignmentContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_trace_assignment)
        try:
            localctx = AVScenariosParser.Trace_scenarioContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1018
            self.match(AVScenariosParser.T__66)
            self.state = 1019
            self.identifier()
            self.state = 1020
            self.match(AVScenariosParser.T__67)
            self.state = 1021
            self.match(AVScenariosParser.T__68)
            self.state = 1022
            self.match(AVScenariosParser.T__1)
            self.state = 1023
            self.identifier()
            self.state = 1024
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Trace_identifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_trace_identifier

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Trace_idContext(Trace_identifierContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Trace_identifierContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrace_id" ):
                listener.enterTrace_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrace_id" ):
                listener.exitTrace_id(self)



    def trace_identifier(self):

        localctx = AVScenariosParser.Trace_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_trace_identifier)
        try:
            localctx = AVScenariosParser.Trace_idContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1026
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Compare_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_compare_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCompare_operator" ):
                listener.enterCompare_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCompare_operator" ):
                listener.exitCompare_operator(self)




    def compare_operator(self):

        localctx = AVScenariosParser.Compare_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_compare_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1028
            _la = self._input.LA(1)
            if not(((((_la - 70)) & ~0x3f) == 0 and ((1 << (_la - 70)) & ((1 << (AVScenariosParser.T__69 - 70)) | (1 << (AVScenariosParser.T__70 - 70)) | (1 << (AVScenariosParser.T__71 - 70)) | (1 << (AVScenariosParser.T__72 - 70)) | (1 << (AVScenariosParser.T__73 - 70)) | (1 << (AVScenariosParser.T__74 - 70)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Temporal_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def a(self):
            return self.getTypedRuleContext(AVScenariosParser.AContext,0)


        def b(self):
            return self.getTypedRuleContext(AVScenariosParser.BContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_temporal_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporal_operator" ):
                listener.enterTemporal_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporal_operator" ):
                listener.exitTemporal_operator(self)




    def temporal_operator(self):

        localctx = AVScenariosParser.Temporal_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_temporal_operator)
        try:
            self.state = 1054
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,93,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1030
                self.match(AVScenariosParser.T__75)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1031
                self.match(AVScenariosParser.T__76)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1032
                self.match(AVScenariosParser.T__77)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1033
                self.match(AVScenariosParser.T__75)
                self.state = 1034
                self.match(AVScenariosParser.T__78)
                self.state = 1035
                self.a()
                self.state = 1036
                self.match(AVScenariosParser.T__13)
                self.state = 1037
                self.b()
                self.state = 1038
                self.match(AVScenariosParser.T__79)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1040
                self.match(AVScenariosParser.T__76)
                self.state = 1041
                self.match(AVScenariosParser.T__78)
                self.state = 1042
                self.a()
                self.state = 1043
                self.match(AVScenariosParser.T__13)
                self.state = 1044
                self.b()
                self.state = 1045
                self.match(AVScenariosParser.T__79)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1047
                self.match(AVScenariosParser.T__77)
                self.state = 1048
                self.match(AVScenariosParser.T__78)
                self.state = 1049
                self.a()
                self.state = 1050
                self.match(AVScenariosParser.T__13)
                self.state = 1051
                self.b()
                self.state = 1052
                self.match(AVScenariosParser.T__79)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Temporal_operator1Context(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def a(self):
            return self.getTypedRuleContext(AVScenariosParser.AContext,0)


        def b(self):
            return self.getTypedRuleContext(AVScenariosParser.BContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_temporal_operator1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporal_operator1" ):
                listener.enterTemporal_operator1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporal_operator1" ):
                listener.exitTemporal_operator1(self)




    def temporal_operator1(self):

        localctx = AVScenariosParser.Temporal_operator1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_temporal_operator1)
        try:
            self.state = 1064
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,94,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1056
                self.match(AVScenariosParser.T__80)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1057
                self.match(AVScenariosParser.T__80)
                self.state = 1058
                self.match(AVScenariosParser.T__78)
                self.state = 1059
                self.a()
                self.state = 1060
                self.match(AVScenariosParser.T__13)
                self.state = 1061
                self.b()
                self.state = 1062
                self.match(AVScenariosParser.T__79)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_a

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class A_rvContext(AContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.AContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterA_rv" ):
                listener.enterA_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitA_rv" ):
                listener.exitA_rv(self)



    def a(self):

        localctx = AVScenariosParser.AContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_a)
        try:
            localctx = AVScenariosParser.A_rvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1066
            self.real_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class BContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_b

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class B_rvContext(BContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.BContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterB_rv" ):
                listener.enterB_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitB_rv" ):
                listener.exitB_rv(self)



    def b(self):

        localctx = AVScenariosParser.BContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_b)
        try:
            localctx = AVScenariosParser.B_rvContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1068
            self.real_value()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Atom_statement_overallContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_atom_statement_overall

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class Atom_statement_overall_atom_statementContext(Atom_statement_overallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_overallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_overall_atom_statement" ):
                listener.enterAtom_statement_overall_atom_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_overall_atom_statement" ):
                listener.exitAtom_statement_overall_atom_statement(self)


    class Atom_statement_overall_with_kuohaoContext(Atom_statement_overallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_overallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_statement_overall(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_statement_overallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_overall_with_kuohao" ):
                listener.enterAtom_statement_overall_with_kuohao(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_overall_with_kuohao" ):
                listener.exitAtom_statement_overall_with_kuohao(self)


    class Atom_statement_idContext(Atom_statement_overallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_overallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_id" ):
                listener.enterAtom_statement_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_id" ):
                listener.exitAtom_statement_id(self)


    class Atom_statement_overall_combinationContext(Atom_statement_overallContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_overallContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_statement_overall(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Atom_statement_overallContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Atom_statement_overallContext,i)

        def arithmetic_operator(self):
            return self.getTypedRuleContext(AVScenariosParser.Arithmetic_operatorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_overall_combination" ):
                listener.enterAtom_statement_overall_combination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_overall_combination" ):
                listener.exitAtom_statement_overall_combination(self)



    def atom_statement_overall(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.Atom_statement_overallContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 222
        self.enterRecursionRule(localctx, 222, self.RULE_atom_statement_overall, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1077
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,95,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Atom_statement_overall_atom_statementContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1071
                self.atom_statement()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Atom_statement_overall_with_kuohaoContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1072
                self.match(AVScenariosParser.T__1)
                self.state = 1073
                self.atom_statement_overall(0)
                self.state = 1074
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Atom_statement_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1076
                self.identifier()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1085
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,96,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = AVScenariosParser.Atom_statement_overall_combinationContext(self, AVScenariosParser.Atom_statement_overallContext(self, _parentctx, _parentState))
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_atom_statement_overall)
                    self.state = 1079
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 1080
                    self.arithmetic_operator()
                    self.state = 1081
                    self.atom_statement_overall(3) 
                self.state = 1087
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,96,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Atom_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_atom_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Acceleration_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def acceleration_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Acceleration_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_statement_for_general_statement" ):
                listener.enterAcceleration_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_statement_for_general_statement" ):
                listener.exitAcceleration_statement_for_general_statement(self)


    class Velocity_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def velocity_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Velocity_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_statement_for_general_statement" ):
                listener.enterVelocity_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_statement_for_general_statement" ):
                listener.exitVelocity_statement_for_general_statement(self)


    class Distance_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def distance_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Distance_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistance_statement_for_general_statement" ):
                listener.enterDistance_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistance_statement_for_general_statement" ):
                listener.exitDistance_statement_for_general_statement(self)


    class Perception_difference_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def perception_difference_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Perception_difference_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPerception_difference_statement_for_general_statement" ):
                listener.enterPerception_difference_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPerception_difference_statement_for_general_statement" ):
                listener.exitPerception_difference_statement_for_general_statement(self)


    class Speed_statement_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_statement_for_general_statement" ):
                listener.enterSpeed_statement_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_statement_for_general_statement" ):
                listener.exitSpeed_statement_for_general_statement(self)


    class Traffic_rule_value_related_APIsContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def value_related_APIs(self):
            return self.getTypedRuleContext(AVScenariosParser.Value_related_APIsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_value_related_APIs" ):
                listener.enterTraffic_rule_value_related_APIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_value_related_APIs" ):
                listener.exitTraffic_rule_value_related_APIs(self)


    class Real_value_for_general_statementContext(Atom_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_valueContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReal_value_for_general_statement" ):
                listener.enterReal_value_for_general_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReal_value_for_general_statement" ):
                listener.exitReal_value_for_general_statement(self)



    def atom_statement(self):

        localctx = AVScenariosParser.Atom_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_atom_statement)
        try:
            self.state = 1095
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Distance_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1088
                self.distance_statement()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Perception_difference_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1089
                self.perception_difference_statement()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Velocity_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1090
                self.velocity_statement()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Speed_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1091
                self.speed_statement()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Acceleration_statement_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1092
                self.acceleration_statement()
                pass

            elif la_ == 6:
                localctx = AVScenariosParser.Real_value_for_general_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1093
                self.real_value()
                pass

            elif la_ == 7:
                localctx = AVScenariosParser.Traffic_rule_value_related_APIsContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1094
                self.value_related_APIs()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Boolean_related_APIsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_boolean_related_APIs

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Traffic_rule_honkingAllowedContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_honkingAllowed" ):
                listener.enterTraffic_rule_honkingAllowed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_honkingAllowed" ):
                listener.exitTraffic_rule_honkingAllowed(self)


    class Traffic_rule_engineOnContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_engineOn" ):
                listener.enterTraffic_rule_engineOn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_engineOn" ):
                listener.exitTraffic_rule_engineOn(self)


    class Traffic_rule_PriorityPedsAheadContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_PriorityPedsAhead" ):
                listener.enterTraffic_rule_PriorityPedsAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_PriorityPedsAhead" ):
                listener.exitTraffic_rule_PriorityPedsAhead(self)


    class Traffic_rule_NearestNPCContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_NearestNPC" ):
                listener.enterTraffic_rule_NearestNPC(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_NearestNPC" ):
                listener.exitTraffic_rule_NearestNPC(self)


    class Traffic_rule_NPCOppositeContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_NPCOpposite" ):
                listener.enterTraffic_rule_NPCOpposite(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_NPCOpposite" ):
                listener.exitTraffic_rule_NPCOpposite(self)


    class Traffic_rule_isLaneChangingContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_isLaneChanging" ):
                listener.enterTraffic_rule_isLaneChanging(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_isLaneChanging" ):
                listener.exitTraffic_rule_isLaneChanging(self)


    class Traffic_rule_streetLightOnContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_streetLightOn" ):
                listener.enterTraffic_rule_streetLightOn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_streetLightOn" ):
                listener.exitTraffic_rule_streetLightOn(self)


    class Traffic_rule_stopSignAheadContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_stopSignAhead" ):
                listener.enterTraffic_rule_stopSignAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_stopSignAhead" ):
                listener.exitTraffic_rule_stopSignAhead(self)


    class Traffic_rule_hornOnContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_hornOn" ):
                listener.enterTraffic_rule_hornOn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_hornOn" ):
                listener.exitTraffic_rule_hornOn(self)


    class Traffic_rule_lowBeamOnContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_lowBeamOn" ):
                listener.enterTraffic_rule_lowBeamOn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_lowBeamOn" ):
                listener.exitTraffic_rule_lowBeamOn(self)


    class Traffic_rule_fogLightOnContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_fogLightOn" ):
                listener.enterTraffic_rule_fogLightOn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_fogLightOn" ):
                listener.exitTraffic_rule_fogLightOn(self)


    class Traffic_rule_highBeamOnContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_highBeamOn" ):
                listener.enterTraffic_rule_highBeamOn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_highBeamOn" ):
                listener.exitTraffic_rule_highBeamOn(self)


    class Traffic_rule_NPCAheadContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_NPCAhead" ):
                listener.enterTraffic_rule_NPCAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_NPCAhead" ):
                listener.exitTraffic_rule_NPCAhead(self)


    class Traffic_rule_warningFlashOnContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_warningFlashOn" ):
                listener.enterTraffic_rule_warningFlashOn(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_warningFlashOn" ):
                listener.exitTraffic_rule_warningFlashOn(self)


    class Traffic_rule_isTurningAroundContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_isTurningAround" ):
                listener.enterTraffic_rule_isTurningAround(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_isTurningAround" ):
                listener.exitTraffic_rule_isTurningAround(self)


    class Traffic_rule_isOverTakingContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_isOverTaking" ):
                listener.enterTraffic_rule_isOverTaking(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_isOverTaking" ):
                listener.exitTraffic_rule_isOverTaking(self)


    class Traffic_rule_specialLocationAheadContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_specialLocationAhead" ):
                listener.enterTraffic_rule_specialLocationAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_specialLocationAhead" ):
                listener.exitTraffic_rule_specialLocationAhead(self)


    class Traffic_rule_trafficLightAhead_arrow_blinkContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_trafficLightAhead_arrow_blink" ):
                listener.enterTraffic_rule_trafficLightAhead_arrow_blink(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_trafficLightAhead_arrow_blink" ):
                listener.exitTraffic_rule_trafficLightAhead_arrow_blink(self)


    class Traffic_rule_crosswalkAheadContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_crosswalkAhead" ):
                listener.enterTraffic_rule_crosswalkAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_crosswalkAhead" ):
                listener.exitTraffic_rule_crosswalkAhead(self)


    class Traffic_rule_stoplineAheadContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_stoplineAhead" ):
                listener.enterTraffic_rule_stoplineAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_stoplineAhead" ):
                listener.exitTraffic_rule_stoplineAhead(self)


    class Traffic_rule_PriorityNPCAheadContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_PriorityNPCAhead" ):
                listener.enterTraffic_rule_PriorityNPCAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_PriorityNPCAhead" ):
                listener.exitTraffic_rule_PriorityNPCAhead(self)


    class Traffic_rule_junctionAheadContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_junctionAhead" ):
                listener.enterTraffic_rule_junctionAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_junctionAhead" ):
                listener.exitTraffic_rule_junctionAhead(self)


    class Traffic_rule_isTrafficJamContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_isTrafficJam" ):
                listener.enterTraffic_rule_isTrafficJam(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_isTrafficJam" ):
                listener.exitTraffic_rule_isTrafficJam(self)


    class Traffic_rule_manualInterventionContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_manualIntervention" ):
                listener.enterTraffic_rule_manualIntervention(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_manualIntervention" ):
                listener.exitTraffic_rule_manualIntervention(self)


    class Traffic_rule_TimeContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def compare_operator(self):
            return self.getTypedRuleContext(AVScenariosParser.Compare_operatorContext,0)

        def time_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Time_parameterContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_Time" ):
                listener.enterTraffic_rule_Time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_Time" ):
                listener.exitTraffic_rule_Time(self)


    class Traffic_rule_trafficLightAhead_blinkContext(Boolean_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Boolean_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_trafficLightAhead_blink" ):
                listener.enterTraffic_rule_trafficLightAhead_blink(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_trafficLightAhead_blink" ):
                listener.exitTraffic_rule_trafficLightAhead_blink(self)



    def boolean_related_APIs(self):

        localctx = AVScenariosParser.Boolean_related_APIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_boolean_related_APIs)
        try:
            self.state = 1158
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__81]:
                localctx = AVScenariosParser.Traffic_rule_highBeamOnContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1097
                self.match(AVScenariosParser.T__81)
                pass
            elif token in [AVScenariosParser.T__82]:
                localctx = AVScenariosParser.Traffic_rule_lowBeamOnContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1098
                self.match(AVScenariosParser.T__82)
                pass
            elif token in [AVScenariosParser.T__83]:
                localctx = AVScenariosParser.Traffic_rule_fogLightOnContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1099
                self.match(AVScenariosParser.T__83)
                pass
            elif token in [AVScenariosParser.T__84]:
                localctx = AVScenariosParser.Traffic_rule_hornOnContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1100
                self.match(AVScenariosParser.T__84)
                pass
            elif token in [AVScenariosParser.T__85]:
                localctx = AVScenariosParser.Traffic_rule_warningFlashOnContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1101
                self.match(AVScenariosParser.T__85)
                pass
            elif token in [AVScenariosParser.T__86]:
                localctx = AVScenariosParser.Traffic_rule_engineOnContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1102
                self.match(AVScenariosParser.T__86)
                pass
            elif token in [AVScenariosParser.T__87]:
                localctx = AVScenariosParser.Traffic_rule_isLaneChangingContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1103
                self.match(AVScenariosParser.T__87)
                pass
            elif token in [AVScenariosParser.T__88]:
                localctx = AVScenariosParser.Traffic_rule_isOverTakingContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1104
                self.match(AVScenariosParser.T__88)
                pass
            elif token in [AVScenariosParser.T__89]:
                localctx = AVScenariosParser.Traffic_rule_isTurningAroundContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 1105
                self.match(AVScenariosParser.T__89)
                pass
            elif token in [AVScenariosParser.T__90]:
                localctx = AVScenariosParser.Traffic_rule_manualInterventionContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 1106
                self.match(AVScenariosParser.T__90)
                pass
            elif token in [AVScenariosParser.T__91]:
                localctx = AVScenariosParser.Traffic_rule_honkingAllowedContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 1107
                self.match(AVScenariosParser.T__91)
                pass
            elif token in [AVScenariosParser.T__92]:
                localctx = AVScenariosParser.Traffic_rule_crosswalkAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 1108
                self.match(AVScenariosParser.T__92)
                self.state = 1109
                self.match(AVScenariosParser.T__1)
                self.state = 1110
                self.real_value_expression(0)
                self.state = 1111
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__93]:
                localctx = AVScenariosParser.Traffic_rule_junctionAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 1113
                self.match(AVScenariosParser.T__93)
                self.state = 1114
                self.match(AVScenariosParser.T__1)
                self.state = 1115
                self.real_value_expression(0)
                self.state = 1116
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__94]:
                localctx = AVScenariosParser.Traffic_rule_stopSignAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 1118
                self.match(AVScenariosParser.T__94)
                self.state = 1119
                self.match(AVScenariosParser.T__1)
                self.state = 1120
                self.real_value_expression(0)
                self.state = 1121
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__95]:
                localctx = AVScenariosParser.Traffic_rule_stoplineAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 1123
                self.match(AVScenariosParser.T__95)
                self.state = 1124
                self.match(AVScenariosParser.T__1)
                self.state = 1125
                self.real_value_expression(0)
                self.state = 1126
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__96]:
                localctx = AVScenariosParser.Traffic_rule_streetLightOnContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 1128
                self.match(AVScenariosParser.T__96)
                pass
            elif token in [AVScenariosParser.T__97]:
                localctx = AVScenariosParser.Traffic_rule_specialLocationAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 1129
                self.match(AVScenariosParser.T__97)
                self.state = 1130
                self.match(AVScenariosParser.T__1)
                self.state = 1131
                self.real_value_expression(0)
                self.state = 1132
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__98]:
                localctx = AVScenariosParser.Traffic_rule_trafficLightAhead_blinkContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 1134
                self.match(AVScenariosParser.T__98)
                pass
            elif token in [AVScenariosParser.T__99]:
                localctx = AVScenariosParser.Traffic_rule_PriorityNPCAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 1135
                self.match(AVScenariosParser.T__99)
                pass
            elif token in [AVScenariosParser.T__100]:
                localctx = AVScenariosParser.Traffic_rule_PriorityPedsAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 1136
                self.match(AVScenariosParser.T__100)
                pass
            elif token in [AVScenariosParser.T__101]:
                localctx = AVScenariosParser.Traffic_rule_isTrafficJamContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 1137
                self.match(AVScenariosParser.T__101)
                pass
            elif token in [AVScenariosParser.T__102]:
                localctx = AVScenariosParser.Traffic_rule_NPCAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 1138
                self.match(AVScenariosParser.T__102)
                self.state = 1139
                self.match(AVScenariosParser.T__1)
                self.state = 1140
                self.real_value_expression(0)
                self.state = 1141
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__103]:
                localctx = AVScenariosParser.Traffic_rule_NearestNPCContext(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 1143
                self.match(AVScenariosParser.T__103)
                self.state = 1144
                self.match(AVScenariosParser.T__1)
                self.state = 1145
                self.real_value_expression(0)
                self.state = 1146
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__104]:
                localctx = AVScenariosParser.Traffic_rule_NPCOppositeContext(self, localctx)
                self.enterOuterAlt(localctx, 24)
                self.state = 1148
                self.match(AVScenariosParser.T__104)
                self.state = 1149
                self.match(AVScenariosParser.T__1)
                self.state = 1150
                self.real_value_expression(0)
                self.state = 1151
                self.match(AVScenariosParser.T__2)
                pass
            elif token in [AVScenariosParser.T__105]:
                localctx = AVScenariosParser.Traffic_rule_trafficLightAhead_arrow_blinkContext(self, localctx)
                self.enterOuterAlt(localctx, 25)
                self.state = 1153
                self.match(AVScenariosParser.T__105)
                pass
            elif token in [AVScenariosParser.T__106]:
                localctx = AVScenariosParser.Traffic_rule_TimeContext(self, localctx)
                self.enterOuterAlt(localctx, 26)
                self.state = 1154
                self.match(AVScenariosParser.T__106)
                self.state = 1155
                self.compare_operator()
                self.state = 1156
                self.time_parameter()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Value_related_APIsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_value_related_APIs

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Traffic_rule_directionContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_direction" ):
                listener.enterTraffic_rule_direction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_direction" ):
                listener.exitTraffic_rule_direction(self)


    class Traffic_rule_trafficLightAhead_colorContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_trafficLightAhead_color" ):
                listener.enterTraffic_rule_trafficLightAhead_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_trafficLightAhead_color" ):
                listener.exitTraffic_rule_trafficLightAhead_color(self)


    class Traffic_rule_NPCOpposite_speedContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_NPCOpposite_speed" ):
                listener.enterTraffic_rule_NPCOpposite_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_NPCOpposite_speed" ):
                listener.exitTraffic_rule_NPCOpposite_speed(self)


    class Traffic_rule_speedLimit_specialLocationAhead_typeContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_speedLimit_specialLocationAhead_type" ):
                listener.enterTraffic_rule_speedLimit_specialLocationAhead_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_speedLimit_specialLocationAhead_type" ):
                listener.exitTraffic_rule_speedLimit_specialLocationAhead_type(self)


    class Traffic_rule_gearContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_gear" ):
                listener.enterTraffic_rule_gear(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_gear" ):
                listener.exitTraffic_rule_gear(self)


    class Traffic_rule_rainContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_rain" ):
                listener.enterTraffic_rule_rain(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_rain" ):
                listener.exitTraffic_rule_rain(self)


    class Traffic_rule_currentlane_directionContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_currentlane_direction" ):
                listener.enterTraffic_rule_currentlane_direction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_currentlane_direction" ):
                listener.exitTraffic_rule_currentlane_direction(self)


    class Traffic_rule_turnSignalContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_turnSignal" ):
                listener.enterTraffic_rule_turnSignal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_turnSignal" ):
                listener.exitTraffic_rule_turnSignal(self)


    class Traffic_rule_currentlane_numberContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_currentlane_number" ):
                listener.enterTraffic_rule_currentlane_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_currentlane_number" ):
                listener.exitTraffic_rule_currentlane_number(self)


    class Traffic_rule_brakeContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_brake" ):
                listener.enterTraffic_rule_brake(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_brake" ):
                listener.exitTraffic_rule_brake(self)


    class Traffic_rule_speedLimit_upperLimitContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_speedLimit_upperLimit" ):
                listener.enterTraffic_rule_speedLimit_upperLimit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_speedLimit_upperLimit" ):
                listener.exitTraffic_rule_speedLimit_upperLimit(self)


    class Traffic_rule_fogContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_fog" ):
                listener.enterTraffic_rule_fog(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_fog" ):
                listener.exitTraffic_rule_fog(self)


    class Traffic_rule_speedContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_speed" ):
                listener.enterTraffic_rule_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_speed" ):
                listener.exitTraffic_rule_speed(self)


    class Traffic_rule_leftContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_left" ):
                listener.enterTraffic_rule_left(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_left" ):
                listener.exitTraffic_rule_left(self)


    class Traffic_rule_speedLimit_lowerLimitContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_speedLimit_lowerLimit" ):
                listener.enterTraffic_rule_speedLimit_lowerLimit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_speedLimit_lowerLimit" ):
                listener.exitTraffic_rule_speedLimit_lowerLimit(self)


    class Traffic_rule_rightContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_right" ):
                listener.enterTraffic_rule_right(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_right" ):
                listener.exitTraffic_rule_right(self)


    class Traffic_rule_offContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_off" ):
                listener.enterTraffic_rule_off(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_off" ):
                listener.exitTraffic_rule_off(self)


    class Traffic_rule_NearestNPC_speedContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_NearestNPC_speed" ):
                listener.enterTraffic_rule_NearestNPC_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_NearestNPC_speed" ):
                listener.exitTraffic_rule_NearestNPC_speed(self)


    class Traffic_rule_redContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_red" ):
                listener.enterTraffic_rule_red(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_red" ):
                listener.exitTraffic_rule_red(self)


    class Traffic_rule_trafficLightAhead_arrow_colorContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_trafficLightAhead_arrow_color" ):
                listener.enterTraffic_rule_trafficLightAhead_arrow_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_trafficLightAhead_arrow_color" ):
                listener.exitTraffic_rule_trafficLightAhead_arrow_color(self)


    class Traffic_rule_snowContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_snow" ):
                listener.enterTraffic_rule_snow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_snow" ):
                listener.exitTraffic_rule_snow(self)


    class Traffic_rule_greenContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_green" ):
                listener.enterTraffic_rule_green(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_green" ):
                listener.exitTraffic_rule_green(self)


    class Traffic_rule_NPCAhead_speedContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_NPCAhead_speed" ):
                listener.enterTraffic_rule_NPCAhead_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_NPCAhead_speed" ):
                listener.exitTraffic_rule_NPCAhead_speed(self)


    class Traffic_rule_signalAheadContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_signalAhead" ):
                listener.enterTraffic_rule_signalAhead(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_signalAhead" ):
                listener.exitTraffic_rule_signalAhead(self)


    class Traffic_rule_accContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_acc" ):
                listener.enterTraffic_rule_acc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_acc" ):
                listener.exitTraffic_rule_acc(self)


    class Traffic_rule_visibilityContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_visibility" ):
                listener.enterTraffic_rule_visibility(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_visibility" ):
                listener.exitTraffic_rule_visibility(self)


    class Traffic_rule_yellowContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_yellow" ):
                listener.enterTraffic_rule_yellow(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_yellow" ):
                listener.exitTraffic_rule_yellow(self)


    class Traffic_rule_forwardContext(Value_related_APIsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Value_related_APIsContext
            super().__init__(parser)
            self.copyFrom(ctx)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_forward" ):
                listener.enterTraffic_rule_forward(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_forward" ):
                listener.exitTraffic_rule_forward(self)



    def value_related_APIs(self):

        localctx = AVScenariosParser.Value_related_APIsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_value_related_APIs)
        try:
            self.state = 1188
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [AVScenariosParser.T__107]:
                localctx = AVScenariosParser.Traffic_rule_turnSignalContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1160
                self.match(AVScenariosParser.T__107)
                pass
            elif token in [AVScenariosParser.T__108]:
                localctx = AVScenariosParser.Traffic_rule_gearContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1161
                self.match(AVScenariosParser.T__108)
                pass
            elif token in [AVScenariosParser.T__109]:
                localctx = AVScenariosParser.Traffic_rule_directionContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1162
                self.match(AVScenariosParser.T__109)
                pass
            elif token in [AVScenariosParser.T__110]:
                localctx = AVScenariosParser.Traffic_rule_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1163
                self.match(AVScenariosParser.T__110)
                pass
            elif token in [AVScenariosParser.T__111]:
                localctx = AVScenariosParser.Traffic_rule_accContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1164
                self.match(AVScenariosParser.T__111)
                pass
            elif token in [AVScenariosParser.T__112]:
                localctx = AVScenariosParser.Traffic_rule_brakeContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1165
                self.match(AVScenariosParser.T__112)
                pass
            elif token in [AVScenariosParser.T__113]:
                localctx = AVScenariosParser.Traffic_rule_currentlane_numberContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1166
                self.match(AVScenariosParser.T__113)
                pass
            elif token in [AVScenariosParser.T__114]:
                localctx = AVScenariosParser.Traffic_rule_currentlane_directionContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1167
                self.match(AVScenariosParser.T__114)
                pass
            elif token in [AVScenariosParser.T__115]:
                localctx = AVScenariosParser.Traffic_rule_speedLimit_upperLimitContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 1168
                self.match(AVScenariosParser.T__115)
                pass
            elif token in [AVScenariosParser.T__116]:
                localctx = AVScenariosParser.Traffic_rule_speedLimit_lowerLimitContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 1169
                self.match(AVScenariosParser.T__116)
                pass
            elif token in [AVScenariosParser.T__117]:
                localctx = AVScenariosParser.Traffic_rule_speedLimit_specialLocationAhead_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 1170
                self.match(AVScenariosParser.T__117)
                pass
            elif token in [AVScenariosParser.T__118]:
                localctx = AVScenariosParser.Traffic_rule_trafficLightAhead_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 1171
                self.match(AVScenariosParser.T__118)
                pass
            elif token in [AVScenariosParser.T__119]:
                localctx = AVScenariosParser.Traffic_rule_signalAheadContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 1172
                self.match(AVScenariosParser.T__119)
                pass
            elif token in [AVScenariosParser.T__120]:
                localctx = AVScenariosParser.Traffic_rule_NPCAhead_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 1173
                self.match(AVScenariosParser.T__120)
                pass
            elif token in [AVScenariosParser.T__121]:
                localctx = AVScenariosParser.Traffic_rule_NearestNPC_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 1174
                self.match(AVScenariosParser.T__121)
                pass
            elif token in [AVScenariosParser.T__122]:
                localctx = AVScenariosParser.Traffic_rule_NPCOpposite_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 1175
                self.match(AVScenariosParser.T__122)
                pass
            elif token in [AVScenariosParser.T__123]:
                localctx = AVScenariosParser.Traffic_rule_trafficLightAhead_arrow_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 1176
                self.match(AVScenariosParser.T__123)
                pass
            elif token in [AVScenariosParser.T__35]:
                localctx = AVScenariosParser.Traffic_rule_greenContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 1177
                self.match(AVScenariosParser.T__35)
                pass
            elif token in [AVScenariosParser.T__34]:
                localctx = AVScenariosParser.Traffic_rule_redContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 1178
                self.match(AVScenariosParser.T__34)
                pass
            elif token in [AVScenariosParser.T__124]:
                localctx = AVScenariosParser.Traffic_rule_yellowContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 1179
                self.match(AVScenariosParser.T__124)
                pass
            elif token in [AVScenariosParser.T__125]:
                localctx = AVScenariosParser.Traffic_rule_offContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 1180
                self.match(AVScenariosParser.T__125)
                pass
            elif token in [AVScenariosParser.T__126]:
                localctx = AVScenariosParser.Traffic_rule_forwardContext(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 1181
                self.match(AVScenariosParser.T__126)
                pass
            elif token in [AVScenariosParser.T__127]:
                localctx = AVScenariosParser.Traffic_rule_leftContext(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 1182
                self.match(AVScenariosParser.T__127)
                pass
            elif token in [AVScenariosParser.T__128]:
                localctx = AVScenariosParser.Traffic_rule_rightContext(self, localctx)
                self.enterOuterAlt(localctx, 24)
                self.state = 1183
                self.match(AVScenariosParser.T__128)
                pass
            elif token in [AVScenariosParser.T__59]:
                localctx = AVScenariosParser.Traffic_rule_fogContext(self, localctx)
                self.enterOuterAlt(localctx, 25)
                self.state = 1184
                self.match(AVScenariosParser.T__59)
                pass
            elif token in [AVScenariosParser.T__57]:
                localctx = AVScenariosParser.Traffic_rule_rainContext(self, localctx)
                self.enterOuterAlt(localctx, 26)
                self.state = 1185
                self.match(AVScenariosParser.T__57)
                pass
            elif token in [AVScenariosParser.T__58]:
                localctx = AVScenariosParser.Traffic_rule_snowContext(self, localctx)
                self.enterOuterAlt(localctx, 27)
                self.state = 1186
                self.match(AVScenariosParser.T__58)
                pass
            elif token in [AVScenariosParser.T__129]:
                localctx = AVScenariosParser.Traffic_rule_visibilityContext(self, localctx)
                self.enterOuterAlt(localctx, 28)
                self.state = 1187
                self.match(AVScenariosParser.T__129)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Distance_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def position_element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Position_elementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Position_elementContext,i)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_distance_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDistance_statement" ):
                listener.enterDistance_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDistance_statement" ):
                listener.exitDistance_statement(self)




    def distance_statement(self):

        localctx = AVScenariosParser.Distance_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_distance_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1190
            self.match(AVScenariosParser.T__130)
            self.state = 1191
            self.match(AVScenariosParser.T__1)
            self.state = 1192
            self.position_element()
            self.state = 1193
            self.match(AVScenariosParser.T__13)
            self.state = 1194
            self.position_element()
            self.state = 1195
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Position_elementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_position_element

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_ground_truth_parameter_for_distanceContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_ground_truth_parameter_for_distance" ):
                listener.enterAgent_ground_truth_parameter_for_distance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_ground_truth_parameter_for_distance" ):
                listener.exitAgent_ground_truth_parameter_for_distance(self)


    class Agent_state_parameter_for_distanceContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_state_parameter_for_distance" ):
                listener.enterAgent_state_parameter_for_distance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_state_parameter_for_distance" ):
                listener.exitAgent_state_parameter_for_distance(self)


    class Ego_state_parameter_for_distanceContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_state_parameter_for_distance" ):
                listener.enterEgo_state_parameter_for_distance(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_state_parameter_for_distance" ):
                listener.exitEgo_state_parameter_for_distance(self)


    class Position_parameter_for_generalContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def position(self):
            return self.getTypedRuleContext(AVScenariosParser.PositionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition_parameter_for_general" ):
                listener.enterPosition_parameter_for_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition_parameter_for_general" ):
                listener.exitPosition_parameter_for_general(self)


    class Position_element_idContext(Position_elementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Position_elementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPosition_element_id" ):
                listener.enterPosition_element_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPosition_element_id" ):
                listener.exitPosition_element_id(self)



    def position_element(self):

        localctx = AVScenariosParser.Position_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_position_element)
        try:
            self.state = 1202
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Ego_state_parameter_for_distanceContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1197
                self.ego_state()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Agent_state_parameter_for_distanceContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1198
                self.agent_state()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Agent_ground_truth_parameter_for_distanceContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1199
                self.agent_ground_truth()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Position_parameter_for_generalContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1200
                self.position()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Position_element_idContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1201
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ego_state_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_ego_state_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Ego_state_idContext(Ego_state_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_state_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_state_id" ):
                listener.enterEgo_state_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_state_id" ):
                listener.exitEgo_state_id(self)


    class Ego_state_parContext(Ego_state_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_state_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_state_par" ):
                listener.enterEgo_state_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_state_par" ):
                listener.exitEgo_state_par(self)



    def ego_state_parameter(self):

        localctx = AVScenariosParser.Ego_state_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_ego_state_parameter)
        try:
            self.state = 1206
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,101,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Ego_state_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1204
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Ego_state_parContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1205
                self.ego_state()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Ego_stateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_ego_state

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Ego_state_for_generalContext(Ego_stateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Ego_stateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_identifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterEgo_state_for_general" ):
                listener.enterEgo_state_for_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitEgo_state_for_general" ):
                listener.exitEgo_state_for_general(self)



    def ego_state(self):

        localctx = AVScenariosParser.Ego_stateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_ego_state)
        try:
            localctx = AVScenariosParser.Ego_state_for_generalContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1208
            self.trace_identifier()
            self.state = 1209
            self.match(AVScenariosParser.T__78)
            self.state = 1210
            self.match(AVScenariosParser.T__131)
            self.state = 1211
            self.match(AVScenariosParser.T__79)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Agent_state_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_agent_state_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_state_parContext(Agent_state_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_state_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_state_par" ):
                listener.enterAgent_state_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_state_par" ):
                listener.exitAgent_state_par(self)


    class Agent_state_idContext(Agent_state_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_state_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_state_id" ):
                listener.enterAgent_state_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_state_id" ):
                listener.exitAgent_state_id(self)



    def agent_state_parameter(self):

        localctx = AVScenariosParser.Agent_state_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_agent_state_parameter)
        try:
            self.state = 1215
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,102,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Agent_state_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1213
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Agent_state_parContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1214
                self.agent_state()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Agent_stateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_agent_state

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_state_for_generalContext(Agent_stateContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_stateContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_identifierContext,0)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_state_for_general" ):
                listener.enterAgent_state_for_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_state_for_general" ):
                listener.exitAgent_state_for_general(self)



    def agent_state(self):

        localctx = AVScenariosParser.Agent_stateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_agent_state)
        try:
            localctx = AVScenariosParser.Agent_state_for_generalContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1217
            self.trace_identifier()
            self.state = 1218
            self.match(AVScenariosParser.T__78)
            self.state = 1219
            self.match(AVScenariosParser.T__132)
            self.state = 1220
            self.match(AVScenariosParser.T__79)
            self.state = 1221
            self.match(AVScenariosParser.T__78)
            self.state = 1222
            self.identifier()
            self.state = 1223
            self.match(AVScenariosParser.T__79)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Agent_ground_truth_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_agent_ground_truth_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_ground_truth_idContext(Agent_ground_truth_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_ground_truth_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_ground_truth_id" ):
                listener.enterAgent_ground_truth_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_ground_truth_id" ):
                listener.exitAgent_ground_truth_id(self)


    class Agent_ground_truth_parContext(Agent_ground_truth_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_ground_truth_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_ground_truth_par" ):
                listener.enterAgent_ground_truth_par(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_ground_truth_par" ):
                listener.exitAgent_ground_truth_par(self)



    def agent_ground_truth_parameter(self):

        localctx = AVScenariosParser.Agent_ground_truth_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_agent_ground_truth_parameter)
        try:
            self.state = 1227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,103,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Agent_ground_truth_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1225
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Agent_ground_truth_parContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1226
                self.agent_ground_truth()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Agent_ground_truthContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_agent_ground_truth

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Agent_ground_truth_for_generalContext(Agent_ground_truthContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Agent_ground_truthContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_identifierContext,0)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgent_ground_truth_for_general" ):
                listener.enterAgent_ground_truth_for_general(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgent_ground_truth_for_general" ):
                listener.exitAgent_ground_truth_for_general(self)



    def agent_ground_truth(self):

        localctx = AVScenariosParser.Agent_ground_truthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_agent_ground_truth)
        try:
            localctx = AVScenariosParser.Agent_ground_truth_for_generalContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1229
            self.trace_identifier()
            self.state = 1230
            self.match(AVScenariosParser.T__78)
            self.state = 1231
            self.match(AVScenariosParser.T__133)
            self.state = 1232
            self.match(AVScenariosParser.T__79)
            self.state = 1233
            self.match(AVScenariosParser.T__78)
            self.state = 1234
            self.identifier()
            self.state = 1235
            self.match(AVScenariosParser.T__79)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Perception_difference_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def agent_state_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_state_parameterContext,0)


        def agent_ground_truth_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truth_parameterContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_perception_difference_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPerception_difference_statement" ):
                listener.enterPerception_difference_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPerception_difference_statement" ):
                listener.exitPerception_difference_statement(self)




    def perception_difference_statement(self):

        localctx = AVScenariosParser.Perception_difference_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_perception_difference_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1237
            self.match(AVScenariosParser.T__134)
            self.state = 1238
            self.match(AVScenariosParser.T__1)
            self.state = 1239
            self.agent_state_parameter()
            self.state = 1240
            self.match(AVScenariosParser.T__13)
            self.state = 1241
            self.agent_ground_truth_parameter()
            self.state = 1242
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Velocity_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def velocity_parameter_for_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Velocity_parameter_for_statementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Velocity_parameter_for_statementContext,i)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_velocity_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_statement" ):
                listener.enterVelocity_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_statement" ):
                listener.exitVelocity_statement(self)




    def velocity_statement(self):

        localctx = AVScenariosParser.Velocity_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_velocity_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1244
            self.match(AVScenariosParser.T__135)
            self.state = 1245
            self.match(AVScenariosParser.T__1)
            self.state = 1246
            self.velocity_parameter_for_statement()
            self.state = 1247
            self.match(AVScenariosParser.T__13)
            self.state = 1248
            self.velocity_parameter_for_statement()
            self.state = 1249
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Velocity_parameter_for_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_velocity_parameter_for_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Velocity_element_agent_stateContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_agent_state" ):
                listener.enterVelocity_element_agent_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_agent_state" ):
                listener.exitVelocity_element_agent_state(self)


    class Velocity_element_ego_stateContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_ego_state" ):
                listener.enterVelocity_element_ego_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_ego_state" ):
                listener.exitVelocity_element_ego_state(self)


    class Velocity_element_idContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_id" ):
                listener.enterVelocity_element_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_id" ):
                listener.exitVelocity_element_id(self)


    class Velocity_element_velocityContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def velocity(self):
            return self.getTypedRuleContext(AVScenariosParser.VelocityContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_velocity" ):
                listener.enterVelocity_element_velocity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_velocity" ):
                listener.exitVelocity_element_velocity(self)


    class Velocity_element_agent_ground_truthContext(Velocity_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Velocity_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_element_agent_ground_truth" ):
                listener.enterVelocity_element_agent_ground_truth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_element_agent_ground_truth" ):
                listener.exitVelocity_element_agent_ground_truth(self)



    def velocity_parameter_for_statement(self):

        localctx = AVScenariosParser.Velocity_parameter_for_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_velocity_parameter_for_statement)
        try:
            self.state = 1256
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Velocity_element_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1251
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Velocity_element_ego_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1252
                self.ego_state()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Velocity_element_agent_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1253
                self.agent_state()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Velocity_element_agent_ground_truthContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1254
                self.agent_ground_truth()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Velocity_element_velocityContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1255
                self.velocity()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Velocity_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def velocity(self):
            return self.getTypedRuleContext(AVScenariosParser.VelocityContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_velocity_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_parameter" ):
                listener.enterVelocity_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_parameter" ):
                listener.exitVelocity_parameter(self)




    def velocity_parameter(self):

        localctx = AVScenariosParser.Velocity_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_velocity_parameter)
        try:
            self.state = 1260
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1258
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1259
                self.velocity()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class VelocityContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_velocity

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Velocity_valueContext(VelocityContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.VelocityContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVelocity_value" ):
                listener.enterVelocity_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVelocity_value" ):
                listener.exitVelocity_value(self)



    def velocity(self):

        localctx = AVScenariosParser.VelocityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_velocity)
        try:
            localctx = AVScenariosParser.Velocity_valueContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1262
            self.coordinate_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def speed_parameter_for_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Speed_parameter_for_statementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Speed_parameter_for_statementContext,i)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_statement" ):
                listener.enterSpeed_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_statement" ):
                listener.exitSpeed_statement(self)




    def speed_statement(self):

        localctx = AVScenariosParser.Speed_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_speed_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1264
            self.match(AVScenariosParser.T__136)
            self.state = 1265
            self.match(AVScenariosParser.T__1)
            self.state = 1266
            self.speed_parameter_for_statement()
            self.state = 1267
            self.match(AVScenariosParser.T__13)
            self.state = 1268
            self.speed_parameter_for_statement()
            self.state = 1269
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Speed_parameter_for_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_speed_parameter_for_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Speed_element_speedContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def speed(self):
            return self.getTypedRuleContext(AVScenariosParser.SpeedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_speed" ):
                listener.enterSpeed_element_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_speed" ):
                listener.exitSpeed_element_speed(self)


    class Speed_element_ego_stateContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_ego_state" ):
                listener.enterSpeed_element_ego_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_ego_state" ):
                listener.exitSpeed_element_ego_state(self)


    class Speed_element_agent_stateContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_agent_state" ):
                listener.enterSpeed_element_agent_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_agent_state" ):
                listener.exitSpeed_element_agent_state(self)


    class Speed_element_idContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_id" ):
                listener.enterSpeed_element_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_id" ):
                listener.exitSpeed_element_id(self)


    class Speed_element_agent_ground_truthContext(Speed_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Speed_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSpeed_element_agent_ground_truth" ):
                listener.enterSpeed_element_agent_ground_truth(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSpeed_element_agent_ground_truth" ):
                listener.exitSpeed_element_agent_ground_truth(self)



    def speed_parameter_for_statement(self):

        localctx = AVScenariosParser.Speed_parameter_for_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_speed_parameter_for_statement)
        try:
            self.state = 1276
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,106,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Speed_element_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1271
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Speed_element_ego_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1272
                self.ego_state()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Speed_element_agent_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1273
                self.agent_state()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Speed_element_agent_ground_truthContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1274
                self.agent_ground_truth()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Speed_element_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1275
                self.speed()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Acceleration_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def acceleration_parameter_for_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Acceleration_parameter_for_statementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Acceleration_parameter_for_statementContext,i)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_acceleration_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_statement" ):
                listener.enterAcceleration_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_statement" ):
                listener.exitAcceleration_statement(self)




    def acceleration_statement(self):

        localctx = AVScenariosParser.Acceleration_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_acceleration_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1278
            self.match(AVScenariosParser.T__111)
            self.state = 1279
            self.match(AVScenariosParser.T__1)
            self.state = 1280
            self.acceleration_parameter_for_statement()
            self.state = 1281
            self.match(AVScenariosParser.T__13)
            self.state = 1282
            self.acceleration_parameter_for_statement()
            self.state = 1283
            self.match(AVScenariosParser.T__2)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Acceleration_parameter_for_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_acceleration_parameter_for_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Acceleration_element_agent_stateContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_agent_state" ):
                listener.enterAcceleration_element_agent_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_agent_state" ):
                listener.exitAcceleration_element_agent_state(self)


    class Acceleration_element_agent_groundContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_agent_ground" ):
                listener.enterAcceleration_element_agent_ground(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_agent_ground" ):
                listener.exitAcceleration_element_agent_ground(self)


    class Acceleration_element_idContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_id" ):
                listener.enterAcceleration_element_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_id" ):
                listener.exitAcceleration_element_id(self)


    class Acceleration_element_accContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def acceleration(self):
            return self.getTypedRuleContext(AVScenariosParser.AccelerationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_acc" ):
                listener.enterAcceleration_element_acc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_acc" ):
                listener.exitAcceleration_element_acc(self)


    class Acceleration_element_ego_stateContext(Acceleration_parameter_for_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Acceleration_parameter_for_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration_element_ego_state" ):
                listener.enterAcceleration_element_ego_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration_element_ego_state" ):
                listener.exitAcceleration_element_ego_state(self)



    def acceleration_parameter_for_statement(self):

        localctx = AVScenariosParser.Acceleration_parameter_for_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_acceleration_parameter_for_statement)
        try:
            self.state = 1290
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,107,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Acceleration_element_idContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1285
                self.identifier()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Acceleration_element_ego_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1286
                self.ego_state()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Acceleration_element_agent_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1287
                self.agent_state()
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Acceleration_element_agent_groundContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1288
                self.agent_ground_truth()
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Acceleration_element_accContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1289
                self.acceleration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class AccelerationContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_acceleration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAcceleration" ):
                listener.enterAcceleration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAcceleration" ):
                listener.exitAcceleration(self)




    def acceleration(self):

        localctx = AVScenariosParser.AccelerationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_acceleration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1292
            self.coordinate_expression(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Atom_statement_parameterContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_atom_statement_parameter

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Atom_statement_varContext(Atom_statement_parameterContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Atom_statement_parameterContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_statement_overall(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_statement_overallContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_statement_var" ):
                listener.enterAtom_statement_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_statement_var" ):
                listener.exitAtom_statement_var(self)



    def atom_statement_parameter(self):

        localctx = AVScenariosParser.Atom_statement_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_atom_statement_parameter)
        try:
            localctx = AVScenariosParser.Atom_statement_varContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1294
            self.atom_statement_overall(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Atom_predicateContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def atom_statement_parameter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Atom_statement_parameterContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Atom_statement_parameterContext,i)


        def compare_operator(self):
            return self.getTypedRuleContext(AVScenariosParser.Compare_operatorContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_atom_predicate

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAtom_predicate" ):
                listener.enterAtom_predicate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAtom_predicate" ):
                listener.exitAtom_predicate(self)




    def atom_predicate(self):

        localctx = AVScenariosParser.Atom_predicateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_atom_predicate)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1296
            self.atom_statement_parameter()
            self.state = 1297
            self.compare_operator()
            self.state = 1298
            self.atom_statement_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class General_assertionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_general_assertion

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)


    class General_assertion3Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.General_assertionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,i)

        def temporal_operator1(self):
            return self.getTypedRuleContext(AVScenariosParser.Temporal_operator1Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion3" ):
                listener.enterGeneral_assertion3(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion3" ):
                listener.exitGeneral_assertion3(self)


    class General_assertion4Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.General_assertionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion4" ):
                listener.enterGeneral_assertion4(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion4" ):
                listener.exitGeneral_assertion4(self)


    class General_assertion5Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.General_assertionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion5" ):
                listener.enterGeneral_assertion5(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion5" ):
                listener.exitGeneral_assertion5(self)


    class General_assertion6Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.General_assertionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion6" ):
                listener.enterGeneral_assertion6(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion6" ):
                listener.exitGeneral_assertion6(self)


    class Traffic_rule_boolean_related_APIsContext(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def boolean_related_APIs(self):
            return self.getTypedRuleContext(AVScenariosParser.Boolean_related_APIsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTraffic_rule_boolean_related_APIs" ):
                listener.enterTraffic_rule_boolean_related_APIs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTraffic_rule_boolean_related_APIs" ):
                listener.exitTraffic_rule_boolean_related_APIs(self)


    class General_assertion0_0Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion0_0" ):
                listener.enterGeneral_assertion0_0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion0_0" ):
                listener.exitGeneral_assertion0_0(self)


    class General_assertion0Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def atom_predicate(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_predicateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion0" ):
                listener.enterGeneral_assertion0(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion0" ):
                listener.exitGeneral_assertion0(self)


    class General_assertion1Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion1" ):
                listener.enterGeneral_assertion1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion1" ):
                listener.exitGeneral_assertion1(self)


    class General_assertion2Context(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def temporal_operator(self):
            return self.getTypedRuleContext(AVScenariosParser.Temporal_operatorContext,0)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion2" ):
                listener.enterGeneral_assertion2(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion2" ):
                listener.exitGeneral_assertion2(self)


    class General_assertion_idContext(General_assertionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.General_assertionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGeneral_assertion_id" ):
                listener.enterGeneral_assertion_id(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGeneral_assertion_id" ):
                listener.exitGeneral_assertion_id(self)



    def general_assertion(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = AVScenariosParser.General_assertionContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 270
        self.enterRecursionRule(localctx, 270, self.RULE_general_assertion, _p)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1313
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,108,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Traffic_rule_boolean_related_APIsContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx

                self.state = 1301
                self.boolean_related_APIs()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.General_assertion0Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1302
                self.atom_predicate()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.General_assertion0_0Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1303
                self.match(AVScenariosParser.T__1)
                self.state = 1304
                self.general_assertion(0)
                self.state = 1305
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.General_assertion1Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1307
                self.match(AVScenariosParser.T__137)
                self.state = 1308
                self.general_assertion(7)
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.General_assertion2Context(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1309
                self.temporal_operator()
                self.state = 1310
                self.general_assertion(6)
                pass

            elif la_ == 6:
                localctx = AVScenariosParser.General_assertion_idContext(self, localctx)
                self._ctx = localctx
                _prevctx = localctx
                self.state = 1312
                self.identifier()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 1330
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,110,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 1328
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,109,self._ctx)
                    if la_ == 1:
                        localctx = AVScenariosParser.General_assertion3Context(self, AVScenariosParser.General_assertionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_general_assertion)
                        self.state = 1315
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 1316
                        self.temporal_operator1()
                        self.state = 1317
                        self.general_assertion(6)
                        pass

                    elif la_ == 2:
                        localctx = AVScenariosParser.General_assertion4Context(self, AVScenariosParser.General_assertionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_general_assertion)
                        self.state = 1319
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 1320
                        self.match(AVScenariosParser.T__15)
                        self.state = 1321
                        self.general_assertion(5)
                        pass

                    elif la_ == 3:
                        localctx = AVScenariosParser.General_assertion5Context(self, AVScenariosParser.General_assertionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_general_assertion)
                        self.state = 1322
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 1323
                        self.match(AVScenariosParser.T__138)
                        self.state = 1324
                        self.general_assertion(4)
                        pass

                    elif la_ == 4:
                        localctx = AVScenariosParser.General_assertion6Context(self, AVScenariosParser.General_assertionContext(self, _parentctx, _parentState))
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_general_assertion)
                        self.state = 1325
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 1326
                        self.match(AVScenariosParser.T__21)
                        self.state = 1327
                        self.general_assertion(3)
                        pass

             
                self.state = 1332
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,110,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx

    class Operator_related_assignmentsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def string_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.String_expressionContext,0)


        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)


        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def atom_statement_overall(self):
            return self.getTypedRuleContext(AVScenariosParser.Atom_statement_overallContext,0)


        def getRuleIndex(self):
            return AVScenariosParser.RULE_operator_related_assignments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator_related_assignments" ):
                listener.enterOperator_related_assignments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator_related_assignments" ):
                listener.exitOperator_related_assignments(self)




    def operator_related_assignments(self):

        localctx = AVScenariosParser.Operator_related_assignmentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_operator_related_assignments)
        try:
            self.state = 1337
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1333
                self.string_expression(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1334
                self.real_value_expression(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1335
                self.coordinate_expression(0)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1336
                self.atom_statement_overall(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assignment_statementsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_assignment_statements

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class AssignsContext(Assignment_statementsContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementsContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def assignment_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Assignment_statementContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Assignment_statementContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssigns" ):
                listener.enterAssigns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssigns" ):
                listener.exitAssigns(self)



    def assignment_statements(self):

        localctx = AVScenariosParser.Assignment_statementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_assignment_statements)
        self._la = 0 # Token type
        try:
            localctx = AVScenariosParser.AssignsContext(self, localctx)
            self.enterOuterAlt(localctx, 1)
            self.state = 1344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 8)) & ~0x3f) == 0 and ((1 << (_la - 8)) & ((1 << (AVScenariosParser.T__7 - 8)) | (1 << (AVScenariosParser.T__11 - 8)) | (1 << (AVScenariosParser.T__12 - 8)) | (1 << (AVScenariosParser.T__16 - 8)) | (1 << (AVScenariosParser.T__17 - 8)) | (1 << (AVScenariosParser.T__18 - 8)) | (1 << (AVScenariosParser.T__23 - 8)) | (1 << (AVScenariosParser.T__24 - 8)) | (1 << (AVScenariosParser.T__25 - 8)) | (1 << (AVScenariosParser.T__26 - 8)) | (1 << (AVScenariosParser.T__27 - 8)) | (1 << (AVScenariosParser.T__28 - 8)) | (1 << (AVScenariosParser.T__29 - 8)) | (1 << (AVScenariosParser.T__30 - 8)) | (1 << (AVScenariosParser.T__31 - 8)) | (1 << (AVScenariosParser.T__32 - 8)) | (1 << (AVScenariosParser.T__33 - 8)) | (1 << (AVScenariosParser.T__39 - 8)) | (1 << (AVScenariosParser.T__40 - 8)) | (1 << (AVScenariosParser.T__41 - 8)) | (1 << (AVScenariosParser.T__42 - 8)) | (1 << (AVScenariosParser.T__43 - 8)) | (1 << (AVScenariosParser.T__44 - 8)) | (1 << (AVScenariosParser.T__45 - 8)) | (1 << (AVScenariosParser.T__46 - 8)) | (1 << (AVScenariosParser.T__47 - 8)) | (1 << (AVScenariosParser.T__48 - 8)) | (1 << (AVScenariosParser.T__49 - 8)) | (1 << (AVScenariosParser.T__54 - 8)) | (1 << (AVScenariosParser.T__64 - 8)) | (1 << (AVScenariosParser.T__65 - 8)) | (1 << (AVScenariosParser.T__66 - 8)) | (1 << (AVScenariosParser.T__68 - 8)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (AVScenariosParser.T__130 - 131)) | (1 << (AVScenariosParser.T__132 - 131)) | (1 << (AVScenariosParser.T__133 - 131)) | (1 << (AVScenariosParser.T__134 - 131)) | (1 << (AVScenariosParser.T__140 - 131)) | (1 << (AVScenariosParser.T__141 - 131)) | (1 << (AVScenariosParser.Variable_name - 131)))) != 0):
                self.state = 1339
                self.assignment_statement()
                self.state = 1340
                self.match(AVScenariosParser.T__9)
                self.state = 1346
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Assignment_statementContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_assignment_statement

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Assign_speed_limitContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def speed_limitation(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_limitationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_speed_limit" ):
                listener.enterAssign_speed_limit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_speed_limit" ):
                listener.exitAssign_speed_limit(self)


    class Assignperception_difference_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def perception_difference_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Perception_difference_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssignperception_difference_statement" ):
                listener.enterAssignperception_difference_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssignperception_difference_statement" ):
                listener.exitAssignperception_difference_statement(self)


    class Assign_obstaclesContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def obstacles(self):
            return self.getTypedRuleContext(AVScenariosParser.ObstaclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_obstacles" ):
                listener.enterAssign_obstacles(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_obstacles" ):
                listener.exitAssign_obstacles(self)


    class Assign_npcsContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def npc_vehicles(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehiclesContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_npcs" ):
                listener.enterAssign_npcs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_npcs" ):
                listener.exitAssign_npcs(self)


    class Assign_agent_groundContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def agent_ground_truth(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_ground_truthContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_agent_ground" ):
                listener.enterAssign_agent_ground(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_agent_ground" ):
                listener.exitAssign_agent_ground(self)


    class Assign_stateContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def state_(self):
            return self.getTypedRuleContext(AVScenariosParser.State_Context,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_state" ):
                listener.enterAssign_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_state" ):
                listener.exitAssign_state(self)


    class Assign_name_two_variablesContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_name_two_variables" ):
                listener.enterAssign_name_two_variables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_name_two_variables" ):
                listener.exitAssign_name_two_variables(self)


    class Assign_name_three_variablesContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_name_three_variables" ):
                listener.enterAssign_name_three_variables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_name_three_variables" ):
                listener.exitAssign_name_three_variables(self)


    class Assign_special_case_of_coordinateContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_special_case_of_coordinate" ):
                listener.enterAssign_special_case_of_coordinate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_special_case_of_coordinate" ):
                listener.exitAssign_special_case_of_coordinate(self)


    class Assign_lane_rangeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_lane_range" ):
                listener.enterAssign_lane_range(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_lane_range" ):
                listener.exitAssign_lane_range(self)


    class Assign_shapeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def shape(self):
            return self.getTypedRuleContext(AVScenariosParser.ShapeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_shape" ):
                listener.enterAssign_shape(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_shape" ):
                listener.exitAssign_shape(self)


    class Assign_position_range_extensionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def position(self):
            return self.getTypedRuleContext(AVScenariosParser.PositionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_position_range_extension" ):
                listener.enterAssign_position_range_extension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_position_range_extension" ):
                listener.exitAssign_position_range_extension(self)


    class Assign_waypoint_motionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def waypoint_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Waypoint_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_waypoint_motion" ):
                listener.enterAssign_waypoint_motion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_waypoint_motion" ):
                listener.exitAssign_waypoint_motion(self)


    class Assign_obsContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def obstacle(self):
            return self.getTypedRuleContext(AVScenariosParser.ObstacleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_obs" ):
                listener.enterAssign_obs(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_obs" ):
                listener.exitAssign_obs(self)


    class Assign_general_assertionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_identifierContext,0)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_general_assertion" ):
                listener.enterAssign_general_assertion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_general_assertion" ):
                listener.exitAssign_general_assertion(self)


    class Assign_egoContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def ego_vehicle(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_vehicleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_ego" ):
                listener.enterAssign_ego(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_ego" ):
                listener.exitAssign_ego(self)


    class Assign_pedContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def pedestrian(self):
            return self.getTypedRuleContext(AVScenariosParser.PedestrianContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_ped" ):
                listener.enterAssign_ped(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_ped" ):
                listener.exitAssign_ped(self)


    class Assign_timeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def time(self):
            return self.getTypedRuleContext(AVScenariosParser.TimeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_time" ):
                listener.enterAssign_time(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_time" ):
                listener.exitAssign_time(self)


    class Assign_state_listContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def state_list(self):
            return self.getTypedRuleContext(AVScenariosParser.State_listContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_state_list" ):
                listener.enterAssign_state_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_state_list" ):
                listener.exitAssign_state_list(self)


    class Assign_traceContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def trace_assignment(self):
            return self.getTypedRuleContext(AVScenariosParser.Trace_assignmentContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_trace" ):
                listener.enterAssign_trace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_trace" ):
                listener.exitAssign_trace(self)


    class Assign_general_assertion_to_varContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def general_assertion(self):
            return self.getTypedRuleContext(AVScenariosParser.General_assertionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_general_assertion_to_var" ):
                listener.enterAssign_general_assertion_to_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_general_assertion_to_var" ):
                listener.exitAssign_general_assertion_to_var(self)


    class Assign_pedestrian_typeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def pedestrian_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Pedestrian_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_pedestrian_type" ):
                listener.enterAssign_pedestrian_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_pedestrian_type" ):
                listener.exitAssign_pedestrian_type(self)


    class Assign_velocity_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def velocity_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Velocity_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_velocity_statement" ):
                listener.enterAssign_velocity_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_velocity_statement" ):
                listener.exitAssign_velocity_statement(self)


    class Assign_speedContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def speed(self):
            return self.getTypedRuleContext(AVScenariosParser.SpeedContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_speed" ):
                listener.enterAssign_speed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_speed" ):
                listener.exitAssign_speed(self)


    class Assign_distance_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def distance_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Distance_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_distance_statement" ):
                listener.enterAssign_distance_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_distance_statement" ):
                listener.exitAssign_distance_statement(self)


    class Assign_operator_related_assignmentsContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def operator_related_assignments(self):
            return self.getTypedRuleContext(AVScenariosParser.Operator_related_assignmentsContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_operator_related_assignments" ):
                listener.enterAssign_operator_related_assignments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_operator_related_assignments" ):
                listener.exitAssign_operator_related_assignments(self)


    class Assign_npcContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def npc_vehicle(self):
            return self.getTypedRuleContext(AVScenariosParser.Npc_vehicleContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_npc" ):
                listener.enterAssign_npc(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_npc" ):
                listener.exitAssign_npc(self)


    class Assign_variableContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_variable" ):
                listener.enterAssign_variable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_variable" ):
                listener.exitAssign_variable(self)


    class Assign_case_of_positionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)

        def coordinate_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_expressionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_case_of_position" ):
                listener.enterAssign_case_of_position(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_case_of_position" ):
                listener.exitAssign_case_of_position(self)


    class Assign_envContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def env(self):
            return self.getTypedRuleContext(AVScenariosParser.EnvContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_env" ):
                listener.enterAssign_env(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_env" ):
                listener.exitAssign_env(self)


    class Assign_acceleration_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def acceleration_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Acceleration_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_acceleration_statement" ):
                listener.enterAssign_acceleration_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_acceleration_statement" ):
                listener.exitAssign_acceleration_statement(self)


    class Assign_ego_stateContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def ego_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Ego_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_ego_state" ):
                listener.enterAssign_ego_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_ego_state" ):
                listener.exitAssign_ego_state(self)


    class Assign_pedestriansContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def pedestrians(self):
            return self.getTypedRuleContext(AVScenariosParser.PedestriansContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_pedestrians" ):
                listener.enterAssign_pedestrians(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_pedestrians" ):
                listener.exitAssign_pedestrians(self)


    class Assign_trafficContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.TrafficContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_traffic" ):
                listener.enterAssign_traffic(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_traffic" ):
                listener.exitAssign_traffic(self)


    class Assign_vehicle_typeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def vehicle_type(self):
            return self.getTypedRuleContext(AVScenariosParser.Vehicle_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_vehicle_type" ):
                listener.enterAssign_vehicle_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_vehicle_type" ):
                listener.exitAssign_vehicle_type(self)


    class Assign_lane_rvContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def laneID_parameter(self):
            return self.getTypedRuleContext(AVScenariosParser.LaneID_parameterContext,0)

        def real_value_expression(self):
            return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,0)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_lane_rv" ):
                listener.enterAssign_lane_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_lane_rv" ):
                listener.exitAssign_lane_rv(self)


    class Assign_speed_statementContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def speed_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Speed_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_speed_statement" ):
                listener.enterAssign_speed_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_speed_statement" ):
                listener.exitAssign_speed_statement(self)


    class Assign_weatherContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def weather(self):
            return self.getTypedRuleContext(AVScenariosParser.WeatherContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_weather" ):
                listener.enterAssign_weather(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_weather" ):
                listener.exitAssign_weather(self)


    class Assign_intersectionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def meta_intersection_traffic(self):
            return self.getTypedRuleContext(AVScenariosParser.Meta_intersection_trafficContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_intersection" ):
                listener.enterAssign_intersection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_intersection" ):
                listener.exitAssign_intersection(self)


    class Assign_weather_stmtContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def weather_statement(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_statementContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_weather_stmt" ):
                listener.enterAssign_weather_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_weather_stmt" ):
                listener.exitAssign_weather_stmt(self)


    class Assign_headingContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def heading(self):
            return self.getTypedRuleContext(AVScenariosParser.HeadingContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_heading" ):
                listener.enterAssign_heading(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_heading" ):
                listener.exitAssign_heading(self)


    class Assign_scenarioContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def scenario(self):
            return self.getTypedRuleContext(AVScenariosParser.ScenarioContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_scenario" ):
                listener.enterAssign_scenario(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_scenario" ):
                listener.exitAssign_scenario(self)


    class Assign_uniform_motionContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def uniform_motion(self):
            return self.getTypedRuleContext(AVScenariosParser.Uniform_motionContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_uniform_motion" ):
                listener.enterAssign_uniform_motion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_uniform_motion" ):
                listener.exitAssign_uniform_motion(self)


    class Assign_general_typeContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def general_type(self):
            return self.getTypedRuleContext(AVScenariosParser.General_typeContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_general_type" ):
                listener.enterAssign_general_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_general_type" ):
                listener.exitAssign_general_type(self)


    class Assign_variablesContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,i)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_variables" ):
                listener.enterAssign_variables(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_variables" ):
                listener.exitAssign_variables(self)


    class Assign_rv_rvContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.op = None # Token
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def real_value_expression(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(AVScenariosParser.Real_value_expressionContext)
            else:
                return self.getTypedRuleContext(AVScenariosParser.Real_value_expressionContext,i)

        def coordinate_frame(self):
            return self.getTypedRuleContext(AVScenariosParser.Coordinate_frameContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_rv_rv" ):
                listener.enterAssign_rv_rv(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_rv_rv" ):
                listener.exitAssign_rv_rv(self)


    class Assign_colorContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def color(self):
            return self.getTypedRuleContext(AVScenariosParser.ColorContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_color" ):
                listener.enterAssign_color(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_color" ):
                listener.exitAssign_color(self)


    class Assign_agent_stateContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def agent_state(self):
            return self.getTypedRuleContext(AVScenariosParser.Agent_stateContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_agent_state" ):
                listener.enterAssign_agent_state(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_agent_state" ):
                listener.exitAssign_agent_state(self)


    class Assign_weather_discreteContext(Assignment_statementContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a AVScenariosParser.Assignment_statementContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identifier(self):
            return self.getTypedRuleContext(AVScenariosParser.IdentifierContext,0)

        def weather_discrete_level(self):
            return self.getTypedRuleContext(AVScenariosParser.Weather_discrete_levelContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_weather_discrete" ):
                listener.enterAssign_weather_discrete(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_weather_discrete" ):
                listener.exitAssign_weather_discrete(self)



    def assignment_statement(self):

        localctx = AVScenariosParser.Assignment_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_assignment_statement)
        self._la = 0 # Token type
        try:
            self.state = 1594
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
            if la_ == 1:
                localctx = AVScenariosParser.Assign_scenarioContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 1347
                self.identifier()
                self.state = 1348
                self.match(AVScenariosParser.T__67)
                self.state = 1349
                self.scenario()
                pass

            elif la_ == 2:
                localctx = AVScenariosParser.Assign_egoContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 1351
                self.identifier()
                self.state = 1352
                self.match(AVScenariosParser.T__67)
                self.state = 1353
                self.ego_vehicle()
                pass

            elif la_ == 3:
                localctx = AVScenariosParser.Assign_variableContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 1355
                self.identifier()
                self.state = 1356
                self.match(AVScenariosParser.T__67)
                self.state = 1357
                self.match(AVScenariosParser.T__1)
                self.state = 1358
                self.identifier()
                self.state = 1359
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 4:
                localctx = AVScenariosParser.Assign_name_two_variablesContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 1361
                self.identifier()
                self.state = 1362
                self.match(AVScenariosParser.T__67)
                self.state = 1363
                self.match(AVScenariosParser.T__1)
                self.state = 1364
                self.identifier()
                self.state = 1365
                self.match(AVScenariosParser.T__13)
                self.state = 1366
                self.identifier()
                self.state = 1367
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 5:
                localctx = AVScenariosParser.Assign_name_three_variablesContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 1369
                self.identifier()
                self.state = 1370
                self.match(AVScenariosParser.T__67)
                self.state = 1371
                self.match(AVScenariosParser.T__1)
                self.state = 1372
                self.identifier()
                self.state = 1373
                self.match(AVScenariosParser.T__13)
                self.state = 1374
                self.identifier()
                self.state = 1375
                self.match(AVScenariosParser.T__13)
                self.state = 1376
                self.identifier()
                self.state = 1377
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 6:
                localctx = AVScenariosParser.Assign_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 1379
                self.identifier()
                self.state = 1380
                self.match(AVScenariosParser.T__67)
                self.state = 1381
                self.state_()
                pass

            elif la_ == 7:
                localctx = AVScenariosParser.Assign_vehicle_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 1383
                self.identifier()
                self.state = 1384
                self.match(AVScenariosParser.T__67)
                self.state = 1385
                self.vehicle_type()
                pass

            elif la_ == 8:
                localctx = AVScenariosParser.Assign_state_listContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 1387
                self.identifier()
                self.state = 1388
                self.match(AVScenariosParser.T__67)
                self.state = 1389
                self.state_list()
                pass

            elif la_ == 9:
                localctx = AVScenariosParser.Assign_pedestrian_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 9)
                self.state = 1391
                self.identifier()
                self.state = 1392
                self.match(AVScenariosParser.T__67)
                self.state = 1393
                self.pedestrian_type()
                pass

            elif la_ == 10:
                localctx = AVScenariosParser.Assign_case_of_positionContext(self, localctx)
                self.enterOuterAlt(localctx, 10)
                self.state = 1395
                self.identifier()
                self.state = 1396
                self.match(AVScenariosParser.T__67)
                self.state = 1397
                self.coordinate_frame()
                self.state = 1398
                self.coordinate_expression(0)
                pass

            elif la_ == 11:
                localctx = AVScenariosParser.Assign_rv_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 11)
                self.state = 1400
                self.identifier()
                self.state = 1401
                self.match(AVScenariosParser.T__67)
                self.state = 1403
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << AVScenariosParser.T__16) | (1 << AVScenariosParser.T__17) | (1 << AVScenariosParser.T__18))) != 0):
                    self.state = 1402
                    self.coordinate_frame()


                self.state = 1405
                self.match(AVScenariosParser.T__1)
                self.state = 1406
                self.real_value_expression(0)
                self.state = 1407
                self.match(AVScenariosParser.T__13)
                self.state = 1408
                self.real_value_expression(0)
                self.state = 1412
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==AVScenariosParser.T__13:
                    self.state = 1409
                    self.match(AVScenariosParser.T__13)
                    self.state = 1410
                    localctx.op = self._input.LT(1)
                    _la = self._input.LA(1)
                    if not(_la==AVScenariosParser.T__0 or _la==AVScenariosParser.T__6):
                        localctx.op = self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1411
                    self.real_value_expression(0)


                self.state = 1414
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 12:
                localctx = AVScenariosParser.Assign_lane_rvContext(self, localctx)
                self.enterOuterAlt(localctx, 12)
                self.state = 1416
                self.identifier()
                self.state = 1417
                self.match(AVScenariosParser.T__67)
                self.state = 1419
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,115,self._ctx)
                if la_ == 1:
                    self.state = 1418
                    self.coordinate_frame()


                self.state = 1421
                self.laneID_parameter()
                self.state = 1422
                self.match(AVScenariosParser.T__21)
                self.state = 1423
                self.real_value_expression(0)
                pass

            elif la_ == 13:
                localctx = AVScenariosParser.Assign_lane_rangeContext(self, localctx)
                self.enterOuterAlt(localctx, 13)
                self.state = 1425
                self.identifier()
                self.state = 1426
                self.match(AVScenariosParser.T__67)
                self.state = 1428
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,116,self._ctx)
                if la_ == 1:
                    self.state = 1427
                    self.coordinate_frame()


                self.state = 1430
                self.laneID_parameter()
                self.state = 1431
                self.match(AVScenariosParser.T__21)
                self.state = 1432
                self.match(AVScenariosParser.T__14)
                self.state = 1433
                self.match(AVScenariosParser.T__1)
                self.state = 1434
                self.real_value_expression(0)
                self.state = 1435
                self.match(AVScenariosParser.T__13)
                self.state = 1436
                self.real_value_expression(0)
                self.state = 1437
                self.match(AVScenariosParser.T__2)
                pass

            elif la_ == 14:
                localctx = AVScenariosParser.Assign_special_case_of_coordinateContext(self, localctx)
                self.enterOuterAlt(localctx, 14)
                self.state = 1439
                self.identifier()
                self.state = 1440
                self.match(AVScenariosParser.T__67)
                self.state = 1441
                self.coordinate_frame()
                self.state = 1442
                self.identifier()
                pass

            elif la_ == 15:
                localctx = AVScenariosParser.Assign_headingContext(self, localctx)
                self.enterOuterAlt(localctx, 15)
                self.state = 1444
                self.identifier()
                self.state = 1445
                self.match(AVScenariosParser.T__67)
                self.state = 1446
                self.heading()
                pass

            elif la_ == 16:
                localctx = AVScenariosParser.Assign_general_typeContext(self, localctx)
                self.enterOuterAlt(localctx, 16)
                self.state = 1448
                self.identifier()
                self.state = 1449
                self.match(AVScenariosParser.T__67)
                self.state = 1450
                self.general_type()
                pass

            elif la_ == 17:
                localctx = AVScenariosParser.Assign_colorContext(self, localctx)
                self.enterOuterAlt(localctx, 17)
                self.state = 1452
                self.identifier()
                self.state = 1453
                self.match(AVScenariosParser.T__67)
                self.state = 1454
                self.color()
                pass

            elif la_ == 18:
                localctx = AVScenariosParser.Assign_npcContext(self, localctx)
                self.enterOuterAlt(localctx, 18)
                self.state = 1456
                self.identifier()
                self.state = 1457
                self.match(AVScenariosParser.T__67)
                self.state = 1458
                self.npc_vehicle()
                pass

            elif la_ == 19:
                localctx = AVScenariosParser.Assign_uniform_motionContext(self, localctx)
                self.enterOuterAlt(localctx, 19)
                self.state = 1460
                self.identifier()
                self.state = 1461
                self.match(AVScenariosParser.T__67)
                self.state = 1462
                self.uniform_motion()
                pass

            elif la_ == 20:
                localctx = AVScenariosParser.Assign_waypoint_motionContext(self, localctx)
                self.enterOuterAlt(localctx, 20)
                self.state = 1464
                self.identifier()
                self.state = 1465
                self.match(AVScenariosParser.T__67)
                self.state = 1466
                self.waypoint_motion()
                pass

            elif la_ == 21:
                localctx = AVScenariosParser.Assign_state_listContext(self, localctx)
                self.enterOuterAlt(localctx, 21)
                self.state = 1468
                self.identifier()
                self.state = 1469
                self.match(AVScenariosParser.T__67)
                self.state = 1470
                self.state_list()
                pass

            elif la_ == 22:
                localctx = AVScenariosParser.Assign_variablesContext(self, localctx)
                self.enterOuterAlt(localctx, 22)
                self.state = 1472
                self.identifier()
                self.state = 1473
                self.match(AVScenariosParser.T__67)
                self.state = 1474
                self.match(AVScenariosParser.T__8)
                self.state = 1475
                self.identifier()
                self.state = 1480
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==AVScenariosParser.T__13:
                    self.state = 1476
                    self.match(AVScenariosParser.T__13)
                    self.state = 1477
                    self.identifier()
                    self.state = 1482
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1483
                self.match(AVScenariosParser.T__10)
                pass

            elif la_ == 23:
                localctx = AVScenariosParser.Assign_pedestriansContext(self, localctx)
                self.enterOuterAlt(localctx, 23)
                self.state = 1485
                self.identifier()
                self.state = 1486
                self.match(AVScenariosParser.T__67)
                self.state = 1487
                self.pedestrians()
                pass

            elif la_ == 24:
                localctx = AVScenariosParser.Assign_npcsContext(self, localctx)
                self.enterOuterAlt(localctx, 24)
                self.state = 1489
                self.identifier()
                self.state = 1490
                self.match(AVScenariosParser.T__67)
                self.state = 1491
                self.npc_vehicles()
                pass

            elif la_ == 25:
                localctx = AVScenariosParser.Assign_obstaclesContext(self, localctx)
                self.enterOuterAlt(localctx, 25)
                self.state = 1493
                self.identifier()
                self.state = 1494
                self.match(AVScenariosParser.T__67)
                self.state = 1495
                self.obstacles()
                pass

            elif la_ == 26:
                localctx = AVScenariosParser.Assign_weatherContext(self, localctx)
                self.enterOuterAlt(localctx, 26)
                self.state = 1497
                self.identifier()
                self.state = 1498
                self.match(AVScenariosParser.T__67)
                self.state = 1499
                self.weather()
                pass

            elif la_ == 27:
                localctx = AVScenariosParser.Assign_trafficContext(self, localctx)
                self.enterOuterAlt(localctx, 27)
                self.state = 1501
                self.identifier()
                self.state = 1502
                self.match(AVScenariosParser.T__67)
                self.state = 1503
                self.traffic()
                pass

            elif la_ == 28:
                localctx = AVScenariosParser.Assign_pedContext(self, localctx)
                self.enterOuterAlt(localctx, 28)
                self.state = 1505
                self.identifier()
                self.state = 1506
                self.match(AVScenariosParser.T__67)
                self.state = 1507
                self.pedestrian()
                pass

            elif la_ == 29:
                localctx = AVScenariosParser.Assign_obsContext(self, localctx)
                self.enterOuterAlt(localctx, 29)
                self.state = 1509
                self.identifier()
                self.state = 1510
                self.match(AVScenariosParser.T__67)
                self.state = 1511
                self.obstacle()
                pass

            elif la_ == 30:
                localctx = AVScenariosParser.Assign_shapeContext(self, localctx)
                self.enterOuterAlt(localctx, 30)
                self.state = 1513
                self.identifier()
                self.state = 1514
                self.match(AVScenariosParser.T__67)
                self.state = 1515
                self.shape()
                pass

            elif la_ == 31:
                localctx = AVScenariosParser.Assign_envContext(self, localctx)
                self.enterOuterAlt(localctx, 31)
                self.state = 1517
                self.identifier()
                self.state = 1518
                self.match(AVScenariosParser.T__67)
                self.state = 1519
                self.env()
                pass

            elif la_ == 32:
                localctx = AVScenariosParser.Assign_timeContext(self, localctx)
                self.enterOuterAlt(localctx, 32)
                self.state = 1521
                self.identifier()
                self.state = 1522
                self.match(AVScenariosParser.T__67)
                self.state = 1523
                self.time()
                pass

            elif la_ == 33:
                localctx = AVScenariosParser.Assign_weather_stmtContext(self, localctx)
                self.enterOuterAlt(localctx, 33)
                self.state = 1525
                self.identifier()
                self.state = 1526
                self.match(AVScenariosParser.T__67)
                self.state = 1527
                self.weather_statement()
                pass

            elif la_ == 34:
                localctx = AVScenariosParser.Assign_weather_discreteContext(self, localctx)
                self.enterOuterAlt(localctx, 34)
                self.state = 1529
                self.identifier()
                self.state = 1530
                self.match(AVScenariosParser.T__67)
                self.state = 1531
                self.weather_discrete_level()
                pass

            elif la_ == 35:
                localctx = AVScenariosParser.Assign_intersectionContext(self, localctx)
                self.enterOuterAlt(localctx, 35)
                self.state = 1533
                self.identifier()
                self.state = 1534
                self.match(AVScenariosParser.T__67)
                self.state = 1535
                self.meta_intersection_traffic()
                pass

            elif la_ == 36:
                localctx = AVScenariosParser.Assign_speed_limitContext(self, localctx)
                self.enterOuterAlt(localctx, 36)
                self.state = 1537
                self.identifier()
                self.state = 1538
                self.match(AVScenariosParser.T__67)
                self.state = 1539
                self.speed_limitation()
                pass

            elif la_ == 37:
                localctx = AVScenariosParser.Assign_traceContext(self, localctx)
                self.enterOuterAlt(localctx, 37)
                self.state = 1541
                self.trace_assignment()
                pass

            elif la_ == 38:
                localctx = AVScenariosParser.Assign_distance_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 38)
                self.state = 1542
                self.identifier()
                self.state = 1543
                self.match(AVScenariosParser.T__67)
                self.state = 1544
                self.distance_statement()
                pass

            elif la_ == 39:
                localctx = AVScenariosParser.Assignperception_difference_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 39)
                self.state = 1546
                self.identifier()
                self.state = 1547
                self.match(AVScenariosParser.T__67)
                self.state = 1548
                self.perception_difference_statement()
                pass

            elif la_ == 40:
                localctx = AVScenariosParser.Assign_velocity_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 40)
                self.state = 1550
                self.identifier()
                self.state = 1551
                self.match(AVScenariosParser.T__67)
                self.state = 1552
                self.velocity_statement()
                pass

            elif la_ == 41:
                localctx = AVScenariosParser.Assign_speed_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 41)
                self.state = 1554
                self.identifier()
                self.state = 1555
                self.match(AVScenariosParser.T__67)
                self.state = 1556
                self.speed_statement()
                pass

            elif la_ == 42:
                localctx = AVScenariosParser.Assign_acceleration_statementContext(self, localctx)
                self.enterOuterAlt(localctx, 42)
                self.state = 1558
                self.identifier()
                self.state = 1559
                self.match(AVScenariosParser.T__67)
                self.state = 1560
                self.acceleration_statement()
                pass

            elif la_ == 43:
                localctx = AVScenariosParser.Assign_operator_related_assignmentsContext(self, localctx)
                self.enterOuterAlt(localctx, 43)
                self.state = 1562
                self.identifier()
                self.state = 1563
                self.match(AVScenariosParser.T__67)
                self.state = 1564
                self.operator_related_assignments()
                pass

            elif la_ == 44:
                localctx = AVScenariosParser.Assign_general_assertion_to_varContext(self, localctx)
                self.enterOuterAlt(localctx, 44)
                self.state = 1566
                self.identifier()
                self.state = 1567
                self.match(AVScenariosParser.T__67)
                self.state = 1568
                self.general_assertion(0)
                pass

            elif la_ == 45:
                localctx = AVScenariosParser.Assign_general_assertionContext(self, localctx)
                self.enterOuterAlt(localctx, 45)
                self.state = 1570
                self.trace_identifier()
                self.state = 1571
                self.match(AVScenariosParser.T__139)
                self.state = 1572
                self.general_assertion(0)
                pass

            elif la_ == 46:
                localctx = AVScenariosParser.Assign_agent_groundContext(self, localctx)
                self.enterOuterAlt(localctx, 46)
                self.state = 1574
                self.identifier()
                self.state = 1575
                self.match(AVScenariosParser.T__67)
                self.state = 1576
                self.agent_ground_truth()
                pass

            elif la_ == 47:
                localctx = AVScenariosParser.Assign_ego_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 47)
                self.state = 1578
                self.identifier()
                self.state = 1579
                self.match(AVScenariosParser.T__67)
                self.state = 1580
                self.ego_state()
                pass

            elif la_ == 48:
                localctx = AVScenariosParser.Assign_agent_stateContext(self, localctx)
                self.enterOuterAlt(localctx, 48)
                self.state = 1582
                self.identifier()
                self.state = 1583
                self.match(AVScenariosParser.T__67)
                self.state = 1584
                self.agent_state()
                pass

            elif la_ == 49:
                localctx = AVScenariosParser.Assign_speedContext(self, localctx)
                self.enterOuterAlt(localctx, 49)
                self.state = 1586
                self.identifier()
                self.state = 1587
                self.match(AVScenariosParser.T__67)
                self.state = 1588
                self.speed()
                pass

            elif la_ == 50:
                localctx = AVScenariosParser.Assign_position_range_extensionContext(self, localctx)
                self.enterOuterAlt(localctx, 50)
                self.state = 1590
                self.identifier()
                self.state = 1591
                self.match(AVScenariosParser.T__67)
                self.state = 1592
                self.position()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class IdentifierContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Variable_name(self):
            return self.getToken(AVScenariosParser.Variable_name, 0)

        def getRuleIndex(self):
            return AVScenariosParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = AVScenariosParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1596
            _la = self._input.LA(1)
            if not(((((_la - 8)) & ~0x3f) == 0 and ((1 << (_la - 8)) & ((1 << (AVScenariosParser.T__7 - 8)) | (1 << (AVScenariosParser.T__11 - 8)) | (1 << (AVScenariosParser.T__12 - 8)) | (1 << (AVScenariosParser.T__16 - 8)) | (1 << (AVScenariosParser.T__17 - 8)) | (1 << (AVScenariosParser.T__18 - 8)) | (1 << (AVScenariosParser.T__23 - 8)) | (1 << (AVScenariosParser.T__24 - 8)) | (1 << (AVScenariosParser.T__25 - 8)) | (1 << (AVScenariosParser.T__26 - 8)) | (1 << (AVScenariosParser.T__27 - 8)) | (1 << (AVScenariosParser.T__28 - 8)) | (1 << (AVScenariosParser.T__29 - 8)) | (1 << (AVScenariosParser.T__30 - 8)) | (1 << (AVScenariosParser.T__31 - 8)) | (1 << (AVScenariosParser.T__32 - 8)) | (1 << (AVScenariosParser.T__33 - 8)) | (1 << (AVScenariosParser.T__39 - 8)) | (1 << (AVScenariosParser.T__40 - 8)) | (1 << (AVScenariosParser.T__41 - 8)) | (1 << (AVScenariosParser.T__42 - 8)) | (1 << (AVScenariosParser.T__43 - 8)) | (1 << (AVScenariosParser.T__44 - 8)) | (1 << (AVScenariosParser.T__45 - 8)) | (1 << (AVScenariosParser.T__46 - 8)) | (1 << (AVScenariosParser.T__47 - 8)) | (1 << (AVScenariosParser.T__48 - 8)) | (1 << (AVScenariosParser.T__49 - 8)) | (1 << (AVScenariosParser.T__54 - 8)) | (1 << (AVScenariosParser.T__64 - 8)) | (1 << (AVScenariosParser.T__65 - 8)) | (1 << (AVScenariosParser.T__68 - 8)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (AVScenariosParser.T__130 - 131)) | (1 << (AVScenariosParser.T__132 - 131)) | (1 << (AVScenariosParser.T__133 - 131)) | (1 << (AVScenariosParser.T__134 - 131)) | (1 << (AVScenariosParser.T__140 - 131)) | (1 << (AVScenariosParser.T__141 - 131)) | (1 << (AVScenariosParser.Variable_name - 131)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx

    class Arithmetic_operatorContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return AVScenariosParser.RULE_arithmetic_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArithmetic_operator" ):
                listener.enterArithmetic_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArithmetic_operator" ):
                listener.exitArithmetic_operator(self)




    def arithmetic_operator(self):

        localctx = AVScenariosParser.Arithmetic_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_arithmetic_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1598
            _la = self._input.LA(1)
            if not(((((_la - 143)) & ~0x3f) == 0 and ((1 << (_la - 143)) & ((1 << (AVScenariosParser.T__142 - 143)) | (1 << (AVScenariosParser.T__143 - 143)) | (1 << (AVScenariosParser.T__144 - 143)) | (1 << (AVScenariosParser.T__145 - 143)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[1] = self.string_expression_sempred
        self._predicates[2] = self.real_value_expression_sempred
        self._predicates[3] = self.coordinate_expression_sempred
        self._predicates[43] = self.multi_npc_vehicles_sempred
        self._predicates[54] = self.multi_states_sempred
        self._predicates[57] = self.multiple_pedestrians_sempred
        self._predicates[68] = self.multiple_obstacles_sempred
        self._predicates[85] = self.multi_weathers_sempred
        self._predicates[99] = self.lane_traffic_sempred
        self._predicates[111] = self.atom_statement_overall_sempred
        self._predicates[135] = self.general_assertion_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def string_expression_sempred(self, localctx:String_expressionContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 2)
         

    def real_value_expression_sempred(self, localctx:Real_value_expressionContext, predIndex:int):
            if predIndex == 1:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 2)
         

    def coordinate_expression_sempred(self, localctx:Coordinate_expressionContext, predIndex:int):
            if predIndex == 4:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 2)
         

    def multi_npc_vehicles_sempred(self, localctx:Multi_npc_vehiclesContext, predIndex:int):
            if predIndex == 6:
                return self.precpred(self._ctx, 1)
         

    def multi_states_sempred(self, localctx:Multi_statesContext, predIndex:int):
            if predIndex == 7:
                return self.precpred(self._ctx, 2)
         

    def multiple_pedestrians_sempred(self, localctx:Multiple_pedestriansContext, predIndex:int):
            if predIndex == 8:
                return self.precpred(self._ctx, 1)
         

    def multiple_obstacles_sempred(self, localctx:Multiple_obstaclesContext, predIndex:int):
            if predIndex == 9:
                return self.precpred(self._ctx, 1)
         

    def multi_weathers_sempred(self, localctx:Multi_weathersContext, predIndex:int):
            if predIndex == 10:
                return self.precpred(self._ctx, 1)
         

    def lane_traffic_sempred(self, localctx:Lane_trafficContext, predIndex:int):
            if predIndex == 11:
                return self.precpred(self._ctx, 1)
         

    def atom_statement_overall_sempred(self, localctx:Atom_statement_overallContext, predIndex:int):
            if predIndex == 12:
                return self.precpred(self._ctx, 2)
         

    def general_assertion_sempred(self, localctx:General_assertionContext, predIndex:int):
            if predIndex == 13:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 2)
         




